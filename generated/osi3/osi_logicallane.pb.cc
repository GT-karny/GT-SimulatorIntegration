// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: osi_logicallane.proto
// Protobuf C++ Version: 5.29.5

#include "osi_logicallane.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace osi3 {

inline constexpr LogicalLaneBoundary_LogicalBoundaryPoint::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        position_{nullptr},
        s_position_{0},
        t_position_{0} {}

template <typename>
PROTOBUF_CONSTEXPR LogicalLaneBoundary_LogicalBoundaryPoint::LogicalLaneBoundary_LogicalBoundaryPoint(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LogicalLaneBoundary_LogicalBoundaryPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogicalLaneBoundary_LogicalBoundaryPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogicalLaneBoundary_LogicalBoundaryPointDefaultTypeInternal() {}
  union {
    LogicalLaneBoundary_LogicalBoundaryPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogicalLaneBoundary_LogicalBoundaryPointDefaultTypeInternal _LogicalLaneBoundary_LogicalBoundaryPoint_default_instance_;

inline constexpr LogicalLane_PhysicalLaneReference::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        physical_lane_id_{nullptr},
        start_s_{0},
        end_s_{0} {}

template <typename>
PROTOBUF_CONSTEXPR LogicalLane_PhysicalLaneReference::LogicalLane_PhysicalLaneReference(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LogicalLane_PhysicalLaneReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogicalLane_PhysicalLaneReferenceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogicalLane_PhysicalLaneReferenceDefaultTypeInternal() {}
  union {
    LogicalLane_PhysicalLaneReference _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogicalLane_PhysicalLaneReferenceDefaultTypeInternal _LogicalLane_PhysicalLaneReference_default_instance_;

inline constexpr LogicalLane_LaneRelation::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        other_lane_id_{nullptr},
        start_s_{0},
        end_s_{0},
        start_s_other_{0},
        end_s_other_{0} {}

template <typename>
PROTOBUF_CONSTEXPR LogicalLane_LaneRelation::LogicalLane_LaneRelation(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LogicalLane_LaneRelationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogicalLane_LaneRelationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogicalLane_LaneRelationDefaultTypeInternal() {}
  union {
    LogicalLane_LaneRelation _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogicalLane_LaneRelationDefaultTypeInternal _LogicalLane_LaneRelation_default_instance_;

inline constexpr LogicalLane_LaneConnection::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        other_lane_id_{nullptr},
        at_begin_of_other_lane_{false} {}

template <typename>
PROTOBUF_CONSTEXPR LogicalLane_LaneConnection::LogicalLane_LaneConnection(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LogicalLane_LaneConnectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogicalLane_LaneConnectionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogicalLane_LaneConnectionDefaultTypeInternal() {}
  union {
    LogicalLane_LaneConnection _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogicalLane_LaneConnectionDefaultTypeInternal _LogicalLane_LaneConnection_default_instance_;

inline constexpr LogicalLaneBoundary::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        boundary_line_{},
        physical_boundary_id_{},
        source_reference_{},
        id_{nullptr},
        reference_line_id_{nullptr},
        passing_rule_{static_cast< ::osi3::LogicalLaneBoundary_PassingRule >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR LogicalLaneBoundary::LogicalLaneBoundary(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LogicalLaneBoundaryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogicalLaneBoundaryDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogicalLaneBoundaryDefaultTypeInternal() {}
  union {
    LogicalLaneBoundary _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogicalLaneBoundaryDefaultTypeInternal _LogicalLaneBoundary_default_instance_;

inline constexpr LogicalLane::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        source_reference_{},
        physical_lane_reference_{},
        right_adjacent_lane_{},
        left_adjacent_lane_{},
        overlapping_lane_{},
        right_boundary_id_{},
        left_boundary_id_{},
        predecessor_lane_{},
        successor_lane_{},
        id_{nullptr},
        reference_line_id_{nullptr},
        type_{static_cast< ::osi3::LogicalLane_Type >(0)},
        move_direction_{static_cast< ::osi3::LogicalLane_MoveDirection >(0)},
        start_s_{0},
        end_s_{0} {}

template <typename>
PROTOBUF_CONSTEXPR LogicalLane::LogicalLane(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LogicalLaneDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogicalLaneDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogicalLaneDefaultTypeInternal() {}
  union {
    LogicalLane _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogicalLaneDefaultTypeInternal _LogicalLane_default_instance_;
}  // namespace osi3
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_osi_5flogicallane_2eproto[3];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_osi_5flogicallane_2eproto = nullptr;
const ::uint32_t
    TableStruct_osi_5flogicallane_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneBoundary_LogicalBoundaryPoint, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneBoundary_LogicalBoundaryPoint, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneBoundary_LogicalBoundaryPoint, _impl_.position_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneBoundary_LogicalBoundaryPoint, _impl_.s_position_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneBoundary_LogicalBoundaryPoint, _impl_.t_position_),
        0,
        1,
        2,
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneBoundary, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneBoundary, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneBoundary, _impl_.id_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneBoundary, _impl_.boundary_line_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneBoundary, _impl_.reference_line_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneBoundary, _impl_.physical_boundary_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneBoundary, _impl_.passing_rule_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLaneBoundary, _impl_.source_reference_),
        0,
        ~0u,
        1,
        ~0u,
        2,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane_PhysicalLaneReference, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane_PhysicalLaneReference, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane_PhysicalLaneReference, _impl_.physical_lane_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane_PhysicalLaneReference, _impl_.start_s_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane_PhysicalLaneReference, _impl_.end_s_),
        0,
        1,
        2,
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane_LaneConnection, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane_LaneConnection, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane_LaneConnection, _impl_.other_lane_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane_LaneConnection, _impl_.at_begin_of_other_lane_),
        0,
        1,
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane_LaneRelation, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane_LaneRelation, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane_LaneRelation, _impl_.other_lane_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane_LaneRelation, _impl_.start_s_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane_LaneRelation, _impl_.end_s_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane_LaneRelation, _impl_.start_s_other_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane_LaneRelation, _impl_.end_s_other_),
        0,
        1,
        2,
        3,
        4,
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane, _impl_.id_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane, _impl_.type_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane, _impl_.source_reference_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane, _impl_.physical_lane_reference_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane, _impl_.reference_line_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane, _impl_.start_s_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane, _impl_.end_s_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane, _impl_.move_direction_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane, _impl_.right_adjacent_lane_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane, _impl_.left_adjacent_lane_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane, _impl_.overlapping_lane_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane, _impl_.right_boundary_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane, _impl_.left_boundary_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane, _impl_.predecessor_lane_),
        PROTOBUF_FIELD_OFFSET(::osi3::LogicalLane, _impl_.successor_lane_),
        0,
        2,
        ~0u,
        ~0u,
        1,
        4,
        5,
        3,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, 11, -1, sizeof(::osi3::LogicalLaneBoundary_LogicalBoundaryPoint)},
        {14, 28, -1, sizeof(::osi3::LogicalLaneBoundary)},
        {34, 45, -1, sizeof(::osi3::LogicalLane_PhysicalLaneReference)},
        {48, 58, -1, sizeof(::osi3::LogicalLane_LaneConnection)},
        {60, 73, -1, sizeof(::osi3::LogicalLane_LaneRelation)},
        {78, 101, -1, sizeof(::osi3::LogicalLane)},
};
static const ::_pb::Message* const file_default_instances[] = {
    &::osi3::_LogicalLaneBoundary_LogicalBoundaryPoint_default_instance_._instance,
    &::osi3::_LogicalLaneBoundary_default_instance_._instance,
    &::osi3::_LogicalLane_PhysicalLaneReference_default_instance_._instance,
    &::osi3::_LogicalLane_LaneConnection_default_instance_._instance,
    &::osi3::_LogicalLane_LaneRelation_default_instance_._instance,
    &::osi3::_LogicalLane_default_instance_._instance,
};
const char descriptor_table_protodef_osi_5flogicallane_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\025osi_logicallane.proto\022\004osi3\032\020osi_commo"
    "n.proto\"\347\004\n\023LogicalLaneBoundary\022\034\n\002id\030\001 "
    "\001(\0132\020.osi3.Identifier\022E\n\rboundary_line\030\002"
    " \003(\0132..osi3.LogicalLaneBoundary.LogicalB"
    "oundaryPoint\022+\n\021reference_line_id\030\003 \001(\0132"
    "\020.osi3.Identifier\022.\n\024physical_boundary_i"
    "d\030\004 \003(\0132\020.osi3.Identifier\022;\n\014passing_rul"
    "e\030\005 \001(\0162%.osi3.LogicalLaneBoundary.Passi"
    "ngRule\0221\n\020source_reference\030\006 \003(\0132\027.osi3."
    "ExternalReference\032`\n\024LogicalBoundaryPoin"
    "t\022 \n\010position\030\001 \001(\0132\016.osi3.Vector3d\022\022\n\ns"
    "_position\030\002 \001(\001\022\022\n\nt_position\030\003 \001(\001\"\273\001\n\013"
    "PassingRule\022\030\n\024PASSING_RULE_UNKNOWN\020\000\022\026\n"
    "\022PASSING_RULE_OTHER\020\001\022\035\n\031PASSING_RULE_NO"
    "NE_ALLOWED\020\002\022\035\n\031PASSING_RULE_INCREASING_"
    "T\020\003\022\035\n\031PASSING_RULE_DECREASING_T\020\004\022\035\n\031PA"
    "SSING_RULE_BOTH_ALLOWED\020\005\"\232\014\n\013LogicalLan"
    "e\022\034\n\002id\030\001 \001(\0132\020.osi3.Identifier\022$\n\004type\030"
    "\002 \001(\0162\026.osi3.LogicalLane.Type\0221\n\020source_"
    "reference\030\003 \003(\0132\027.osi3.ExternalReference"
    "\022H\n\027physical_lane_reference\030\004 \003(\0132\'.osi3"
    ".LogicalLane.PhysicalLaneReference\022+\n\021re"
    "ference_line_id\030\005 \001(\0132\020.osi3.Identifier\022"
    "\017\n\007start_s\030\006 \001(\001\022\r\n\005end_s\030\007 \001(\001\0227\n\016move_"
    "direction\030\010 \001(\0162\037.osi3.LogicalLane.MoveD"
    "irection\022;\n\023right_adjacent_lane\030\t \003(\0132\036."
    "osi3.LogicalLane.LaneRelation\022:\n\022left_ad"
    "jacent_lane\030\n \003(\0132\036.osi3.LogicalLane.Lan"
    "eRelation\0228\n\020overlapping_lane\030\013 \003(\0132\036.os"
    "i3.LogicalLane.LaneRelation\022+\n\021right_bou"
    "ndary_id\030\014 \003(\0132\020.osi3.Identifier\022*\n\020left"
    "_boundary_id\030\r \003(\0132\020.osi3.Identifier\022:\n\020"
    "predecessor_lane\030\016 \003(\0132 .osi3.LogicalLan"
    "e.LaneConnection\0228\n\016successor_lane\030\017 \003(\013"
    "2 .osi3.LogicalLane.LaneConnection\032c\n\025Ph"
    "ysicalLaneReference\022*\n\020physical_lane_id\030"
    "\001 \001(\0132\020.osi3.Identifier\022\017\n\007start_s\030\002 \001(\001"
    "\022\r\n\005end_s\030\003 \001(\001\032Y\n\016LaneConnection\022\'\n\roth"
    "er_lane_id\030\001 \001(\0132\020.osi3.Identifier\022\036\n\026at"
    "_begin_of_other_lane\030\002 \001(\010\032\203\001\n\014LaneRelat"
    "ion\022\'\n\rother_lane_id\030\001 \001(\0132\020.osi3.Identi"
    "fier\022\017\n\007start_s\030\002 \001(\001\022\r\n\005end_s\030\003 \001(\001\022\025\n\r"
    "start_s_other\030\004 \001(\001\022\023\n\013end_s_other\030\005 \001(\001"
    "\"\320\002\n\004Type\022\020\n\014TYPE_UNKNOWN\020\000\022\016\n\nTYPE_OTHE"
    "R\020\001\022\017\n\013TYPE_NORMAL\020\002\022\017\n\013TYPE_BIKING\020\003\022\021\n"
    "\rTYPE_SIDEWALK\020\004\022\020\n\014TYPE_PARKING\020\005\022\r\n\tTY"
    "PE_STOP\020\006\022\023\n\017TYPE_RESTRICTED\020\007\022\017\n\013TYPE_B"
    "ORDER\020\010\022\021\n\rTYPE_SHOULDER\020\t\022\r\n\tTYPE_EXIT\020"
    "\n\022\016\n\nTYPE_ENTRY\020\013\022\017\n\013TYPE_ONRAMP\020\014\022\020\n\014TY"
    "PE_OFFRAMP\020\r\022\027\n\023TYPE_CONNECTINGRAMP\020\016\022\017\n"
    "\013TYPE_MEDIAN\020\017\022\r\n\tTYPE_CURB\020\020\022\r\n\tTYPE_RA"
    "IL\020\021\022\r\n\tTYPE_TRAM\020\022\"\250\001\n\rMoveDirection\022\032\n"
    "\026MOVE_DIRECTION_UNKNOWN\020\000\022\030\n\024MOVE_DIRECT"
    "ION_OTHER\020\001\022\037\n\033MOVE_DIRECTION_INCREASING"
    "_S\020\002\022\037\n\033MOVE_DIRECTION_DECREASING_S\020\003\022\037\n"
    "\033MOVE_DIRECTION_BOTH_ALLOWED\020\004B\002H\001"
};
static const ::_pbi::DescriptorTable* const descriptor_table_osi_5flogicallane_2eproto_deps[1] =
    {
        &::descriptor_table_osi_5fcommon_2eproto,
};
static ::absl::once_flag descriptor_table_osi_5flogicallane_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_osi_5flogicallane_2eproto = {
    false,
    false,
    2234,
    descriptor_table_protodef_osi_5flogicallane_2eproto,
    "osi_logicallane.proto",
    &descriptor_table_osi_5flogicallane_2eproto_once,
    descriptor_table_osi_5flogicallane_2eproto_deps,
    1,
    6,
    schemas,
    file_default_instances,
    TableStruct_osi_5flogicallane_2eproto::offsets,
    file_level_enum_descriptors_osi_5flogicallane_2eproto,
    file_level_service_descriptors_osi_5flogicallane_2eproto,
};
namespace osi3 {
const ::google::protobuf::EnumDescriptor* LogicalLaneBoundary_PassingRule_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_osi_5flogicallane_2eproto);
  return file_level_enum_descriptors_osi_5flogicallane_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t LogicalLaneBoundary_PassingRule_internal_data_[] = {
    393216u, 0u, };
bool LogicalLaneBoundary_PassingRule_IsValid(int value) {
  return 0 <= value && value <= 5;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr LogicalLaneBoundary_PassingRule LogicalLaneBoundary::PASSING_RULE_UNKNOWN;
constexpr LogicalLaneBoundary_PassingRule LogicalLaneBoundary::PASSING_RULE_OTHER;
constexpr LogicalLaneBoundary_PassingRule LogicalLaneBoundary::PASSING_RULE_NONE_ALLOWED;
constexpr LogicalLaneBoundary_PassingRule LogicalLaneBoundary::PASSING_RULE_INCREASING_T;
constexpr LogicalLaneBoundary_PassingRule LogicalLaneBoundary::PASSING_RULE_DECREASING_T;
constexpr LogicalLaneBoundary_PassingRule LogicalLaneBoundary::PASSING_RULE_BOTH_ALLOWED;
constexpr LogicalLaneBoundary_PassingRule LogicalLaneBoundary::PassingRule_MIN;
constexpr LogicalLaneBoundary_PassingRule LogicalLaneBoundary::PassingRule_MAX;
constexpr int LogicalLaneBoundary::PassingRule_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* LogicalLane_Type_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_osi_5flogicallane_2eproto);
  return file_level_enum_descriptors_osi_5flogicallane_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t LogicalLane_Type_internal_data_[] = {
    1245184u, 0u, };
bool LogicalLane_Type_IsValid(int value) {
  return 0 <= value && value <= 18;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr LogicalLane_Type LogicalLane::TYPE_UNKNOWN;
constexpr LogicalLane_Type LogicalLane::TYPE_OTHER;
constexpr LogicalLane_Type LogicalLane::TYPE_NORMAL;
constexpr LogicalLane_Type LogicalLane::TYPE_BIKING;
constexpr LogicalLane_Type LogicalLane::TYPE_SIDEWALK;
constexpr LogicalLane_Type LogicalLane::TYPE_PARKING;
constexpr LogicalLane_Type LogicalLane::TYPE_STOP;
constexpr LogicalLane_Type LogicalLane::TYPE_RESTRICTED;
constexpr LogicalLane_Type LogicalLane::TYPE_BORDER;
constexpr LogicalLane_Type LogicalLane::TYPE_SHOULDER;
constexpr LogicalLane_Type LogicalLane::TYPE_EXIT;
constexpr LogicalLane_Type LogicalLane::TYPE_ENTRY;
constexpr LogicalLane_Type LogicalLane::TYPE_ONRAMP;
constexpr LogicalLane_Type LogicalLane::TYPE_OFFRAMP;
constexpr LogicalLane_Type LogicalLane::TYPE_CONNECTINGRAMP;
constexpr LogicalLane_Type LogicalLane::TYPE_MEDIAN;
constexpr LogicalLane_Type LogicalLane::TYPE_CURB;
constexpr LogicalLane_Type LogicalLane::TYPE_RAIL;
constexpr LogicalLane_Type LogicalLane::TYPE_TRAM;
constexpr LogicalLane_Type LogicalLane::Type_MIN;
constexpr LogicalLane_Type LogicalLane::Type_MAX;
constexpr int LogicalLane::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* LogicalLane_MoveDirection_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_osi_5flogicallane_2eproto);
  return file_level_enum_descriptors_osi_5flogicallane_2eproto[2];
}
PROTOBUF_CONSTINIT const uint32_t LogicalLane_MoveDirection_internal_data_[] = {
    327680u, 0u, };
bool LogicalLane_MoveDirection_IsValid(int value) {
  return 0 <= value && value <= 4;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr LogicalLane_MoveDirection LogicalLane::MOVE_DIRECTION_UNKNOWN;
constexpr LogicalLane_MoveDirection LogicalLane::MOVE_DIRECTION_OTHER;
constexpr LogicalLane_MoveDirection LogicalLane::MOVE_DIRECTION_INCREASING_S;
constexpr LogicalLane_MoveDirection LogicalLane::MOVE_DIRECTION_DECREASING_S;
constexpr LogicalLane_MoveDirection LogicalLane::MOVE_DIRECTION_BOTH_ALLOWED;
constexpr LogicalLane_MoveDirection LogicalLane::MoveDirection_MIN;
constexpr LogicalLane_MoveDirection LogicalLane::MoveDirection_MAX;
constexpr int LogicalLane::MoveDirection_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class LogicalLaneBoundary_LogicalBoundaryPoint::_Internal {
 public:
  using HasBits =
      decltype(std::declval<LogicalLaneBoundary_LogicalBoundaryPoint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary_LogicalBoundaryPoint, _impl_._has_bits_);
};

void LogicalLaneBoundary_LogicalBoundaryPoint::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
LogicalLaneBoundary_LogicalBoundaryPoint::LogicalLaneBoundary_LogicalBoundaryPoint(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.LogicalLaneBoundary.LogicalBoundaryPoint)
}
inline PROTOBUF_NDEBUG_INLINE LogicalLaneBoundary_LogicalBoundaryPoint::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::LogicalLaneBoundary_LogicalBoundaryPoint& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

LogicalLaneBoundary_LogicalBoundaryPoint::LogicalLaneBoundary_LogicalBoundaryPoint(
    ::google::protobuf::Arena* arena,
    const LogicalLaneBoundary_LogicalBoundaryPoint& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LogicalLaneBoundary_LogicalBoundaryPoint* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.position_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Vector3d>(
                              arena, *from._impl_.position_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, s_position_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, s_position_),
           offsetof(Impl_, t_position_) -
               offsetof(Impl_, s_position_) +
               sizeof(Impl_::t_position_));

  // @@protoc_insertion_point(copy_constructor:osi3.LogicalLaneBoundary.LogicalBoundaryPoint)
}
inline PROTOBUF_NDEBUG_INLINE LogicalLaneBoundary_LogicalBoundaryPoint::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void LogicalLaneBoundary_LogicalBoundaryPoint::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, position_),
           0,
           offsetof(Impl_, t_position_) -
               offsetof(Impl_, position_) +
               sizeof(Impl_::t_position_));
}
LogicalLaneBoundary_LogicalBoundaryPoint::~LogicalLaneBoundary_LogicalBoundaryPoint() {
  // @@protoc_insertion_point(destructor:osi3.LogicalLaneBoundary.LogicalBoundaryPoint)
  SharedDtor(*this);
}
inline void LogicalLaneBoundary_LogicalBoundaryPoint::SharedDtor(MessageLite& self) {
  LogicalLaneBoundary_LogicalBoundaryPoint& this_ = static_cast<LogicalLaneBoundary_LogicalBoundaryPoint&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.position_;
  this_._impl_.~Impl_();
}

inline void* LogicalLaneBoundary_LogicalBoundaryPoint::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) LogicalLaneBoundary_LogicalBoundaryPoint(arena);
}
constexpr auto LogicalLaneBoundary_LogicalBoundaryPoint::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(LogicalLaneBoundary_LogicalBoundaryPoint),
                                            alignof(LogicalLaneBoundary_LogicalBoundaryPoint));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull LogicalLaneBoundary_LogicalBoundaryPoint::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_LogicalLaneBoundary_LogicalBoundaryPoint_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &LogicalLaneBoundary_LogicalBoundaryPoint::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<LogicalLaneBoundary_LogicalBoundaryPoint>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &LogicalLaneBoundary_LogicalBoundaryPoint::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<LogicalLaneBoundary_LogicalBoundaryPoint>(), &LogicalLaneBoundary_LogicalBoundaryPoint::ByteSizeLong,
            &LogicalLaneBoundary_LogicalBoundaryPoint::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary_LogicalBoundaryPoint, _impl_._cached_size_),
        false,
    },
    &LogicalLaneBoundary_LogicalBoundaryPoint::kDescriptorMethods,
    &descriptor_table_osi_5flogicallane_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* LogicalLaneBoundary_LogicalBoundaryPoint::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> LogicalLaneBoundary_LogicalBoundaryPoint::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary_LogicalBoundaryPoint, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::LogicalLaneBoundary_LogicalBoundaryPoint>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .osi3.Vector3d position = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary_LogicalBoundaryPoint, _impl_.position_)}},
    // optional double s_position = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 1, 0, PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary_LogicalBoundaryPoint, _impl_.s_position_)}},
    // optional double t_position = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 2, 0, PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary_LogicalBoundaryPoint, _impl_.t_position_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.Vector3d position = 1;
    {PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary_LogicalBoundaryPoint, _impl_.position_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional double s_position = 2;
    {PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary_LogicalBoundaryPoint, _impl_.s_position_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double t_position = 3;
    {PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary_LogicalBoundaryPoint, _impl_.t_position_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Vector3d>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void LogicalLaneBoundary_LogicalBoundaryPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LogicalLaneBoundary.LogicalBoundaryPoint)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.position_ != nullptr);
    _impl_.position_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.s_position_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.t_position_) -
        reinterpret_cast<char*>(&_impl_.s_position_)) + sizeof(_impl_.t_position_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* LogicalLaneBoundary_LogicalBoundaryPoint::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const LogicalLaneBoundary_LogicalBoundaryPoint& this_ = static_cast<const LogicalLaneBoundary_LogicalBoundaryPoint&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* LogicalLaneBoundary_LogicalBoundaryPoint::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const LogicalLaneBoundary_LogicalBoundaryPoint& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.LogicalLaneBoundary.LogicalBoundaryPoint)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.Vector3d position = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.position_, this_._impl_.position_->GetCachedSize(), target,
                stream);
          }

          // optional double s_position = 2;
          if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                2, this_._internal_s_position(), target);
          }

          // optional double t_position = 3;
          if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                3, this_._internal_t_position(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.LogicalLaneBoundary.LogicalBoundaryPoint)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t LogicalLaneBoundary_LogicalBoundaryPoint::ByteSizeLong(const MessageLite& base) {
          const LogicalLaneBoundary_LogicalBoundaryPoint& this_ = static_cast<const LogicalLaneBoundary_LogicalBoundaryPoint&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t LogicalLaneBoundary_LogicalBoundaryPoint::ByteSizeLong() const {
          const LogicalLaneBoundary_LogicalBoundaryPoint& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.LogicalLaneBoundary.LogicalBoundaryPoint)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000007u) {
            // optional .osi3.Vector3d position = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.position_);
            }
            // optional double s_position = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 9;
            }
            // optional double t_position = 3;
            if (cached_has_bits & 0x00000004u) {
              total_size += 9;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void LogicalLaneBoundary_LogicalBoundaryPoint::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LogicalLaneBoundary_LogicalBoundaryPoint*>(&to_msg);
  auto& from = static_cast<const LogicalLaneBoundary_LogicalBoundaryPoint&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.LogicalLaneBoundary.LogicalBoundaryPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.position_ != nullptr);
      if (_this->_impl_.position_ == nullptr) {
        _this->_impl_.position_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Vector3d>(arena, *from._impl_.position_);
      } else {
        _this->_impl_.position_->MergeFrom(*from._impl_.position_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.s_position_ = from._impl_.s_position_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.t_position_ = from._impl_.t_position_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LogicalLaneBoundary_LogicalBoundaryPoint::CopyFrom(const LogicalLaneBoundary_LogicalBoundaryPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LogicalLaneBoundary.LogicalBoundaryPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LogicalLaneBoundary_LogicalBoundaryPoint::InternalSwap(LogicalLaneBoundary_LogicalBoundaryPoint* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary_LogicalBoundaryPoint, _impl_.t_position_)
      + sizeof(LogicalLaneBoundary_LogicalBoundaryPoint::_impl_.t_position_)
      - PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary_LogicalBoundaryPoint, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::google::protobuf::Metadata LogicalLaneBoundary_LogicalBoundaryPoint::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LogicalLaneBoundary::_Internal {
 public:
  using HasBits =
      decltype(std::declval<LogicalLaneBoundary>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_._has_bits_);
};

void LogicalLaneBoundary::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void LogicalLaneBoundary::clear_reference_line_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.reference_line_id_ != nullptr) _impl_.reference_line_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void LogicalLaneBoundary::clear_physical_boundary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.physical_boundary_id_.Clear();
}
void LogicalLaneBoundary::clear_source_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_reference_.Clear();
}
LogicalLaneBoundary::LogicalLaneBoundary(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.LogicalLaneBoundary)
}
inline PROTOBUF_NDEBUG_INLINE LogicalLaneBoundary::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::LogicalLaneBoundary& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        boundary_line_{visibility, arena, from.boundary_line_},
        physical_boundary_id_{visibility, arena, from.physical_boundary_id_},
        source_reference_{visibility, arena, from.source_reference_} {}

LogicalLaneBoundary::LogicalLaneBoundary(
    ::google::protobuf::Arena* arena,
    const LogicalLaneBoundary& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LogicalLaneBoundary* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.id_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.id_)
                        : nullptr;
  _impl_.reference_line_id_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.reference_line_id_)
                        : nullptr;
  _impl_.passing_rule_ = from._impl_.passing_rule_;

  // @@protoc_insertion_point(copy_constructor:osi3.LogicalLaneBoundary)
}
inline PROTOBUF_NDEBUG_INLINE LogicalLaneBoundary::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        boundary_line_{visibility, arena},
        physical_boundary_id_{visibility, arena},
        source_reference_{visibility, arena} {}

inline void LogicalLaneBoundary::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, passing_rule_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::passing_rule_));
}
LogicalLaneBoundary::~LogicalLaneBoundary() {
  // @@protoc_insertion_point(destructor:osi3.LogicalLaneBoundary)
  SharedDtor(*this);
}
inline void LogicalLaneBoundary::SharedDtor(MessageLite& self) {
  LogicalLaneBoundary& this_ = static_cast<LogicalLaneBoundary&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.id_;
  delete this_._impl_.reference_line_id_;
  this_._impl_.~Impl_();
}

inline void* LogicalLaneBoundary::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) LogicalLaneBoundary(arena);
}
constexpr auto LogicalLaneBoundary::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_.boundary_line_) +
          decltype(LogicalLaneBoundary::_impl_.boundary_line_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_.physical_boundary_id_) +
          decltype(LogicalLaneBoundary::_impl_.physical_boundary_id_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_.source_reference_) +
          decltype(LogicalLaneBoundary::_impl_.source_reference_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(LogicalLaneBoundary), alignof(LogicalLaneBoundary), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&LogicalLaneBoundary::PlacementNew_,
                                 sizeof(LogicalLaneBoundary),
                                 alignof(LogicalLaneBoundary));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull LogicalLaneBoundary::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_LogicalLaneBoundary_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &LogicalLaneBoundary::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<LogicalLaneBoundary>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &LogicalLaneBoundary::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<LogicalLaneBoundary>(), &LogicalLaneBoundary::ByteSizeLong,
            &LogicalLaneBoundary::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_._cached_size_),
        false,
    },
    &LogicalLaneBoundary::kDescriptorMethods,
    &descriptor_table_osi_5flogicallane_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* LogicalLaneBoundary::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 6, 0, 2> LogicalLaneBoundary::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    6,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::LogicalLaneBoundary>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .osi3.Identifier id = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_.id_)}},
    // repeated .osi3.LogicalLaneBoundary.LogicalBoundaryPoint boundary_line = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 1, PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_.boundary_line_)}},
    // optional .osi3.Identifier reference_line_id = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 2, PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_.reference_line_id_)}},
    // repeated .osi3.Identifier physical_boundary_id = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 3, PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_.physical_boundary_id_)}},
    // optional .osi3.LogicalLaneBoundary.PassingRule passing_rule = 5;
    {::_pbi::TcParser::FastEr0S1,
     {40, 2, 5, PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_.passing_rule_)}},
    // repeated .osi3.ExternalReference source_reference = 6;
    {::_pbi::TcParser::FastMtR1,
     {50, 63, 4, PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_.source_reference_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.Identifier id = 1;
    {PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_.id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.LogicalLaneBoundary.LogicalBoundaryPoint boundary_line = 2;
    {PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_.boundary_line_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.Identifier reference_line_id = 3;
    {PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_.reference_line_id_), _Internal::kHasBitsOffset + 1, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.Identifier physical_boundary_id = 4;
    {PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_.physical_boundary_id_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.LogicalLaneBoundary.PassingRule passing_rule = 5;
    {PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_.passing_rule_), _Internal::kHasBitsOffset + 2, 5,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // repeated .osi3.ExternalReference source_reference = 6;
    {PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_.source_reference_), -1, 4,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::LogicalLaneBoundary_LogicalBoundaryPoint>()},
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::ExternalReference>()},
    {0, 6},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void LogicalLaneBoundary::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LogicalLaneBoundary)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.boundary_line_.Clear();
  _impl_.physical_boundary_id_.Clear();
  _impl_.source_reference_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.id_ != nullptr);
      _impl_.id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.reference_line_id_ != nullptr);
      _impl_.reference_line_id_->Clear();
    }
  }
  _impl_.passing_rule_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* LogicalLaneBoundary::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const LogicalLaneBoundary& this_ = static_cast<const LogicalLaneBoundary&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* LogicalLaneBoundary::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const LogicalLaneBoundary& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.LogicalLaneBoundary)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.Identifier id = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.id_, this_._impl_.id_->GetCachedSize(), target,
                stream);
          }

          // repeated .osi3.LogicalLaneBoundary.LogicalBoundaryPoint boundary_line = 2;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_boundary_line_size());
               i < n; i++) {
            const auto& repfield = this_._internal_boundary_line().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    2, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // optional .osi3.Identifier reference_line_id = 3;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.reference_line_id_, this_._impl_.reference_line_id_->GetCachedSize(), target,
                stream);
          }

          // repeated .osi3.Identifier physical_boundary_id = 4;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_physical_boundary_id_size());
               i < n; i++) {
            const auto& repfield = this_._internal_physical_boundary_id().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    4, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // optional .osi3.LogicalLaneBoundary.PassingRule passing_rule = 5;
          if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                5, this_._internal_passing_rule(), target);
          }

          // repeated .osi3.ExternalReference source_reference = 6;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_source_reference_size());
               i < n; i++) {
            const auto& repfield = this_._internal_source_reference().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    6, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.LogicalLaneBoundary)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t LogicalLaneBoundary::ByteSizeLong(const MessageLite& base) {
          const LogicalLaneBoundary& this_ = static_cast<const LogicalLaneBoundary&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t LogicalLaneBoundary::ByteSizeLong() const {
          const LogicalLaneBoundary& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.LogicalLaneBoundary)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .osi3.LogicalLaneBoundary.LogicalBoundaryPoint boundary_line = 2;
            {
              total_size += 1UL * this_._internal_boundary_line_size();
              for (const auto& msg : this_._internal_boundary_line()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.Identifier physical_boundary_id = 4;
            {
              total_size += 1UL * this_._internal_physical_boundary_id_size();
              for (const auto& msg : this_._internal_physical_boundary_id()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.ExternalReference source_reference = 6;
            {
              total_size += 1UL * this_._internal_source_reference_size();
              for (const auto& msg : this_._internal_source_reference()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000007u) {
            // optional .osi3.Identifier id = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.id_);
            }
            // optional .osi3.Identifier reference_line_id = 3;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.reference_line_id_);
            }
            // optional .osi3.LogicalLaneBoundary.PassingRule passing_rule = 5;
            if (cached_has_bits & 0x00000004u) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_passing_rule());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void LogicalLaneBoundary::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LogicalLaneBoundary*>(&to_msg);
  auto& from = static_cast<const LogicalLaneBoundary&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.LogicalLaneBoundary)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_boundary_line()->MergeFrom(
      from._internal_boundary_line());
  _this->_internal_mutable_physical_boundary_id()->MergeFrom(
      from._internal_physical_boundary_id());
  _this->_internal_mutable_source_reference()->MergeFrom(
      from._internal_source_reference());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.id_ != nullptr);
      if (_this->_impl_.id_ == nullptr) {
        _this->_impl_.id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.id_);
      } else {
        _this->_impl_.id_->MergeFrom(*from._impl_.id_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.reference_line_id_ != nullptr);
      if (_this->_impl_.reference_line_id_ == nullptr) {
        _this->_impl_.reference_line_id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.reference_line_id_);
      } else {
        _this->_impl_.reference_line_id_->MergeFrom(*from._impl_.reference_line_id_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.passing_rule_ = from._impl_.passing_rule_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LogicalLaneBoundary::CopyFrom(const LogicalLaneBoundary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LogicalLaneBoundary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LogicalLaneBoundary::InternalSwap(LogicalLaneBoundary* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.boundary_line_.InternalSwap(&other->_impl_.boundary_line_);
  _impl_.physical_boundary_id_.InternalSwap(&other->_impl_.physical_boundary_id_);
  _impl_.source_reference_.InternalSwap(&other->_impl_.source_reference_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_.passing_rule_)
      + sizeof(LogicalLaneBoundary::_impl_.passing_rule_)
      - PROTOBUF_FIELD_OFFSET(LogicalLaneBoundary, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata LogicalLaneBoundary::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LogicalLane_PhysicalLaneReference::_Internal {
 public:
  using HasBits =
      decltype(std::declval<LogicalLane_PhysicalLaneReference>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LogicalLane_PhysicalLaneReference, _impl_._has_bits_);
};

void LogicalLane_PhysicalLaneReference::clear_physical_lane_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.physical_lane_id_ != nullptr) _impl_.physical_lane_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
LogicalLane_PhysicalLaneReference::LogicalLane_PhysicalLaneReference(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.LogicalLane.PhysicalLaneReference)
}
inline PROTOBUF_NDEBUG_INLINE LogicalLane_PhysicalLaneReference::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::LogicalLane_PhysicalLaneReference& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

LogicalLane_PhysicalLaneReference::LogicalLane_PhysicalLaneReference(
    ::google::protobuf::Arena* arena,
    const LogicalLane_PhysicalLaneReference& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LogicalLane_PhysicalLaneReference* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.physical_lane_id_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.physical_lane_id_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, start_s_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, start_s_),
           offsetof(Impl_, end_s_) -
               offsetof(Impl_, start_s_) +
               sizeof(Impl_::end_s_));

  // @@protoc_insertion_point(copy_constructor:osi3.LogicalLane.PhysicalLaneReference)
}
inline PROTOBUF_NDEBUG_INLINE LogicalLane_PhysicalLaneReference::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void LogicalLane_PhysicalLaneReference::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, physical_lane_id_),
           0,
           offsetof(Impl_, end_s_) -
               offsetof(Impl_, physical_lane_id_) +
               sizeof(Impl_::end_s_));
}
LogicalLane_PhysicalLaneReference::~LogicalLane_PhysicalLaneReference() {
  // @@protoc_insertion_point(destructor:osi3.LogicalLane.PhysicalLaneReference)
  SharedDtor(*this);
}
inline void LogicalLane_PhysicalLaneReference::SharedDtor(MessageLite& self) {
  LogicalLane_PhysicalLaneReference& this_ = static_cast<LogicalLane_PhysicalLaneReference&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.physical_lane_id_;
  this_._impl_.~Impl_();
}

inline void* LogicalLane_PhysicalLaneReference::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) LogicalLane_PhysicalLaneReference(arena);
}
constexpr auto LogicalLane_PhysicalLaneReference::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(LogicalLane_PhysicalLaneReference),
                                            alignof(LogicalLane_PhysicalLaneReference));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull LogicalLane_PhysicalLaneReference::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_LogicalLane_PhysicalLaneReference_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &LogicalLane_PhysicalLaneReference::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<LogicalLane_PhysicalLaneReference>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &LogicalLane_PhysicalLaneReference::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<LogicalLane_PhysicalLaneReference>(), &LogicalLane_PhysicalLaneReference::ByteSizeLong,
            &LogicalLane_PhysicalLaneReference::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(LogicalLane_PhysicalLaneReference, _impl_._cached_size_),
        false,
    },
    &LogicalLane_PhysicalLaneReference::kDescriptorMethods,
    &descriptor_table_osi_5flogicallane_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* LogicalLane_PhysicalLaneReference::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> LogicalLane_PhysicalLaneReference::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LogicalLane_PhysicalLaneReference, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::LogicalLane_PhysicalLaneReference>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .osi3.Identifier physical_lane_id = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(LogicalLane_PhysicalLaneReference, _impl_.physical_lane_id_)}},
    // optional double start_s = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 1, 0, PROTOBUF_FIELD_OFFSET(LogicalLane_PhysicalLaneReference, _impl_.start_s_)}},
    // optional double end_s = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 2, 0, PROTOBUF_FIELD_OFFSET(LogicalLane_PhysicalLaneReference, _impl_.end_s_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.Identifier physical_lane_id = 1;
    {PROTOBUF_FIELD_OFFSET(LogicalLane_PhysicalLaneReference, _impl_.physical_lane_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional double start_s = 2;
    {PROTOBUF_FIELD_OFFSET(LogicalLane_PhysicalLaneReference, _impl_.start_s_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double end_s = 3;
    {PROTOBUF_FIELD_OFFSET(LogicalLane_PhysicalLaneReference, _impl_.end_s_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void LogicalLane_PhysicalLaneReference::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LogicalLane.PhysicalLaneReference)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.physical_lane_id_ != nullptr);
    _impl_.physical_lane_id_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.start_s_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.end_s_) -
        reinterpret_cast<char*>(&_impl_.start_s_)) + sizeof(_impl_.end_s_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* LogicalLane_PhysicalLaneReference::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const LogicalLane_PhysicalLaneReference& this_ = static_cast<const LogicalLane_PhysicalLaneReference&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* LogicalLane_PhysicalLaneReference::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const LogicalLane_PhysicalLaneReference& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.LogicalLane.PhysicalLaneReference)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.Identifier physical_lane_id = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.physical_lane_id_, this_._impl_.physical_lane_id_->GetCachedSize(), target,
                stream);
          }

          // optional double start_s = 2;
          if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                2, this_._internal_start_s(), target);
          }

          // optional double end_s = 3;
          if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                3, this_._internal_end_s(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.LogicalLane.PhysicalLaneReference)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t LogicalLane_PhysicalLaneReference::ByteSizeLong(const MessageLite& base) {
          const LogicalLane_PhysicalLaneReference& this_ = static_cast<const LogicalLane_PhysicalLaneReference&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t LogicalLane_PhysicalLaneReference::ByteSizeLong() const {
          const LogicalLane_PhysicalLaneReference& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.LogicalLane.PhysicalLaneReference)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000007u) {
            // optional .osi3.Identifier physical_lane_id = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.physical_lane_id_);
            }
            // optional double start_s = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 9;
            }
            // optional double end_s = 3;
            if (cached_has_bits & 0x00000004u) {
              total_size += 9;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void LogicalLane_PhysicalLaneReference::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LogicalLane_PhysicalLaneReference*>(&to_msg);
  auto& from = static_cast<const LogicalLane_PhysicalLaneReference&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.LogicalLane.PhysicalLaneReference)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.physical_lane_id_ != nullptr);
      if (_this->_impl_.physical_lane_id_ == nullptr) {
        _this->_impl_.physical_lane_id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.physical_lane_id_);
      } else {
        _this->_impl_.physical_lane_id_->MergeFrom(*from._impl_.physical_lane_id_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.start_s_ = from._impl_.start_s_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.end_s_ = from._impl_.end_s_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LogicalLane_PhysicalLaneReference::CopyFrom(const LogicalLane_PhysicalLaneReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LogicalLane.PhysicalLaneReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LogicalLane_PhysicalLaneReference::InternalSwap(LogicalLane_PhysicalLaneReference* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogicalLane_PhysicalLaneReference, _impl_.end_s_)
      + sizeof(LogicalLane_PhysicalLaneReference::_impl_.end_s_)
      - PROTOBUF_FIELD_OFFSET(LogicalLane_PhysicalLaneReference, _impl_.physical_lane_id_)>(
          reinterpret_cast<char*>(&_impl_.physical_lane_id_),
          reinterpret_cast<char*>(&other->_impl_.physical_lane_id_));
}

::google::protobuf::Metadata LogicalLane_PhysicalLaneReference::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LogicalLane_LaneConnection::_Internal {
 public:
  using HasBits =
      decltype(std::declval<LogicalLane_LaneConnection>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LogicalLane_LaneConnection, _impl_._has_bits_);
};

void LogicalLane_LaneConnection::clear_other_lane_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.other_lane_id_ != nullptr) _impl_.other_lane_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
LogicalLane_LaneConnection::LogicalLane_LaneConnection(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.LogicalLane.LaneConnection)
}
inline PROTOBUF_NDEBUG_INLINE LogicalLane_LaneConnection::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::LogicalLane_LaneConnection& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

LogicalLane_LaneConnection::LogicalLane_LaneConnection(
    ::google::protobuf::Arena* arena,
    const LogicalLane_LaneConnection& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LogicalLane_LaneConnection* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.other_lane_id_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.other_lane_id_)
                        : nullptr;
  _impl_.at_begin_of_other_lane_ = from._impl_.at_begin_of_other_lane_;

  // @@protoc_insertion_point(copy_constructor:osi3.LogicalLane.LaneConnection)
}
inline PROTOBUF_NDEBUG_INLINE LogicalLane_LaneConnection::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void LogicalLane_LaneConnection::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, other_lane_id_),
           0,
           offsetof(Impl_, at_begin_of_other_lane_) -
               offsetof(Impl_, other_lane_id_) +
               sizeof(Impl_::at_begin_of_other_lane_));
}
LogicalLane_LaneConnection::~LogicalLane_LaneConnection() {
  // @@protoc_insertion_point(destructor:osi3.LogicalLane.LaneConnection)
  SharedDtor(*this);
}
inline void LogicalLane_LaneConnection::SharedDtor(MessageLite& self) {
  LogicalLane_LaneConnection& this_ = static_cast<LogicalLane_LaneConnection&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.other_lane_id_;
  this_._impl_.~Impl_();
}

inline void* LogicalLane_LaneConnection::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) LogicalLane_LaneConnection(arena);
}
constexpr auto LogicalLane_LaneConnection::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(LogicalLane_LaneConnection),
                                            alignof(LogicalLane_LaneConnection));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull LogicalLane_LaneConnection::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_LogicalLane_LaneConnection_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &LogicalLane_LaneConnection::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<LogicalLane_LaneConnection>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &LogicalLane_LaneConnection::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<LogicalLane_LaneConnection>(), &LogicalLane_LaneConnection::ByteSizeLong,
            &LogicalLane_LaneConnection::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(LogicalLane_LaneConnection, _impl_._cached_size_),
        false,
    },
    &LogicalLane_LaneConnection::kDescriptorMethods,
    &descriptor_table_osi_5flogicallane_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* LogicalLane_LaneConnection::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2> LogicalLane_LaneConnection::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LogicalLane_LaneConnection, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::LogicalLane_LaneConnection>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool at_begin_of_other_lane = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(LogicalLane_LaneConnection, _impl_.at_begin_of_other_lane_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(LogicalLane_LaneConnection, _impl_.at_begin_of_other_lane_)}},
    // optional .osi3.Identifier other_lane_id = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(LogicalLane_LaneConnection, _impl_.other_lane_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.Identifier other_lane_id = 1;
    {PROTOBUF_FIELD_OFFSET(LogicalLane_LaneConnection, _impl_.other_lane_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bool at_begin_of_other_lane = 2;
    {PROTOBUF_FIELD_OFFSET(LogicalLane_LaneConnection, _impl_.at_begin_of_other_lane_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void LogicalLane_LaneConnection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LogicalLane.LaneConnection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.other_lane_id_ != nullptr);
    _impl_.other_lane_id_->Clear();
  }
  _impl_.at_begin_of_other_lane_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* LogicalLane_LaneConnection::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const LogicalLane_LaneConnection& this_ = static_cast<const LogicalLane_LaneConnection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* LogicalLane_LaneConnection::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const LogicalLane_LaneConnection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.LogicalLane.LaneConnection)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.Identifier other_lane_id = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.other_lane_id_, this_._impl_.other_lane_id_->GetCachedSize(), target,
                stream);
          }

          // optional bool at_begin_of_other_lane = 2;
          if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                2, this_._internal_at_begin_of_other_lane(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.LogicalLane.LaneConnection)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t LogicalLane_LaneConnection::ByteSizeLong(const MessageLite& base) {
          const LogicalLane_LaneConnection& this_ = static_cast<const LogicalLane_LaneConnection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t LogicalLane_LaneConnection::ByteSizeLong() const {
          const LogicalLane_LaneConnection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.LogicalLane.LaneConnection)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // optional .osi3.Identifier other_lane_id = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.other_lane_id_);
            }
            // optional bool at_begin_of_other_lane = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 2;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void LogicalLane_LaneConnection::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LogicalLane_LaneConnection*>(&to_msg);
  auto& from = static_cast<const LogicalLane_LaneConnection&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.LogicalLane.LaneConnection)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.other_lane_id_ != nullptr);
      if (_this->_impl_.other_lane_id_ == nullptr) {
        _this->_impl_.other_lane_id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.other_lane_id_);
      } else {
        _this->_impl_.other_lane_id_->MergeFrom(*from._impl_.other_lane_id_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.at_begin_of_other_lane_ = from._impl_.at_begin_of_other_lane_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LogicalLane_LaneConnection::CopyFrom(const LogicalLane_LaneConnection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LogicalLane.LaneConnection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LogicalLane_LaneConnection::InternalSwap(LogicalLane_LaneConnection* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogicalLane_LaneConnection, _impl_.at_begin_of_other_lane_)
      + sizeof(LogicalLane_LaneConnection::_impl_.at_begin_of_other_lane_)
      - PROTOBUF_FIELD_OFFSET(LogicalLane_LaneConnection, _impl_.other_lane_id_)>(
          reinterpret_cast<char*>(&_impl_.other_lane_id_),
          reinterpret_cast<char*>(&other->_impl_.other_lane_id_));
}

::google::protobuf::Metadata LogicalLane_LaneConnection::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LogicalLane_LaneRelation::_Internal {
 public:
  using HasBits =
      decltype(std::declval<LogicalLane_LaneRelation>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LogicalLane_LaneRelation, _impl_._has_bits_);
};

void LogicalLane_LaneRelation::clear_other_lane_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.other_lane_id_ != nullptr) _impl_.other_lane_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
LogicalLane_LaneRelation::LogicalLane_LaneRelation(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.LogicalLane.LaneRelation)
}
inline PROTOBUF_NDEBUG_INLINE LogicalLane_LaneRelation::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::LogicalLane_LaneRelation& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

LogicalLane_LaneRelation::LogicalLane_LaneRelation(
    ::google::protobuf::Arena* arena,
    const LogicalLane_LaneRelation& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LogicalLane_LaneRelation* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.other_lane_id_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.other_lane_id_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, start_s_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, start_s_),
           offsetof(Impl_, end_s_other_) -
               offsetof(Impl_, start_s_) +
               sizeof(Impl_::end_s_other_));

  // @@protoc_insertion_point(copy_constructor:osi3.LogicalLane.LaneRelation)
}
inline PROTOBUF_NDEBUG_INLINE LogicalLane_LaneRelation::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void LogicalLane_LaneRelation::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, other_lane_id_),
           0,
           offsetof(Impl_, end_s_other_) -
               offsetof(Impl_, other_lane_id_) +
               sizeof(Impl_::end_s_other_));
}
LogicalLane_LaneRelation::~LogicalLane_LaneRelation() {
  // @@protoc_insertion_point(destructor:osi3.LogicalLane.LaneRelation)
  SharedDtor(*this);
}
inline void LogicalLane_LaneRelation::SharedDtor(MessageLite& self) {
  LogicalLane_LaneRelation& this_ = static_cast<LogicalLane_LaneRelation&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.other_lane_id_;
  this_._impl_.~Impl_();
}

inline void* LogicalLane_LaneRelation::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) LogicalLane_LaneRelation(arena);
}
constexpr auto LogicalLane_LaneRelation::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(LogicalLane_LaneRelation),
                                            alignof(LogicalLane_LaneRelation));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull LogicalLane_LaneRelation::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_LogicalLane_LaneRelation_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &LogicalLane_LaneRelation::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<LogicalLane_LaneRelation>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &LogicalLane_LaneRelation::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<LogicalLane_LaneRelation>(), &LogicalLane_LaneRelation::ByteSizeLong,
            &LogicalLane_LaneRelation::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(LogicalLane_LaneRelation, _impl_._cached_size_),
        false,
    },
    &LogicalLane_LaneRelation::kDescriptorMethods,
    &descriptor_table_osi_5flogicallane_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* LogicalLane_LaneRelation::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 1, 0, 2> LogicalLane_LaneRelation::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LogicalLane_LaneRelation, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::LogicalLane_LaneRelation>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .osi3.Identifier other_lane_id = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(LogicalLane_LaneRelation, _impl_.other_lane_id_)}},
    // optional double start_s = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 1, 0, PROTOBUF_FIELD_OFFSET(LogicalLane_LaneRelation, _impl_.start_s_)}},
    // optional double end_s = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 2, 0, PROTOBUF_FIELD_OFFSET(LogicalLane_LaneRelation, _impl_.end_s_)}},
    // optional double start_s_other = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 3, 0, PROTOBUF_FIELD_OFFSET(LogicalLane_LaneRelation, _impl_.start_s_other_)}},
    // optional double end_s_other = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 4, 0, PROTOBUF_FIELD_OFFSET(LogicalLane_LaneRelation, _impl_.end_s_other_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.Identifier other_lane_id = 1;
    {PROTOBUF_FIELD_OFFSET(LogicalLane_LaneRelation, _impl_.other_lane_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional double start_s = 2;
    {PROTOBUF_FIELD_OFFSET(LogicalLane_LaneRelation, _impl_.start_s_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double end_s = 3;
    {PROTOBUF_FIELD_OFFSET(LogicalLane_LaneRelation, _impl_.end_s_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double start_s_other = 4;
    {PROTOBUF_FIELD_OFFSET(LogicalLane_LaneRelation, _impl_.start_s_other_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double end_s_other = 5;
    {PROTOBUF_FIELD_OFFSET(LogicalLane_LaneRelation, _impl_.end_s_other_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void LogicalLane_LaneRelation::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LogicalLane.LaneRelation)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.other_lane_id_ != nullptr);
    _impl_.other_lane_id_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.start_s_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.end_s_other_) -
        reinterpret_cast<char*>(&_impl_.start_s_)) + sizeof(_impl_.end_s_other_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* LogicalLane_LaneRelation::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const LogicalLane_LaneRelation& this_ = static_cast<const LogicalLane_LaneRelation&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* LogicalLane_LaneRelation::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const LogicalLane_LaneRelation& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.LogicalLane.LaneRelation)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.Identifier other_lane_id = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.other_lane_id_, this_._impl_.other_lane_id_->GetCachedSize(), target,
                stream);
          }

          // optional double start_s = 2;
          if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                2, this_._internal_start_s(), target);
          }

          // optional double end_s = 3;
          if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                3, this_._internal_end_s(), target);
          }

          // optional double start_s_other = 4;
          if (cached_has_bits & 0x00000008u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                4, this_._internal_start_s_other(), target);
          }

          // optional double end_s_other = 5;
          if (cached_has_bits & 0x00000010u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                5, this_._internal_end_s_other(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.LogicalLane.LaneRelation)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t LogicalLane_LaneRelation::ByteSizeLong(const MessageLite& base) {
          const LogicalLane_LaneRelation& this_ = static_cast<const LogicalLane_LaneRelation&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t LogicalLane_LaneRelation::ByteSizeLong() const {
          const LogicalLane_LaneRelation& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.LogicalLane.LaneRelation)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x0000001fu) {
            // optional .osi3.Identifier other_lane_id = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.other_lane_id_);
            }
            // optional double start_s = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 9;
            }
            // optional double end_s = 3;
            if (cached_has_bits & 0x00000004u) {
              total_size += 9;
            }
            // optional double start_s_other = 4;
            if (cached_has_bits & 0x00000008u) {
              total_size += 9;
            }
            // optional double end_s_other = 5;
            if (cached_has_bits & 0x00000010u) {
              total_size += 9;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void LogicalLane_LaneRelation::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LogicalLane_LaneRelation*>(&to_msg);
  auto& from = static_cast<const LogicalLane_LaneRelation&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.LogicalLane.LaneRelation)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.other_lane_id_ != nullptr);
      if (_this->_impl_.other_lane_id_ == nullptr) {
        _this->_impl_.other_lane_id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.other_lane_id_);
      } else {
        _this->_impl_.other_lane_id_->MergeFrom(*from._impl_.other_lane_id_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.start_s_ = from._impl_.start_s_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.end_s_ = from._impl_.end_s_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.start_s_other_ = from._impl_.start_s_other_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.end_s_other_ = from._impl_.end_s_other_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LogicalLane_LaneRelation::CopyFrom(const LogicalLane_LaneRelation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LogicalLane.LaneRelation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LogicalLane_LaneRelation::InternalSwap(LogicalLane_LaneRelation* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogicalLane_LaneRelation, _impl_.end_s_other_)
      + sizeof(LogicalLane_LaneRelation::_impl_.end_s_other_)
      - PROTOBUF_FIELD_OFFSET(LogicalLane_LaneRelation, _impl_.other_lane_id_)>(
          reinterpret_cast<char*>(&_impl_.other_lane_id_),
          reinterpret_cast<char*>(&other->_impl_.other_lane_id_));
}

::google::protobuf::Metadata LogicalLane_LaneRelation::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LogicalLane::_Internal {
 public:
  using HasBits =
      decltype(std::declval<LogicalLane>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_._has_bits_);
};

void LogicalLane::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void LogicalLane::clear_source_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_reference_.Clear();
}
void LogicalLane::clear_reference_line_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.reference_line_id_ != nullptr) _impl_.reference_line_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void LogicalLane::clear_right_boundary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.right_boundary_id_.Clear();
}
void LogicalLane::clear_left_boundary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.left_boundary_id_.Clear();
}
LogicalLane::LogicalLane(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.LogicalLane)
}
inline PROTOBUF_NDEBUG_INLINE LogicalLane::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::LogicalLane& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        source_reference_{visibility, arena, from.source_reference_},
        physical_lane_reference_{visibility, arena, from.physical_lane_reference_},
        right_adjacent_lane_{visibility, arena, from.right_adjacent_lane_},
        left_adjacent_lane_{visibility, arena, from.left_adjacent_lane_},
        overlapping_lane_{visibility, arena, from.overlapping_lane_},
        right_boundary_id_{visibility, arena, from.right_boundary_id_},
        left_boundary_id_{visibility, arena, from.left_boundary_id_},
        predecessor_lane_{visibility, arena, from.predecessor_lane_},
        successor_lane_{visibility, arena, from.successor_lane_} {}

LogicalLane::LogicalLane(
    ::google::protobuf::Arena* arena,
    const LogicalLane& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LogicalLane* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.id_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.id_)
                        : nullptr;
  _impl_.reference_line_id_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.reference_line_id_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, type_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, type_),
           offsetof(Impl_, end_s_) -
               offsetof(Impl_, type_) +
               sizeof(Impl_::end_s_));

  // @@protoc_insertion_point(copy_constructor:osi3.LogicalLane)
}
inline PROTOBUF_NDEBUG_INLINE LogicalLane::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        source_reference_{visibility, arena},
        physical_lane_reference_{visibility, arena},
        right_adjacent_lane_{visibility, arena},
        left_adjacent_lane_{visibility, arena},
        overlapping_lane_{visibility, arena},
        right_boundary_id_{visibility, arena},
        left_boundary_id_{visibility, arena},
        predecessor_lane_{visibility, arena},
        successor_lane_{visibility, arena} {}

inline void LogicalLane::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, end_s_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::end_s_));
}
LogicalLane::~LogicalLane() {
  // @@protoc_insertion_point(destructor:osi3.LogicalLane)
  SharedDtor(*this);
}
inline void LogicalLane::SharedDtor(MessageLite& self) {
  LogicalLane& this_ = static_cast<LogicalLane&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.id_;
  delete this_._impl_.reference_line_id_;
  this_._impl_.~Impl_();
}

inline void* LogicalLane::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) LogicalLane(arena);
}
constexpr auto LogicalLane::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.source_reference_) +
          decltype(LogicalLane::_impl_.source_reference_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.physical_lane_reference_) +
          decltype(LogicalLane::_impl_.physical_lane_reference_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.right_adjacent_lane_) +
          decltype(LogicalLane::_impl_.right_adjacent_lane_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.left_adjacent_lane_) +
          decltype(LogicalLane::_impl_.left_adjacent_lane_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.overlapping_lane_) +
          decltype(LogicalLane::_impl_.overlapping_lane_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.right_boundary_id_) +
          decltype(LogicalLane::_impl_.right_boundary_id_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.left_boundary_id_) +
          decltype(LogicalLane::_impl_.left_boundary_id_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.predecessor_lane_) +
          decltype(LogicalLane::_impl_.predecessor_lane_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.successor_lane_) +
          decltype(LogicalLane::_impl_.successor_lane_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(LogicalLane), alignof(LogicalLane), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&LogicalLane::PlacementNew_,
                                 sizeof(LogicalLane),
                                 alignof(LogicalLane));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull LogicalLane::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_LogicalLane_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &LogicalLane::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<LogicalLane>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &LogicalLane::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<LogicalLane>(), &LogicalLane::ByteSizeLong,
            &LogicalLane::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_._cached_size_),
        false,
    },
    &LogicalLane::kDescriptorMethods,
    &descriptor_table_osi_5flogicallane_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* LogicalLane::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 15, 13, 0, 2> LogicalLane::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_._has_bits_),
    0, // no _extensions_
    15, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294934528,  // skipmap
    offsetof(decltype(_table_), field_entries),
    15,  // num_field_entries
    13,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::LogicalLane>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .osi3.Identifier id = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.id_)}},
    // optional .osi3.LogicalLane.Type type = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 2, 18, PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.type_)}},
    // repeated .osi3.ExternalReference source_reference = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 1, PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.source_reference_)}},
    // repeated .osi3.LogicalLane.PhysicalLaneReference physical_lane_reference = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 2, PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.physical_lane_reference_)}},
    // optional .osi3.Identifier reference_line_id = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 1, 3, PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.reference_line_id_)}},
    // optional double start_s = 6;
    {::_pbi::TcParser::FastF64S1,
     {49, 4, 0, PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.start_s_)}},
    // optional double end_s = 7;
    {::_pbi::TcParser::FastF64S1,
     {57, 5, 0, PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.end_s_)}},
    // optional .osi3.LogicalLane.MoveDirection move_direction = 8;
    {::_pbi::TcParser::FastEr0S1,
     {64, 3, 4, PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.move_direction_)}},
    // repeated .osi3.LogicalLane.LaneRelation right_adjacent_lane = 9;
    {::_pbi::TcParser::FastMtR1,
     {74, 63, 4, PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.right_adjacent_lane_)}},
    // repeated .osi3.LogicalLane.LaneRelation left_adjacent_lane = 10;
    {::_pbi::TcParser::FastMtR1,
     {82, 63, 5, PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.left_adjacent_lane_)}},
    // repeated .osi3.LogicalLane.LaneRelation overlapping_lane = 11;
    {::_pbi::TcParser::FastMtR1,
     {90, 63, 6, PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.overlapping_lane_)}},
    // repeated .osi3.Identifier right_boundary_id = 12;
    {::_pbi::TcParser::FastMtR1,
     {98, 63, 7, PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.right_boundary_id_)}},
    // repeated .osi3.Identifier left_boundary_id = 13;
    {::_pbi::TcParser::FastMtR1,
     {106, 63, 8, PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.left_boundary_id_)}},
    // repeated .osi3.LogicalLane.LaneConnection predecessor_lane = 14;
    {::_pbi::TcParser::FastMtR1,
     {114, 63, 9, PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.predecessor_lane_)}},
    // repeated .osi3.LogicalLane.LaneConnection successor_lane = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 10, PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.successor_lane_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.Identifier id = 1;
    {PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.LogicalLane.Type type = 2;
    {PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.type_), _Internal::kHasBitsOffset + 2, 11,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // repeated .osi3.ExternalReference source_reference = 3;
    {PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.source_reference_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.LogicalLane.PhysicalLaneReference physical_lane_reference = 4;
    {PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.physical_lane_reference_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.Identifier reference_line_id = 5;
    {PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.reference_line_id_), _Internal::kHasBitsOffset + 1, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional double start_s = 6;
    {PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.start_s_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double end_s = 7;
    {PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.end_s_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .osi3.LogicalLane.MoveDirection move_direction = 8;
    {PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.move_direction_), _Internal::kHasBitsOffset + 3, 12,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // repeated .osi3.LogicalLane.LaneRelation right_adjacent_lane = 9;
    {PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.right_adjacent_lane_), -1, 4,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.LogicalLane.LaneRelation left_adjacent_lane = 10;
    {PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.left_adjacent_lane_), -1, 5,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.LogicalLane.LaneRelation overlapping_lane = 11;
    {PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.overlapping_lane_), -1, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.Identifier right_boundary_id = 12;
    {PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.right_boundary_id_), -1, 7,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.Identifier left_boundary_id = 13;
    {PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.left_boundary_id_), -1, 8,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.LogicalLane.LaneConnection predecessor_lane = 14;
    {PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.predecessor_lane_), -1, 9,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.LogicalLane.LaneConnection successor_lane = 15;
    {PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.successor_lane_), -1, 10,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::ExternalReference>()},
    {::_pbi::TcParser::GetTable<::osi3::LogicalLane_PhysicalLaneReference>()},
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::LogicalLane_LaneRelation>()},
    {::_pbi::TcParser::GetTable<::osi3::LogicalLane_LaneRelation>()},
    {::_pbi::TcParser::GetTable<::osi3::LogicalLane_LaneRelation>()},
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::LogicalLane_LaneConnection>()},
    {::_pbi::TcParser::GetTable<::osi3::LogicalLane_LaneConnection>()},
    {0, 19},
    {0, 5},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void LogicalLane::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LogicalLane)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.source_reference_.Clear();
  _impl_.physical_lane_reference_.Clear();
  _impl_.right_adjacent_lane_.Clear();
  _impl_.left_adjacent_lane_.Clear();
  _impl_.overlapping_lane_.Clear();
  _impl_.right_boundary_id_.Clear();
  _impl_.left_boundary_id_.Clear();
  _impl_.predecessor_lane_.Clear();
  _impl_.successor_lane_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.id_ != nullptr);
      _impl_.id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.reference_line_id_ != nullptr);
      _impl_.reference_line_id_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.type_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.end_s_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.end_s_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* LogicalLane::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const LogicalLane& this_ = static_cast<const LogicalLane&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* LogicalLane::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const LogicalLane& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.LogicalLane)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.Identifier id = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.id_, this_._impl_.id_->GetCachedSize(), target,
                stream);
          }

          // optional .osi3.LogicalLane.Type type = 2;
          if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                2, this_._internal_type(), target);
          }

          // repeated .osi3.ExternalReference source_reference = 3;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_source_reference_size());
               i < n; i++) {
            const auto& repfield = this_._internal_source_reference().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    3, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .osi3.LogicalLane.PhysicalLaneReference physical_lane_reference = 4;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_physical_lane_reference_size());
               i < n; i++) {
            const auto& repfield = this_._internal_physical_lane_reference().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    4, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // optional .osi3.Identifier reference_line_id = 5;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                5, *this_._impl_.reference_line_id_, this_._impl_.reference_line_id_->GetCachedSize(), target,
                stream);
          }

          // optional double start_s = 6;
          if (cached_has_bits & 0x00000010u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                6, this_._internal_start_s(), target);
          }

          // optional double end_s = 7;
          if (cached_has_bits & 0x00000020u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                7, this_._internal_end_s(), target);
          }

          // optional .osi3.LogicalLane.MoveDirection move_direction = 8;
          if (cached_has_bits & 0x00000008u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                8, this_._internal_move_direction(), target);
          }

          // repeated .osi3.LogicalLane.LaneRelation right_adjacent_lane = 9;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_right_adjacent_lane_size());
               i < n; i++) {
            const auto& repfield = this_._internal_right_adjacent_lane().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    9, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .osi3.LogicalLane.LaneRelation left_adjacent_lane = 10;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_left_adjacent_lane_size());
               i < n; i++) {
            const auto& repfield = this_._internal_left_adjacent_lane().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    10, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .osi3.LogicalLane.LaneRelation overlapping_lane = 11;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_overlapping_lane_size());
               i < n; i++) {
            const auto& repfield = this_._internal_overlapping_lane().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    11, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .osi3.Identifier right_boundary_id = 12;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_right_boundary_id_size());
               i < n; i++) {
            const auto& repfield = this_._internal_right_boundary_id().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    12, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .osi3.Identifier left_boundary_id = 13;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_left_boundary_id_size());
               i < n; i++) {
            const auto& repfield = this_._internal_left_boundary_id().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    13, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .osi3.LogicalLane.LaneConnection predecessor_lane = 14;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_predecessor_lane_size());
               i < n; i++) {
            const auto& repfield = this_._internal_predecessor_lane().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    14, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .osi3.LogicalLane.LaneConnection successor_lane = 15;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_successor_lane_size());
               i < n; i++) {
            const auto& repfield = this_._internal_successor_lane().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    15, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.LogicalLane)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t LogicalLane::ByteSizeLong(const MessageLite& base) {
          const LogicalLane& this_ = static_cast<const LogicalLane&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t LogicalLane::ByteSizeLong() const {
          const LogicalLane& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.LogicalLane)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .osi3.ExternalReference source_reference = 3;
            {
              total_size += 1UL * this_._internal_source_reference_size();
              for (const auto& msg : this_._internal_source_reference()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.LogicalLane.PhysicalLaneReference physical_lane_reference = 4;
            {
              total_size += 1UL * this_._internal_physical_lane_reference_size();
              for (const auto& msg : this_._internal_physical_lane_reference()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.LogicalLane.LaneRelation right_adjacent_lane = 9;
            {
              total_size += 1UL * this_._internal_right_adjacent_lane_size();
              for (const auto& msg : this_._internal_right_adjacent_lane()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.LogicalLane.LaneRelation left_adjacent_lane = 10;
            {
              total_size += 1UL * this_._internal_left_adjacent_lane_size();
              for (const auto& msg : this_._internal_left_adjacent_lane()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.LogicalLane.LaneRelation overlapping_lane = 11;
            {
              total_size += 1UL * this_._internal_overlapping_lane_size();
              for (const auto& msg : this_._internal_overlapping_lane()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.Identifier right_boundary_id = 12;
            {
              total_size += 1UL * this_._internal_right_boundary_id_size();
              for (const auto& msg : this_._internal_right_boundary_id()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.Identifier left_boundary_id = 13;
            {
              total_size += 1UL * this_._internal_left_boundary_id_size();
              for (const auto& msg : this_._internal_left_boundary_id()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.LogicalLane.LaneConnection predecessor_lane = 14;
            {
              total_size += 1UL * this_._internal_predecessor_lane_size();
              for (const auto& msg : this_._internal_predecessor_lane()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.LogicalLane.LaneConnection successor_lane = 15;
            {
              total_size += 1UL * this_._internal_successor_lane_size();
              for (const auto& msg : this_._internal_successor_lane()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x0000003fu) {
            // optional .osi3.Identifier id = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.id_);
            }
            // optional .osi3.Identifier reference_line_id = 5;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.reference_line_id_);
            }
            // optional .osi3.LogicalLane.Type type = 2;
            if (cached_has_bits & 0x00000004u) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
            }
            // optional .osi3.LogicalLane.MoveDirection move_direction = 8;
            if (cached_has_bits & 0x00000008u) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_move_direction());
            }
            // optional double start_s = 6;
            if (cached_has_bits & 0x00000010u) {
              total_size += 9;
            }
            // optional double end_s = 7;
            if (cached_has_bits & 0x00000020u) {
              total_size += 9;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void LogicalLane::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LogicalLane*>(&to_msg);
  auto& from = static_cast<const LogicalLane&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.LogicalLane)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_source_reference()->MergeFrom(
      from._internal_source_reference());
  _this->_internal_mutable_physical_lane_reference()->MergeFrom(
      from._internal_physical_lane_reference());
  _this->_internal_mutable_right_adjacent_lane()->MergeFrom(
      from._internal_right_adjacent_lane());
  _this->_internal_mutable_left_adjacent_lane()->MergeFrom(
      from._internal_left_adjacent_lane());
  _this->_internal_mutable_overlapping_lane()->MergeFrom(
      from._internal_overlapping_lane());
  _this->_internal_mutable_right_boundary_id()->MergeFrom(
      from._internal_right_boundary_id());
  _this->_internal_mutable_left_boundary_id()->MergeFrom(
      from._internal_left_boundary_id());
  _this->_internal_mutable_predecessor_lane()->MergeFrom(
      from._internal_predecessor_lane());
  _this->_internal_mutable_successor_lane()->MergeFrom(
      from._internal_successor_lane());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.id_ != nullptr);
      if (_this->_impl_.id_ == nullptr) {
        _this->_impl_.id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.id_);
      } else {
        _this->_impl_.id_->MergeFrom(*from._impl_.id_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.reference_line_id_ != nullptr);
      if (_this->_impl_.reference_line_id_ == nullptr) {
        _this->_impl_.reference_line_id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.reference_line_id_);
      } else {
        _this->_impl_.reference_line_id_->MergeFrom(*from._impl_.reference_line_id_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.move_direction_ = from._impl_.move_direction_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.start_s_ = from._impl_.start_s_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.end_s_ = from._impl_.end_s_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LogicalLane::CopyFrom(const LogicalLane& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LogicalLane)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LogicalLane::InternalSwap(LogicalLane* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.source_reference_.InternalSwap(&other->_impl_.source_reference_);
  _impl_.physical_lane_reference_.InternalSwap(&other->_impl_.physical_lane_reference_);
  _impl_.right_adjacent_lane_.InternalSwap(&other->_impl_.right_adjacent_lane_);
  _impl_.left_adjacent_lane_.InternalSwap(&other->_impl_.left_adjacent_lane_);
  _impl_.overlapping_lane_.InternalSwap(&other->_impl_.overlapping_lane_);
  _impl_.right_boundary_id_.InternalSwap(&other->_impl_.right_boundary_id_);
  _impl_.left_boundary_id_.InternalSwap(&other->_impl_.left_boundary_id_);
  _impl_.predecessor_lane_.InternalSwap(&other->_impl_.predecessor_lane_);
  _impl_.successor_lane_.InternalSwap(&other->_impl_.successor_lane_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.end_s_)
      + sizeof(LogicalLane::_impl_.end_s_)
      - PROTOBUF_FIELD_OFFSET(LogicalLane, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata LogicalLane::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace osi3
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ PROTOBUF_UNUSED =
        (::_pbi::AddDescriptors(&descriptor_table_osi_5flogicallane_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
