// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: osi_featuredata.proto
// Protobuf C++ Version: 5.29.5

#ifndef osi_5ffeaturedata_2eproto_2epb_2eh
#define osi_5ffeaturedata_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029005
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "osi_version.pb.h"
#include "osi_common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_osi_5ffeaturedata_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_osi_5ffeaturedata_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_osi_5ffeaturedata_2eproto;
namespace osi3 {
class CameraDetection;
struct CameraDetectionDefaultTypeInternal;
extern CameraDetectionDefaultTypeInternal _CameraDetection_default_instance_;
class CameraDetectionData;
struct CameraDetectionDataDefaultTypeInternal;
extern CameraDetectionDataDefaultTypeInternal _CameraDetectionData_default_instance_;
class CameraDetectionSpecificHeader;
struct CameraDetectionSpecificHeaderDefaultTypeInternal;
extern CameraDetectionSpecificHeaderDefaultTypeInternal _CameraDetectionSpecificHeader_default_instance_;
class CameraPoint;
struct CameraPointDefaultTypeInternal;
extern CameraPointDefaultTypeInternal _CameraPoint_default_instance_;
class FeatureData;
struct FeatureDataDefaultTypeInternal;
extern FeatureDataDefaultTypeInternal _FeatureData_default_instance_;
class LidarDetection;
struct LidarDetectionDefaultTypeInternal;
extern LidarDetectionDefaultTypeInternal _LidarDetection_default_instance_;
class LidarDetectionData;
struct LidarDetectionDataDefaultTypeInternal;
extern LidarDetectionDataDefaultTypeInternal _LidarDetectionData_default_instance_;
class RadarDetection;
struct RadarDetectionDefaultTypeInternal;
extern RadarDetectionDefaultTypeInternal _RadarDetection_default_instance_;
class RadarDetectionData;
struct RadarDetectionDataDefaultTypeInternal;
extern RadarDetectionDataDefaultTypeInternal _RadarDetectionData_default_instance_;
class SensorDetectionHeader;
struct SensorDetectionHeaderDefaultTypeInternal;
extern SensorDetectionHeaderDefaultTypeInternal _SensorDetectionHeader_default_instance_;
class UltrasonicDetection;
struct UltrasonicDetectionDefaultTypeInternal;
extern UltrasonicDetectionDefaultTypeInternal _UltrasonicDetection_default_instance_;
class UltrasonicDetectionData;
struct UltrasonicDetectionDataDefaultTypeInternal;
extern UltrasonicDetectionDataDefaultTypeInternal _UltrasonicDetectionData_default_instance_;
class UltrasonicDetectionSpecificHeader;
struct UltrasonicDetectionSpecificHeaderDefaultTypeInternal;
extern UltrasonicDetectionSpecificHeaderDefaultTypeInternal _UltrasonicDetectionSpecificHeader_default_instance_;
class UltrasonicIndirectDetection;
struct UltrasonicIndirectDetectionDefaultTypeInternal;
extern UltrasonicIndirectDetectionDefaultTypeInternal _UltrasonicIndirectDetection_default_instance_;
}  // namespace osi3
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace osi3 {
enum SensorDetectionHeader_DataQualifier : int {
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_UNKNOWN = 0,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_OTHER = 1,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_AVAILABLE = 2,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_AVAILABLE_REDUCED = 3,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_NOT_AVAILABLE = 4,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_BLINDNESS = 5,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_TEMPORARY_AVAILABLE = 6,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_INVALID = 7,
};

bool SensorDetectionHeader_DataQualifier_IsValid(int value);
extern const uint32_t SensorDetectionHeader_DataQualifier_internal_data_[];
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader_DataQualifier_DataQualifier_MIN = static_cast<SensorDetectionHeader_DataQualifier>(0);
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader_DataQualifier_DataQualifier_MAX = static_cast<SensorDetectionHeader_DataQualifier>(7);
constexpr int SensorDetectionHeader_DataQualifier_DataQualifier_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
SensorDetectionHeader_DataQualifier_descriptor();
template <typename T>
const std::string& SensorDetectionHeader_DataQualifier_Name(T value) {
  static_assert(std::is_same<T, SensorDetectionHeader_DataQualifier>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DataQualifier_Name().");
  return SensorDetectionHeader_DataQualifier_Name(static_cast<SensorDetectionHeader_DataQualifier>(value));
}
template <>
inline const std::string& SensorDetectionHeader_DataQualifier_Name(SensorDetectionHeader_DataQualifier value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SensorDetectionHeader_DataQualifier_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool SensorDetectionHeader_DataQualifier_Parse(absl::string_view name, SensorDetectionHeader_DataQualifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorDetectionHeader_DataQualifier>(
      SensorDetectionHeader_DataQualifier_descriptor(), name, value);
}
enum SensorDetectionHeader_ExtendedQualifier : int {
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_UNKNOWN = 0,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_OTHER = 1,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_NORMAL_OPERATION_MODE = 2,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_POWER_UP_OR_DOWN = 3,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_NOT_CALIBRATED = 4,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_BLOCKED = 5,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_MISALIGNED = 6,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_CONDITION = 7,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_REDUCED_FIELD_OF_VIEW = 8,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_INPUT_NOT_AVAILABLE = 9,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_INTERNAL_REASON = 10,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_EXTERNAL_DISTURBANCE = 11,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_BEGINNING_BLOCKAGE = 12,
};

bool SensorDetectionHeader_ExtendedQualifier_IsValid(int value);
extern const uint32_t SensorDetectionHeader_ExtendedQualifier_internal_data_[];
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_MIN = static_cast<SensorDetectionHeader_ExtendedQualifier>(0);
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_MAX = static_cast<SensorDetectionHeader_ExtendedQualifier>(12);
constexpr int SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor*
SensorDetectionHeader_ExtendedQualifier_descriptor();
template <typename T>
const std::string& SensorDetectionHeader_ExtendedQualifier_Name(T value) {
  static_assert(std::is_same<T, SensorDetectionHeader_ExtendedQualifier>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ExtendedQualifier_Name().");
  return SensorDetectionHeader_ExtendedQualifier_Name(static_cast<SensorDetectionHeader_ExtendedQualifier>(value));
}
template <>
inline const std::string& SensorDetectionHeader_ExtendedQualifier_Name(SensorDetectionHeader_ExtendedQualifier value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SensorDetectionHeader_ExtendedQualifier_descriptor,
                                                 0, 12>(
      static_cast<int>(value));
}
inline bool SensorDetectionHeader_ExtendedQualifier_Parse(absl::string_view name, SensorDetectionHeader_ExtendedQualifier* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorDetectionHeader_ExtendedQualifier>(
      SensorDetectionHeader_ExtendedQualifier_descriptor(), name, value);
}
enum CameraDetection_Color : int {
  CameraDetection_Color_COLOR_UNKNOWN = 0,
  CameraDetection_Color_COLOR_OTHER = 1,
  CameraDetection_Color_COLOR_BLACK = 2,
  CameraDetection_Color_COLOR_GREY = 3,
  CameraDetection_Color_COLOR_WHITE = 4,
  CameraDetection_Color_COLOR_YELLOW = 5,
  CameraDetection_Color_COLOR_ORANGE = 6,
  CameraDetection_Color_COLOR_RED = 7,
  CameraDetection_Color_COLOR_VIOLET = 8,
  CameraDetection_Color_COLOR_BLUE = 9,
  CameraDetection_Color_COLOR_GREEN = 10,
  CameraDetection_Color_COLOR_REFLECTIVE = 11,
};

bool CameraDetection_Color_IsValid(int value);
extern const uint32_t CameraDetection_Color_internal_data_[];
constexpr CameraDetection_Color CameraDetection_Color_Color_MIN = static_cast<CameraDetection_Color>(0);
constexpr CameraDetection_Color CameraDetection_Color_Color_MAX = static_cast<CameraDetection_Color>(11);
constexpr int CameraDetection_Color_Color_ARRAYSIZE = 11 + 1;
const ::google::protobuf::EnumDescriptor*
CameraDetection_Color_descriptor();
template <typename T>
const std::string& CameraDetection_Color_Name(T value) {
  static_assert(std::is_same<T, CameraDetection_Color>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Color_Name().");
  return CameraDetection_Color_Name(static_cast<CameraDetection_Color>(value));
}
template <>
inline const std::string& CameraDetection_Color_Name(CameraDetection_Color value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CameraDetection_Color_descriptor,
                                                 0, 11>(
      static_cast<int>(value));
}
inline bool CameraDetection_Color_Parse(absl::string_view name, CameraDetection_Color* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CameraDetection_Color>(
      CameraDetection_Color_descriptor(), name, value);
}
enum CameraDetection_ImageShapeType : int {
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_UNKNOWN = 0,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_OTHER = 1,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POINT = 2,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_BOX = 3,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_ELLIPSE = 4,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POLYGON = 5,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POLYLINE = 6,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POINT_CLOUD = 7,
};

bool CameraDetection_ImageShapeType_IsValid(int value);
extern const uint32_t CameraDetection_ImageShapeType_internal_data_[];
constexpr CameraDetection_ImageShapeType CameraDetection_ImageShapeType_ImageShapeType_MIN = static_cast<CameraDetection_ImageShapeType>(0);
constexpr CameraDetection_ImageShapeType CameraDetection_ImageShapeType_ImageShapeType_MAX = static_cast<CameraDetection_ImageShapeType>(7);
constexpr int CameraDetection_ImageShapeType_ImageShapeType_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
CameraDetection_ImageShapeType_descriptor();
template <typename T>
const std::string& CameraDetection_ImageShapeType_Name(T value) {
  static_assert(std::is_same<T, CameraDetection_ImageShapeType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ImageShapeType_Name().");
  return CameraDetection_ImageShapeType_Name(static_cast<CameraDetection_ImageShapeType>(value));
}
template <>
inline const std::string& CameraDetection_ImageShapeType_Name(CameraDetection_ImageShapeType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CameraDetection_ImageShapeType_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool CameraDetection_ImageShapeType_Parse(absl::string_view name, CameraDetection_ImageShapeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CameraDetection_ImageShapeType>(
      CameraDetection_ImageShapeType_descriptor(), name, value);
}
enum DetectionClassification : int {
  DETECTION_CLASSIFICATION_UNKNOWN = 0,
  DETECTION_CLASSIFICATION_OTHER = 1,
  DETECTION_CLASSIFICATION_INVALID = 2,
  DETECTION_CLASSIFICATION_CLUTTER = 3,
  DETECTION_CLASSIFICATION_OVERDRIVABLE = 4,
  DETECTION_CLASSIFICATION_UNDERDRIVABLE = 5,
};

bool DetectionClassification_IsValid(int value);
extern const uint32_t DetectionClassification_internal_data_[];
constexpr DetectionClassification DetectionClassification_MIN = static_cast<DetectionClassification>(0);
constexpr DetectionClassification DetectionClassification_MAX = static_cast<DetectionClassification>(5);
constexpr int DetectionClassification_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
DetectionClassification_descriptor();
template <typename T>
const std::string& DetectionClassification_Name(T value) {
  static_assert(std::is_same<T, DetectionClassification>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DetectionClassification_Name().");
  return DetectionClassification_Name(static_cast<DetectionClassification>(value));
}
template <>
inline const std::string& DetectionClassification_Name(DetectionClassification value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DetectionClassification_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool DetectionClassification_Parse(absl::string_view name, DetectionClassification* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DetectionClassification>(
      DetectionClassification_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UltrasonicDetectionSpecificHeader final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.UltrasonicDetectionSpecificHeader) */ {
 public:
  inline UltrasonicDetectionSpecificHeader() : UltrasonicDetectionSpecificHeader(nullptr) {}
  ~UltrasonicDetectionSpecificHeader() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UltrasonicDetectionSpecificHeader* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UltrasonicDetectionSpecificHeader));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UltrasonicDetectionSpecificHeader(
      ::google::protobuf::internal::ConstantInitialized);

  inline UltrasonicDetectionSpecificHeader(const UltrasonicDetectionSpecificHeader& from) : UltrasonicDetectionSpecificHeader(nullptr, from) {}
  inline UltrasonicDetectionSpecificHeader(UltrasonicDetectionSpecificHeader&& from) noexcept
      : UltrasonicDetectionSpecificHeader(nullptr, std::move(from)) {}
  inline UltrasonicDetectionSpecificHeader& operator=(const UltrasonicDetectionSpecificHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline UltrasonicDetectionSpecificHeader& operator=(UltrasonicDetectionSpecificHeader&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UltrasonicDetectionSpecificHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const UltrasonicDetectionSpecificHeader* internal_default_instance() {
    return reinterpret_cast<const UltrasonicDetectionSpecificHeader*>(
        &_UltrasonicDetectionSpecificHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(UltrasonicDetectionSpecificHeader& a, UltrasonicDetectionSpecificHeader& b) { a.Swap(&b); }
  inline void Swap(UltrasonicDetectionSpecificHeader* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UltrasonicDetectionSpecificHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UltrasonicDetectionSpecificHeader* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UltrasonicDetectionSpecificHeader>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UltrasonicDetectionSpecificHeader& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UltrasonicDetectionSpecificHeader& from) { UltrasonicDetectionSpecificHeader::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UltrasonicDetectionSpecificHeader* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.UltrasonicDetectionSpecificHeader"; }

 protected:
  explicit UltrasonicDetectionSpecificHeader(::google::protobuf::Arena* arena);
  UltrasonicDetectionSpecificHeader(::google::protobuf::Arena* arena, const UltrasonicDetectionSpecificHeader& from);
  UltrasonicDetectionSpecificHeader(::google::protobuf::Arena* arena, UltrasonicDetectionSpecificHeader&& from) noexcept
      : UltrasonicDetectionSpecificHeader(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMaxRangeFieldNumber = 1,
    kNumberOfValidIndirectDetectionsFieldNumber = 2,
  };
  // optional double max_range = 1;
  bool has_max_range() const;
  void clear_max_range() ;
  double max_range() const;
  void set_max_range(double value);

  private:
  double _internal_max_range() const;
  void _internal_set_max_range(double value);

  public:
  // optional uint32 number_of_valid_indirect_detections = 2;
  bool has_number_of_valid_indirect_detections() const;
  void clear_number_of_valid_indirect_detections() ;
  ::uint32_t number_of_valid_indirect_detections() const;
  void set_number_of_valid_indirect_detections(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_valid_indirect_detections() const;
  void _internal_set_number_of_valid_indirect_detections(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.UltrasonicDetectionSpecificHeader)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UltrasonicDetectionSpecificHeader& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double max_range_;
    ::uint32_t number_of_valid_indirect_detections_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class CameraDetectionSpecificHeader final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.CameraDetectionSpecificHeader) */ {
 public:
  inline CameraDetectionSpecificHeader() : CameraDetectionSpecificHeader(nullptr) {}
  ~CameraDetectionSpecificHeader() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CameraDetectionSpecificHeader* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CameraDetectionSpecificHeader));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CameraDetectionSpecificHeader(
      ::google::protobuf::internal::ConstantInitialized);

  inline CameraDetectionSpecificHeader(const CameraDetectionSpecificHeader& from) : CameraDetectionSpecificHeader(nullptr, from) {}
  inline CameraDetectionSpecificHeader(CameraDetectionSpecificHeader&& from) noexcept
      : CameraDetectionSpecificHeader(nullptr, std::move(from)) {}
  inline CameraDetectionSpecificHeader& operator=(const CameraDetectionSpecificHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraDetectionSpecificHeader& operator=(CameraDetectionSpecificHeader&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraDetectionSpecificHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraDetectionSpecificHeader* internal_default_instance() {
    return reinterpret_cast<const CameraDetectionSpecificHeader*>(
        &_CameraDetectionSpecificHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(CameraDetectionSpecificHeader& a, CameraDetectionSpecificHeader& b) { a.Swap(&b); }
  inline void Swap(CameraDetectionSpecificHeader* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraDetectionSpecificHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CameraDetectionSpecificHeader* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CameraDetectionSpecificHeader>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CameraDetectionSpecificHeader& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CameraDetectionSpecificHeader& from) { CameraDetectionSpecificHeader::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CameraDetectionSpecificHeader* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.CameraDetectionSpecificHeader"; }

 protected:
  explicit CameraDetectionSpecificHeader(::google::protobuf::Arena* arena);
  CameraDetectionSpecificHeader(::google::protobuf::Arena* arena, const CameraDetectionSpecificHeader& from);
  CameraDetectionSpecificHeader(::google::protobuf::Arena* arena, CameraDetectionSpecificHeader&& from) noexcept
      : CameraDetectionSpecificHeader(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNumberOfValidPointsFieldNumber = 1,
  };
  // optional uint32 number_of_valid_points = 1;
  bool has_number_of_valid_points() const;
  void clear_number_of_valid_points() ;
  ::uint32_t number_of_valid_points() const;
  void set_number_of_valid_points(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_valid_points() const;
  void _internal_set_number_of_valid_points(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.CameraDetectionSpecificHeader)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CameraDetectionSpecificHeader& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t number_of_valid_points_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class UltrasonicIndirectDetection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.UltrasonicIndirectDetection) */ {
 public:
  inline UltrasonicIndirectDetection() : UltrasonicIndirectDetection(nullptr) {}
  ~UltrasonicIndirectDetection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UltrasonicIndirectDetection* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UltrasonicIndirectDetection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UltrasonicIndirectDetection(
      ::google::protobuf::internal::ConstantInitialized);

  inline UltrasonicIndirectDetection(const UltrasonicIndirectDetection& from) : UltrasonicIndirectDetection(nullptr, from) {}
  inline UltrasonicIndirectDetection(UltrasonicIndirectDetection&& from) noexcept
      : UltrasonicIndirectDetection(nullptr, std::move(from)) {}
  inline UltrasonicIndirectDetection& operator=(const UltrasonicIndirectDetection& from) {
    CopyFrom(from);
    return *this;
  }
  inline UltrasonicIndirectDetection& operator=(UltrasonicIndirectDetection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UltrasonicIndirectDetection& default_instance() {
    return *internal_default_instance();
  }
  static inline const UltrasonicIndirectDetection* internal_default_instance() {
    return reinterpret_cast<const UltrasonicIndirectDetection*>(
        &_UltrasonicIndirectDetection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(UltrasonicIndirectDetection& a, UltrasonicIndirectDetection& b) { a.Swap(&b); }
  inline void Swap(UltrasonicIndirectDetection* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UltrasonicIndirectDetection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UltrasonicIndirectDetection* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UltrasonicIndirectDetection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UltrasonicIndirectDetection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UltrasonicIndirectDetection& from) { UltrasonicIndirectDetection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UltrasonicIndirectDetection* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.UltrasonicIndirectDetection"; }

 protected:
  explicit UltrasonicIndirectDetection(::google::protobuf::Arena* arena);
  UltrasonicIndirectDetection(::google::protobuf::Arena* arena, const UltrasonicIndirectDetection& from);
  UltrasonicIndirectDetection(::google::protobuf::Arena* arena, UltrasonicIndirectDetection&& from) noexcept
      : UltrasonicIndirectDetection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjectIdFieldNumber = 2,
    kReceiverIdFieldNumber = 5,
    kReceiverOriginFieldNumber = 6,
    kExistenceProbabilityFieldNumber = 1,
    kEllipsoidRadialFieldNumber = 3,
    kEllipsoidAxialFieldNumber = 4,
  };
  // optional .osi3.Identifier object_id = 2;
  bool has_object_id() const;
  void clear_object_id() ;
  const ::osi3::Identifier& object_id() const;
  PROTOBUF_NODISCARD ::osi3::Identifier* release_object_id();
  ::osi3::Identifier* mutable_object_id();
  void set_allocated_object_id(::osi3::Identifier* value);
  void unsafe_arena_set_allocated_object_id(::osi3::Identifier* value);
  ::osi3::Identifier* unsafe_arena_release_object_id();

  private:
  const ::osi3::Identifier& _internal_object_id() const;
  ::osi3::Identifier* _internal_mutable_object_id();

  public:
  // optional .osi3.Identifier receiver_id = 5;
  bool has_receiver_id() const;
  void clear_receiver_id() ;
  const ::osi3::Identifier& receiver_id() const;
  PROTOBUF_NODISCARD ::osi3::Identifier* release_receiver_id();
  ::osi3::Identifier* mutable_receiver_id();
  void set_allocated_receiver_id(::osi3::Identifier* value);
  void unsafe_arena_set_allocated_receiver_id(::osi3::Identifier* value);
  ::osi3::Identifier* unsafe_arena_release_receiver_id();

  private:
  const ::osi3::Identifier& _internal_receiver_id() const;
  ::osi3::Identifier* _internal_mutable_receiver_id();

  public:
  // optional .osi3.Vector3d receiver_origin = 6;
  bool has_receiver_origin() const;
  void clear_receiver_origin() ;
  const ::osi3::Vector3d& receiver_origin() const;
  PROTOBUF_NODISCARD ::osi3::Vector3d* release_receiver_origin();
  ::osi3::Vector3d* mutable_receiver_origin();
  void set_allocated_receiver_origin(::osi3::Vector3d* value);
  void unsafe_arena_set_allocated_receiver_origin(::osi3::Vector3d* value);
  ::osi3::Vector3d* unsafe_arena_release_receiver_origin();

  private:
  const ::osi3::Vector3d& _internal_receiver_origin() const;
  ::osi3::Vector3d* _internal_mutable_receiver_origin();

  public:
  // optional double existence_probability = 1;
  bool has_existence_probability() const;
  void clear_existence_probability() ;
  double existence_probability() const;
  void set_existence_probability(double value);

  private:
  double _internal_existence_probability() const;
  void _internal_set_existence_probability(double value);

  public:
  // optional double ellipsoid_radial = 3;
  bool has_ellipsoid_radial() const;
  void clear_ellipsoid_radial() ;
  double ellipsoid_radial() const;
  void set_ellipsoid_radial(double value);

  private:
  double _internal_ellipsoid_radial() const;
  void _internal_set_ellipsoid_radial(double value);

  public:
  // optional double ellipsoid_axial = 4;
  bool has_ellipsoid_axial() const;
  void clear_ellipsoid_axial() ;
  double ellipsoid_axial() const;
  void set_ellipsoid_axial(double value);

  private:
  double _internal_ellipsoid_axial() const;
  void _internal_set_ellipsoid_axial(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.UltrasonicIndirectDetection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UltrasonicIndirectDetection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::osi3::Identifier* object_id_;
    ::osi3::Identifier* receiver_id_;
    ::osi3::Vector3d* receiver_origin_;
    double existence_probability_;
    double ellipsoid_radial_;
    double ellipsoid_axial_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class UltrasonicDetection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.UltrasonicDetection) */ {
 public:
  inline UltrasonicDetection() : UltrasonicDetection(nullptr) {}
  ~UltrasonicDetection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UltrasonicDetection* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UltrasonicDetection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UltrasonicDetection(
      ::google::protobuf::internal::ConstantInitialized);

  inline UltrasonicDetection(const UltrasonicDetection& from) : UltrasonicDetection(nullptr, from) {}
  inline UltrasonicDetection(UltrasonicDetection&& from) noexcept
      : UltrasonicDetection(nullptr, std::move(from)) {}
  inline UltrasonicDetection& operator=(const UltrasonicDetection& from) {
    CopyFrom(from);
    return *this;
  }
  inline UltrasonicDetection& operator=(UltrasonicDetection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UltrasonicDetection& default_instance() {
    return *internal_default_instance();
  }
  static inline const UltrasonicDetection* internal_default_instance() {
    return reinterpret_cast<const UltrasonicDetection*>(
        &_UltrasonicDetection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(UltrasonicDetection& a, UltrasonicDetection& b) { a.Swap(&b); }
  inline void Swap(UltrasonicDetection* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UltrasonicDetection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UltrasonicDetection* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UltrasonicDetection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UltrasonicDetection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UltrasonicDetection& from) { UltrasonicDetection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UltrasonicDetection* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.UltrasonicDetection"; }

 protected:
  explicit UltrasonicDetection(::google::protobuf::Arena* arena);
  UltrasonicDetection(::google::protobuf::Arena* arena, const UltrasonicDetection& from);
  UltrasonicDetection(::google::protobuf::Arena* arena, UltrasonicDetection&& from) noexcept
      : UltrasonicDetection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjectIdFieldNumber = 2,
    kExistenceProbabilityFieldNumber = 1,
    kDistanceFieldNumber = 3,
  };
  // optional .osi3.Identifier object_id = 2;
  bool has_object_id() const;
  void clear_object_id() ;
  const ::osi3::Identifier& object_id() const;
  PROTOBUF_NODISCARD ::osi3::Identifier* release_object_id();
  ::osi3::Identifier* mutable_object_id();
  void set_allocated_object_id(::osi3::Identifier* value);
  void unsafe_arena_set_allocated_object_id(::osi3::Identifier* value);
  ::osi3::Identifier* unsafe_arena_release_object_id();

  private:
  const ::osi3::Identifier& _internal_object_id() const;
  ::osi3::Identifier* _internal_mutable_object_id();

  public:
  // optional double existence_probability = 1;
  bool has_existence_probability() const;
  void clear_existence_probability() ;
  double existence_probability() const;
  void set_existence_probability(double value);

  private:
  double _internal_existence_probability() const;
  void _internal_set_existence_probability(double value);

  public:
  // optional double distance = 3;
  bool has_distance() const;
  void clear_distance() ;
  double distance() const;
  void set_distance(double value);

  private:
  double _internal_distance() const;
  void _internal_set_distance(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.UltrasonicDetection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UltrasonicDetection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::osi3::Identifier* object_id_;
    double existence_probability_;
    double distance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class RadarDetection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.RadarDetection) */ {
 public:
  inline RadarDetection() : RadarDetection(nullptr) {}
  ~RadarDetection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RadarDetection* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RadarDetection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RadarDetection(
      ::google::protobuf::internal::ConstantInitialized);

  inline RadarDetection(const RadarDetection& from) : RadarDetection(nullptr, from) {}
  inline RadarDetection(RadarDetection&& from) noexcept
      : RadarDetection(nullptr, std::move(from)) {}
  inline RadarDetection& operator=(const RadarDetection& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadarDetection& operator=(RadarDetection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadarDetection& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadarDetection* internal_default_instance() {
    return reinterpret_cast<const RadarDetection*>(
        &_RadarDetection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(RadarDetection& a, RadarDetection& b) { a.Swap(&b); }
  inline void Swap(RadarDetection* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadarDetection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RadarDetection* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RadarDetection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RadarDetection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RadarDetection& from) { RadarDetection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RadarDetection* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.RadarDetection"; }

 protected:
  explicit RadarDetection(::google::protobuf::Arena* arena);
  RadarDetection(::google::protobuf::Arena* arena, const RadarDetection& from);
  RadarDetection(::google::protobuf::Arena* arena, RadarDetection&& from) noexcept
      : RadarDetection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjectIdFieldNumber = 2,
    kPositionFieldNumber = 3,
    kPositionRmseFieldNumber = 4,
    kAmbiguityIdFieldNumber = 10,
    kExistenceProbabilityFieldNumber = 1,
    kRadialVelocityFieldNumber = 5,
    kRadialVelocityRmseFieldNumber = 6,
    kRcsFieldNumber = 7,
    kSnrFieldNumber = 8,
    kPointTargetProbabilityFieldNumber = 9,
    kClassificationFieldNumber = 11,
  };
  // optional .osi3.Identifier object_id = 2;
  bool has_object_id() const;
  void clear_object_id() ;
  const ::osi3::Identifier& object_id() const;
  PROTOBUF_NODISCARD ::osi3::Identifier* release_object_id();
  ::osi3::Identifier* mutable_object_id();
  void set_allocated_object_id(::osi3::Identifier* value);
  void unsafe_arena_set_allocated_object_id(::osi3::Identifier* value);
  ::osi3::Identifier* unsafe_arena_release_object_id();

  private:
  const ::osi3::Identifier& _internal_object_id() const;
  ::osi3::Identifier* _internal_mutable_object_id();

  public:
  // optional .osi3.Spherical3d position = 3;
  bool has_position() const;
  void clear_position() ;
  const ::osi3::Spherical3d& position() const;
  PROTOBUF_NODISCARD ::osi3::Spherical3d* release_position();
  ::osi3::Spherical3d* mutable_position();
  void set_allocated_position(::osi3::Spherical3d* value);
  void unsafe_arena_set_allocated_position(::osi3::Spherical3d* value);
  ::osi3::Spherical3d* unsafe_arena_release_position();

  private:
  const ::osi3::Spherical3d& _internal_position() const;
  ::osi3::Spherical3d* _internal_mutable_position();

  public:
  // optional .osi3.Spherical3d position_rmse = 4;
  bool has_position_rmse() const;
  void clear_position_rmse() ;
  const ::osi3::Spherical3d& position_rmse() const;
  PROTOBUF_NODISCARD ::osi3::Spherical3d* release_position_rmse();
  ::osi3::Spherical3d* mutable_position_rmse();
  void set_allocated_position_rmse(::osi3::Spherical3d* value);
  void unsafe_arena_set_allocated_position_rmse(::osi3::Spherical3d* value);
  ::osi3::Spherical3d* unsafe_arena_release_position_rmse();

  private:
  const ::osi3::Spherical3d& _internal_position_rmse() const;
  ::osi3::Spherical3d* _internal_mutable_position_rmse();

  public:
  // optional .osi3.Identifier ambiguity_id = 10;
  bool has_ambiguity_id() const;
  void clear_ambiguity_id() ;
  const ::osi3::Identifier& ambiguity_id() const;
  PROTOBUF_NODISCARD ::osi3::Identifier* release_ambiguity_id();
  ::osi3::Identifier* mutable_ambiguity_id();
  void set_allocated_ambiguity_id(::osi3::Identifier* value);
  void unsafe_arena_set_allocated_ambiguity_id(::osi3::Identifier* value);
  ::osi3::Identifier* unsafe_arena_release_ambiguity_id();

  private:
  const ::osi3::Identifier& _internal_ambiguity_id() const;
  ::osi3::Identifier* _internal_mutable_ambiguity_id();

  public:
  // optional double existence_probability = 1;
  bool has_existence_probability() const;
  void clear_existence_probability() ;
  double existence_probability() const;
  void set_existence_probability(double value);

  private:
  double _internal_existence_probability() const;
  void _internal_set_existence_probability(double value);

  public:
  // optional double radial_velocity = 5;
  bool has_radial_velocity() const;
  void clear_radial_velocity() ;
  double radial_velocity() const;
  void set_radial_velocity(double value);

  private:
  double _internal_radial_velocity() const;
  void _internal_set_radial_velocity(double value);

  public:
  // optional double radial_velocity_rmse = 6;
  bool has_radial_velocity_rmse() const;
  void clear_radial_velocity_rmse() ;
  double radial_velocity_rmse() const;
  void set_radial_velocity_rmse(double value);

  private:
  double _internal_radial_velocity_rmse() const;
  void _internal_set_radial_velocity_rmse(double value);

  public:
  // optional double rcs = 7;
  bool has_rcs() const;
  void clear_rcs() ;
  double rcs() const;
  void set_rcs(double value);

  private:
  double _internal_rcs() const;
  void _internal_set_rcs(double value);

  public:
  // optional double snr = 8;
  bool has_snr() const;
  void clear_snr() ;
  double snr() const;
  void set_snr(double value);

  private:
  double _internal_snr() const;
  void _internal_set_snr(double value);

  public:
  // optional double point_target_probability = 9;
  bool has_point_target_probability() const;
  void clear_point_target_probability() ;
  double point_target_probability() const;
  void set_point_target_probability(double value);

  private:
  double _internal_point_target_probability() const;
  void _internal_set_point_target_probability(double value);

  public:
  // optional .osi3.DetectionClassification classification = 11;
  bool has_classification() const;
  void clear_classification() ;
  ::osi3::DetectionClassification classification() const;
  void set_classification(::osi3::DetectionClassification value);

  private:
  ::osi3::DetectionClassification _internal_classification() const;
  void _internal_set_classification(::osi3::DetectionClassification value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.RadarDetection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 5,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RadarDetection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::osi3::Identifier* object_id_;
    ::osi3::Spherical3d* position_;
    ::osi3::Spherical3d* position_rmse_;
    ::osi3::Identifier* ambiguity_id_;
    double existence_probability_;
    double radial_velocity_;
    double radial_velocity_rmse_;
    double rcs_;
    double snr_;
    double point_target_probability_;
    int classification_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class LidarDetection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.LidarDetection) */ {
 public:
  inline LidarDetection() : LidarDetection(nullptr) {}
  ~LidarDetection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LidarDetection* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LidarDetection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LidarDetection(
      ::google::protobuf::internal::ConstantInitialized);

  inline LidarDetection(const LidarDetection& from) : LidarDetection(nullptr, from) {}
  inline LidarDetection(LidarDetection&& from) noexcept
      : LidarDetection(nullptr, std::move(from)) {}
  inline LidarDetection& operator=(const LidarDetection& from) {
    CopyFrom(from);
    return *this;
  }
  inline LidarDetection& operator=(LidarDetection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LidarDetection& default_instance() {
    return *internal_default_instance();
  }
  static inline const LidarDetection* internal_default_instance() {
    return reinterpret_cast<const LidarDetection*>(
        &_LidarDetection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(LidarDetection& a, LidarDetection& b) { a.Swap(&b); }
  inline void Swap(LidarDetection* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LidarDetection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LidarDetection* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LidarDetection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LidarDetection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LidarDetection& from) { LidarDetection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LidarDetection* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.LidarDetection"; }

 protected:
  explicit LidarDetection(::google::protobuf::Arena* arena);
  LidarDetection(::google::protobuf::Arena* arena, const LidarDetection& from);
  LidarDetection(::google::protobuf::Arena* arena, LidarDetection&& from) noexcept
      : LidarDetection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjectIdFieldNumber = 2,
    kPositionFieldNumber = 3,
    kPositionRmseFieldNumber = 4,
    kExistenceProbabilityFieldNumber = 1,
    kHeightFieldNumber = 5,
    kHeightRmseFieldNumber = 6,
    kIntensityFieldNumber = 7,
    kFreeSpaceProbabilityFieldNumber = 8,
    kReflectivityFieldNumber = 10,
    kEchoPulseWidthFieldNumber = 11,
    kClassificationFieldNumber = 9,
  };
  // optional .osi3.Identifier object_id = 2;
  bool has_object_id() const;
  void clear_object_id() ;
  const ::osi3::Identifier& object_id() const;
  PROTOBUF_NODISCARD ::osi3::Identifier* release_object_id();
  ::osi3::Identifier* mutable_object_id();
  void set_allocated_object_id(::osi3::Identifier* value);
  void unsafe_arena_set_allocated_object_id(::osi3::Identifier* value);
  ::osi3::Identifier* unsafe_arena_release_object_id();

  private:
  const ::osi3::Identifier& _internal_object_id() const;
  ::osi3::Identifier* _internal_mutable_object_id();

  public:
  // optional .osi3.Spherical3d position = 3;
  bool has_position() const;
  void clear_position() ;
  const ::osi3::Spherical3d& position() const;
  PROTOBUF_NODISCARD ::osi3::Spherical3d* release_position();
  ::osi3::Spherical3d* mutable_position();
  void set_allocated_position(::osi3::Spherical3d* value);
  void unsafe_arena_set_allocated_position(::osi3::Spherical3d* value);
  ::osi3::Spherical3d* unsafe_arena_release_position();

  private:
  const ::osi3::Spherical3d& _internal_position() const;
  ::osi3::Spherical3d* _internal_mutable_position();

  public:
  // optional .osi3.Spherical3d position_rmse = 4;
  bool has_position_rmse() const;
  void clear_position_rmse() ;
  const ::osi3::Spherical3d& position_rmse() const;
  PROTOBUF_NODISCARD ::osi3::Spherical3d* release_position_rmse();
  ::osi3::Spherical3d* mutable_position_rmse();
  void set_allocated_position_rmse(::osi3::Spherical3d* value);
  void unsafe_arena_set_allocated_position_rmse(::osi3::Spherical3d* value);
  ::osi3::Spherical3d* unsafe_arena_release_position_rmse();

  private:
  const ::osi3::Spherical3d& _internal_position_rmse() const;
  ::osi3::Spherical3d* _internal_mutable_position_rmse();

  public:
  // optional double existence_probability = 1;
  bool has_existence_probability() const;
  void clear_existence_probability() ;
  double existence_probability() const;
  void set_existence_probability(double value);

  private:
  double _internal_existence_probability() const;
  void _internal_set_existence_probability(double value);

  public:
  // optional double height = 5;
  bool has_height() const;
  void clear_height() ;
  double height() const;
  void set_height(double value);

  private:
  double _internal_height() const;
  void _internal_set_height(double value);

  public:
  // optional double height_rmse = 6;
  bool has_height_rmse() const;
  void clear_height_rmse() ;
  double height_rmse() const;
  void set_height_rmse(double value);

  private:
  double _internal_height_rmse() const;
  void _internal_set_height_rmse(double value);

  public:
  // optional double intensity = 7;
  bool has_intensity() const;
  void clear_intensity() ;
  double intensity() const;
  void set_intensity(double value);

  private:
  double _internal_intensity() const;
  void _internal_set_intensity(double value);

  public:
  // optional double free_space_probability = 8;
  bool has_free_space_probability() const;
  void clear_free_space_probability() ;
  double free_space_probability() const;
  void set_free_space_probability(double value);

  private:
  double _internal_free_space_probability() const;
  void _internal_set_free_space_probability(double value);

  public:
  // optional double reflectivity = 10;
  bool has_reflectivity() const;
  void clear_reflectivity() ;
  double reflectivity() const;
  void set_reflectivity(double value);

  private:
  double _internal_reflectivity() const;
  void _internal_set_reflectivity(double value);

  public:
  // optional double echo_pulse_width = 11;
  bool has_echo_pulse_width() const;
  void clear_echo_pulse_width() ;
  double echo_pulse_width() const;
  void set_echo_pulse_width(double value);

  private:
  double _internal_echo_pulse_width() const;
  void _internal_set_echo_pulse_width(double value);

  public:
  // optional .osi3.DetectionClassification classification = 9;
  bool has_classification() const;
  void clear_classification() ;
  ::osi3::DetectionClassification classification() const;
  void set_classification(::osi3::DetectionClassification value);

  private:
  ::osi3::DetectionClassification _internal_classification() const;
  void _internal_set_classification(::osi3::DetectionClassification value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.LidarDetection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LidarDetection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::osi3::Identifier* object_id_;
    ::osi3::Spherical3d* position_;
    ::osi3::Spherical3d* position_rmse_;
    double existence_probability_;
    double height_;
    double height_rmse_;
    double intensity_;
    double free_space_probability_;
    double reflectivity_;
    double echo_pulse_width_;
    int classification_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class CameraPoint final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.CameraPoint) */ {
 public:
  inline CameraPoint() : CameraPoint(nullptr) {}
  ~CameraPoint() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CameraPoint* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CameraPoint));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CameraPoint(
      ::google::protobuf::internal::ConstantInitialized);

  inline CameraPoint(const CameraPoint& from) : CameraPoint(nullptr, from) {}
  inline CameraPoint(CameraPoint&& from) noexcept
      : CameraPoint(nullptr, std::move(from)) {}
  inline CameraPoint& operator=(const CameraPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraPoint& operator=(CameraPoint&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraPoint* internal_default_instance() {
    return reinterpret_cast<const CameraPoint*>(
        &_CameraPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(CameraPoint& a, CameraPoint& b) { a.Swap(&b); }
  inline void Swap(CameraPoint* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CameraPoint* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CameraPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CameraPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CameraPoint& from) { CameraPoint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CameraPoint* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.CameraPoint"; }

 protected:
  explicit CameraPoint(::google::protobuf::Arena* arena);
  CameraPoint(::google::protobuf::Arena* arena, const CameraPoint& from);
  CameraPoint(::google::protobuf::Arena* arena, CameraPoint&& from) noexcept
      : CameraPoint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPointFieldNumber = 2,
    kPointRmseFieldNumber = 3,
    kExistenceProbabilityFieldNumber = 1,
  };
  // optional .osi3.Spherical3d point = 2;
  bool has_point() const;
  void clear_point() ;
  const ::osi3::Spherical3d& point() const;
  PROTOBUF_NODISCARD ::osi3::Spherical3d* release_point();
  ::osi3::Spherical3d* mutable_point();
  void set_allocated_point(::osi3::Spherical3d* value);
  void unsafe_arena_set_allocated_point(::osi3::Spherical3d* value);
  ::osi3::Spherical3d* unsafe_arena_release_point();

  private:
  const ::osi3::Spherical3d& _internal_point() const;
  ::osi3::Spherical3d* _internal_mutable_point();

  public:
  // optional .osi3.Spherical3d point_rmse = 3;
  bool has_point_rmse() const;
  void clear_point_rmse() ;
  const ::osi3::Spherical3d& point_rmse() const;
  PROTOBUF_NODISCARD ::osi3::Spherical3d* release_point_rmse();
  ::osi3::Spherical3d* mutable_point_rmse();
  void set_allocated_point_rmse(::osi3::Spherical3d* value);
  void unsafe_arena_set_allocated_point_rmse(::osi3::Spherical3d* value);
  ::osi3::Spherical3d* unsafe_arena_release_point_rmse();

  private:
  const ::osi3::Spherical3d& _internal_point_rmse() const;
  ::osi3::Spherical3d* _internal_mutable_point_rmse();

  public:
  // optional double existence_probability = 1;
  bool has_existence_probability() const;
  void clear_existence_probability() ;
  double existence_probability() const;
  void set_existence_probability(double value);

  private:
  double _internal_existence_probability() const;
  void _internal_set_existence_probability(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.CameraPoint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CameraPoint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::osi3::Spherical3d* point_;
    ::osi3::Spherical3d* point_rmse_;
    double existence_probability_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class SensorDetectionHeader final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.SensorDetectionHeader) */ {
 public:
  inline SensorDetectionHeader() : SensorDetectionHeader(nullptr) {}
  ~SensorDetectionHeader() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SensorDetectionHeader* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SensorDetectionHeader));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorDetectionHeader(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorDetectionHeader(const SensorDetectionHeader& from) : SensorDetectionHeader(nullptr, from) {}
  inline SensorDetectionHeader(SensorDetectionHeader&& from) noexcept
      : SensorDetectionHeader(nullptr, std::move(from)) {}
  inline SensorDetectionHeader& operator=(const SensorDetectionHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorDetectionHeader& operator=(SensorDetectionHeader&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorDetectionHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorDetectionHeader* internal_default_instance() {
    return reinterpret_cast<const SensorDetectionHeader*>(
        &_SensorDetectionHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(SensorDetectionHeader& a, SensorDetectionHeader& b) { a.Swap(&b); }
  inline void Swap(SensorDetectionHeader* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorDetectionHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorDetectionHeader* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SensorDetectionHeader>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorDetectionHeader& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorDetectionHeader& from) { SensorDetectionHeader::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SensorDetectionHeader* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.SensorDetectionHeader"; }

 protected:
  explicit SensorDetectionHeader(::google::protobuf::Arena* arena);
  SensorDetectionHeader(::google::protobuf::Arena* arena, const SensorDetectionHeader& from);
  SensorDetectionHeader(::google::protobuf::Arena* arena, SensorDetectionHeader&& from) noexcept
      : SensorDetectionHeader(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using DataQualifier = SensorDetectionHeader_DataQualifier;
  static constexpr DataQualifier DATA_QUALIFIER_UNKNOWN = SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_UNKNOWN;
  static constexpr DataQualifier DATA_QUALIFIER_OTHER = SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_OTHER;
  static constexpr DataQualifier DATA_QUALIFIER_AVAILABLE = SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_AVAILABLE;
  static constexpr DataQualifier DATA_QUALIFIER_AVAILABLE_REDUCED = SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_AVAILABLE_REDUCED;
  static constexpr DataQualifier DATA_QUALIFIER_NOT_AVAILABLE = SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_NOT_AVAILABLE;
  static constexpr DataQualifier DATA_QUALIFIER_BLINDNESS = SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_BLINDNESS;
  static constexpr DataQualifier DATA_QUALIFIER_TEMPORARY_AVAILABLE = SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_TEMPORARY_AVAILABLE;
  static constexpr DataQualifier DATA_QUALIFIER_INVALID = SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_INVALID;
  static inline bool DataQualifier_IsValid(int value) {
    return SensorDetectionHeader_DataQualifier_IsValid(value);
  }
  static constexpr DataQualifier DataQualifier_MIN = SensorDetectionHeader_DataQualifier_DataQualifier_MIN;
  static constexpr DataQualifier DataQualifier_MAX = SensorDetectionHeader_DataQualifier_DataQualifier_MAX;
  static constexpr int DataQualifier_ARRAYSIZE = SensorDetectionHeader_DataQualifier_DataQualifier_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DataQualifier_descriptor() {
    return SensorDetectionHeader_DataQualifier_descriptor();
  }
  template <typename T>
  static inline const std::string& DataQualifier_Name(T value) {
    return SensorDetectionHeader_DataQualifier_Name(value);
  }
  static inline bool DataQualifier_Parse(absl::string_view name, DataQualifier* value) {
    return SensorDetectionHeader_DataQualifier_Parse(name, value);
  }
  using ExtendedQualifier = SensorDetectionHeader_ExtendedQualifier;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_UNKNOWN = SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_UNKNOWN;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_OTHER = SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_OTHER;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_NORMAL_OPERATION_MODE = SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_NORMAL_OPERATION_MODE;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_POWER_UP_OR_DOWN = SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_POWER_UP_OR_DOWN;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_SENSOR_NOT_CALIBRATED = SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_NOT_CALIBRATED;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_SENSOR_BLOCKED = SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_BLOCKED;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_SENSOR_MISALIGNED = SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_MISALIGNED;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_CONDITION = SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_CONDITION;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_REDUCED_FIELD_OF_VIEW = SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_REDUCED_FIELD_OF_VIEW;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_INPUT_NOT_AVAILABLE = SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_INPUT_NOT_AVAILABLE;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_INTERNAL_REASON = SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_INTERNAL_REASON;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_EXTERNAL_DISTURBANCE = SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_EXTERNAL_DISTURBANCE;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_BEGINNING_BLOCKAGE = SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_BEGINNING_BLOCKAGE;
  static inline bool ExtendedQualifier_IsValid(int value) {
    return SensorDetectionHeader_ExtendedQualifier_IsValid(value);
  }
  static constexpr ExtendedQualifier ExtendedQualifier_MIN = SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_MIN;
  static constexpr ExtendedQualifier ExtendedQualifier_MAX = SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_MAX;
  static constexpr int ExtendedQualifier_ARRAYSIZE = SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ExtendedQualifier_descriptor() {
    return SensorDetectionHeader_ExtendedQualifier_descriptor();
  }
  template <typename T>
  static inline const std::string& ExtendedQualifier_Name(T value) {
    return SensorDetectionHeader_ExtendedQualifier_Name(value);
  }
  static inline bool ExtendedQualifier_Parse(absl::string_view name, ExtendedQualifier* value) {
    return SensorDetectionHeader_ExtendedQualifier_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMeasurementTimeFieldNumber = 1,
    kMountingPositionFieldNumber = 3,
    kMountingPositionRmseFieldNumber = 4,
    kSensorIdFieldNumber = 7,
    kCycleCounterFieldNumber = 2,
    kDataQualifierFieldNumber = 5,
    kNumberOfValidDetectionsFieldNumber = 6,
    kExtendedQualifierFieldNumber = 8,
  };
  // optional .osi3.Timestamp measurement_time = 1;
  bool has_measurement_time() const;
  void clear_measurement_time() ;
  const ::osi3::Timestamp& measurement_time() const;
  PROTOBUF_NODISCARD ::osi3::Timestamp* release_measurement_time();
  ::osi3::Timestamp* mutable_measurement_time();
  void set_allocated_measurement_time(::osi3::Timestamp* value);
  void unsafe_arena_set_allocated_measurement_time(::osi3::Timestamp* value);
  ::osi3::Timestamp* unsafe_arena_release_measurement_time();

  private:
  const ::osi3::Timestamp& _internal_measurement_time() const;
  ::osi3::Timestamp* _internal_mutable_measurement_time();

  public:
  // optional .osi3.MountingPosition mounting_position = 3;
  bool has_mounting_position() const;
  void clear_mounting_position() ;
  const ::osi3::MountingPosition& mounting_position() const;
  PROTOBUF_NODISCARD ::osi3::MountingPosition* release_mounting_position();
  ::osi3::MountingPosition* mutable_mounting_position();
  void set_allocated_mounting_position(::osi3::MountingPosition* value);
  void unsafe_arena_set_allocated_mounting_position(::osi3::MountingPosition* value);
  ::osi3::MountingPosition* unsafe_arena_release_mounting_position();

  private:
  const ::osi3::MountingPosition& _internal_mounting_position() const;
  ::osi3::MountingPosition* _internal_mutable_mounting_position();

  public:
  // optional .osi3.MountingPosition mounting_position_rmse = 4;
  bool has_mounting_position_rmse() const;
  void clear_mounting_position_rmse() ;
  const ::osi3::MountingPosition& mounting_position_rmse() const;
  PROTOBUF_NODISCARD ::osi3::MountingPosition* release_mounting_position_rmse();
  ::osi3::MountingPosition* mutable_mounting_position_rmse();
  void set_allocated_mounting_position_rmse(::osi3::MountingPosition* value);
  void unsafe_arena_set_allocated_mounting_position_rmse(::osi3::MountingPosition* value);
  ::osi3::MountingPosition* unsafe_arena_release_mounting_position_rmse();

  private:
  const ::osi3::MountingPosition& _internal_mounting_position_rmse() const;
  ::osi3::MountingPosition* _internal_mutable_mounting_position_rmse();

  public:
  // optional .osi3.Identifier sensor_id = 7;
  bool has_sensor_id() const;
  void clear_sensor_id() ;
  const ::osi3::Identifier& sensor_id() const;
  PROTOBUF_NODISCARD ::osi3::Identifier* release_sensor_id();
  ::osi3::Identifier* mutable_sensor_id();
  void set_allocated_sensor_id(::osi3::Identifier* value);
  void unsafe_arena_set_allocated_sensor_id(::osi3::Identifier* value);
  ::osi3::Identifier* unsafe_arena_release_sensor_id();

  private:
  const ::osi3::Identifier& _internal_sensor_id() const;
  ::osi3::Identifier* _internal_mutable_sensor_id();

  public:
  // optional uint64 cycle_counter = 2;
  bool has_cycle_counter() const;
  void clear_cycle_counter() ;
  ::uint64_t cycle_counter() const;
  void set_cycle_counter(::uint64_t value);

  private:
  ::uint64_t _internal_cycle_counter() const;
  void _internal_set_cycle_counter(::uint64_t value);

  public:
  // optional .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
  bool has_data_qualifier() const;
  void clear_data_qualifier() ;
  ::osi3::SensorDetectionHeader_DataQualifier data_qualifier() const;
  void set_data_qualifier(::osi3::SensorDetectionHeader_DataQualifier value);

  private:
  ::osi3::SensorDetectionHeader_DataQualifier _internal_data_qualifier() const;
  void _internal_set_data_qualifier(::osi3::SensorDetectionHeader_DataQualifier value);

  public:
  // optional uint32 number_of_valid_detections = 6;
  bool has_number_of_valid_detections() const;
  void clear_number_of_valid_detections() ;
  ::uint32_t number_of_valid_detections() const;
  void set_number_of_valid_detections(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_valid_detections() const;
  void _internal_set_number_of_valid_detections(::uint32_t value);

  public:
  // optional .osi3.SensorDetectionHeader.ExtendedQualifier extended_qualifier = 8;
  bool has_extended_qualifier() const;
  void clear_extended_qualifier() ;
  ::osi3::SensorDetectionHeader_ExtendedQualifier extended_qualifier() const;
  void set_extended_qualifier(::osi3::SensorDetectionHeader_ExtendedQualifier value);

  private:
  ::osi3::SensorDetectionHeader_ExtendedQualifier _internal_extended_qualifier() const;
  void _internal_set_extended_qualifier(::osi3::SensorDetectionHeader_ExtendedQualifier value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.SensorDetectionHeader)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 6,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SensorDetectionHeader& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::osi3::Timestamp* measurement_time_;
    ::osi3::MountingPosition* mounting_position_;
    ::osi3::MountingPosition* mounting_position_rmse_;
    ::osi3::Identifier* sensor_id_;
    ::uint64_t cycle_counter_;
    int data_qualifier_;
    ::uint32_t number_of_valid_detections_;
    int extended_qualifier_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class CameraDetection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.CameraDetection) */ {
 public:
  inline CameraDetection() : CameraDetection(nullptr) {}
  ~CameraDetection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CameraDetection* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CameraDetection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CameraDetection(
      ::google::protobuf::internal::ConstantInitialized);

  inline CameraDetection(const CameraDetection& from) : CameraDetection(nullptr, from) {}
  inline CameraDetection(CameraDetection&& from) noexcept
      : CameraDetection(nullptr, std::move(from)) {}
  inline CameraDetection& operator=(const CameraDetection& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraDetection& operator=(CameraDetection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraDetection& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraDetection* internal_default_instance() {
    return reinterpret_cast<const CameraDetection*>(
        &_CameraDetection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(CameraDetection& a, CameraDetection& b) { a.Swap(&b); }
  inline void Swap(CameraDetection* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraDetection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CameraDetection* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CameraDetection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CameraDetection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CameraDetection& from) { CameraDetection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CameraDetection* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.CameraDetection"; }

 protected:
  explicit CameraDetection(::google::protobuf::Arena* arena);
  CameraDetection(::google::protobuf::Arena* arena, const CameraDetection& from);
  CameraDetection(::google::protobuf::Arena* arena, CameraDetection&& from) noexcept
      : CameraDetection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Color = CameraDetection_Color;
  static constexpr Color COLOR_UNKNOWN = CameraDetection_Color_COLOR_UNKNOWN;
  static constexpr Color COLOR_OTHER = CameraDetection_Color_COLOR_OTHER;
  static constexpr Color COLOR_BLACK = CameraDetection_Color_COLOR_BLACK;
  static constexpr Color COLOR_GREY = CameraDetection_Color_COLOR_GREY;
  static constexpr Color COLOR_WHITE = CameraDetection_Color_COLOR_WHITE;
  static constexpr Color COLOR_YELLOW = CameraDetection_Color_COLOR_YELLOW;
  static constexpr Color COLOR_ORANGE = CameraDetection_Color_COLOR_ORANGE;
  static constexpr Color COLOR_RED = CameraDetection_Color_COLOR_RED;
  static constexpr Color COLOR_VIOLET = CameraDetection_Color_COLOR_VIOLET;
  static constexpr Color COLOR_BLUE = CameraDetection_Color_COLOR_BLUE;
  static constexpr Color COLOR_GREEN = CameraDetection_Color_COLOR_GREEN;
  static constexpr Color COLOR_REFLECTIVE = CameraDetection_Color_COLOR_REFLECTIVE;
  static inline bool Color_IsValid(int value) {
    return CameraDetection_Color_IsValid(value);
  }
  static constexpr Color Color_MIN = CameraDetection_Color_Color_MIN;
  static constexpr Color Color_MAX = CameraDetection_Color_Color_MAX;
  static constexpr int Color_ARRAYSIZE = CameraDetection_Color_Color_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Color_descriptor() {
    return CameraDetection_Color_descriptor();
  }
  template <typename T>
  static inline const std::string& Color_Name(T value) {
    return CameraDetection_Color_Name(value);
  }
  static inline bool Color_Parse(absl::string_view name, Color* value) {
    return CameraDetection_Color_Parse(name, value);
  }
  using ImageShapeType = CameraDetection_ImageShapeType;
  static constexpr ImageShapeType IMAGE_SHAPE_TYPE_UNKNOWN = CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_UNKNOWN;
  static constexpr ImageShapeType IMAGE_SHAPE_TYPE_OTHER = CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_OTHER;
  static constexpr ImageShapeType IMAGE_SHAPE_TYPE_POINT = CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POINT;
  static constexpr ImageShapeType IMAGE_SHAPE_TYPE_BOX = CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_BOX;
  static constexpr ImageShapeType IMAGE_SHAPE_TYPE_ELLIPSE = CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_ELLIPSE;
  static constexpr ImageShapeType IMAGE_SHAPE_TYPE_POLYGON = CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POLYGON;
  static constexpr ImageShapeType IMAGE_SHAPE_TYPE_POLYLINE = CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POLYLINE;
  static constexpr ImageShapeType IMAGE_SHAPE_TYPE_POINT_CLOUD = CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POINT_CLOUD;
  static inline bool ImageShapeType_IsValid(int value) {
    return CameraDetection_ImageShapeType_IsValid(value);
  }
  static constexpr ImageShapeType ImageShapeType_MIN = CameraDetection_ImageShapeType_ImageShapeType_MIN;
  static constexpr ImageShapeType ImageShapeType_MAX = CameraDetection_ImageShapeType_ImageShapeType_MAX;
  static constexpr int ImageShapeType_ARRAYSIZE = CameraDetection_ImageShapeType_ImageShapeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ImageShapeType_descriptor() {
    return CameraDetection_ImageShapeType_descriptor();
  }
  template <typename T>
  static inline const std::string& ImageShapeType_Name(T value) {
    return CameraDetection_ImageShapeType_Name(value);
  }
  static inline bool ImageShapeType_Parse(absl::string_view name, ImageShapeType* value) {
    return CameraDetection_ImageShapeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kObjectIdFieldNumber = 2,
    kTimeDifferenceFieldNumber = 3,
    kAmbiguityIdFieldNumber = 30,
    kColorDescriptionFieldNumber = 33,
    kExistenceProbabilityFieldNumber = 1,
    kImageShapeTypeFieldNumber = 4,
    kShapeClassificationBackgroundFieldNumber = 5,
    kShapeClassificationForegroundFieldNumber = 6,
    kShapeClassificationFlatFieldNumber = 7,
    kShapeClassificationUprightFieldNumber = 8,
    kShapeClassificationGroundFieldNumber = 9,
    kShapeClassificationSkyFieldNumber = 10,
    kShapeClassificationVegetationFieldNumber = 11,
    kShapeClassificationRoadFieldNumber = 12,
    kShapeClassificationNonDrivingLaneFieldNumber = 13,
    kShapeClassificationNonRoadFieldNumber = 14,
    kShapeClassificationStationaryObjectFieldNumber = 15,
    kShapeClassificationMovingObjectFieldNumber = 16,
    kShapeClassificationLandmarkFieldNumber = 17,
    kShapeClassificationTrafficSignFieldNumber = 18,
    kShapeClassificationTrafficLightFieldNumber = 19,
    kShapeClassificationRoadMarkingFieldNumber = 20,
    kShapeClassificationVehicleFieldNumber = 21,
    kShapeClassificationPedestrianFieldNumber = 22,
    kShapeClassificationAnimalFieldNumber = 23,
    kShapeClassificationPedestrianFrontFieldNumber = 24,
    kShapeClassificationPedestrianSideFieldNumber = 25,
    kShapeClassificationPedestrianRearFieldNumber = 26,
    kColorFieldNumber = 28,
    kShapeClassificationProbabilityFieldNumber = 27,
    kColorProbabilityFieldNumber = 29,
    kFirstPointIndexFieldNumber = 31,
    kNumberOfPointsFieldNumber = 32,
  };
  // optional .osi3.Identifier object_id = 2;
  bool has_object_id() const;
  void clear_object_id() ;
  const ::osi3::Identifier& object_id() const;
  PROTOBUF_NODISCARD ::osi3::Identifier* release_object_id();
  ::osi3::Identifier* mutable_object_id();
  void set_allocated_object_id(::osi3::Identifier* value);
  void unsafe_arena_set_allocated_object_id(::osi3::Identifier* value);
  ::osi3::Identifier* unsafe_arena_release_object_id();

  private:
  const ::osi3::Identifier& _internal_object_id() const;
  ::osi3::Identifier* _internal_mutable_object_id();

  public:
  // optional .osi3.Timestamp time_difference = 3;
  bool has_time_difference() const;
  void clear_time_difference() ;
  const ::osi3::Timestamp& time_difference() const;
  PROTOBUF_NODISCARD ::osi3::Timestamp* release_time_difference();
  ::osi3::Timestamp* mutable_time_difference();
  void set_allocated_time_difference(::osi3::Timestamp* value);
  void unsafe_arena_set_allocated_time_difference(::osi3::Timestamp* value);
  ::osi3::Timestamp* unsafe_arena_release_time_difference();

  private:
  const ::osi3::Timestamp& _internal_time_difference() const;
  ::osi3::Timestamp* _internal_mutable_time_difference();

  public:
  // optional .osi3.Identifier ambiguity_id = 30;
  bool has_ambiguity_id() const;
  void clear_ambiguity_id() ;
  const ::osi3::Identifier& ambiguity_id() const;
  PROTOBUF_NODISCARD ::osi3::Identifier* release_ambiguity_id();
  ::osi3::Identifier* mutable_ambiguity_id();
  void set_allocated_ambiguity_id(::osi3::Identifier* value);
  void unsafe_arena_set_allocated_ambiguity_id(::osi3::Identifier* value);
  ::osi3::Identifier* unsafe_arena_release_ambiguity_id();

  private:
  const ::osi3::Identifier& _internal_ambiguity_id() const;
  ::osi3::Identifier* _internal_mutable_ambiguity_id();

  public:
  // optional .osi3.ColorDescription color_description = 33;
  bool has_color_description() const;
  void clear_color_description() ;
  const ::osi3::ColorDescription& color_description() const;
  PROTOBUF_NODISCARD ::osi3::ColorDescription* release_color_description();
  ::osi3::ColorDescription* mutable_color_description();
  void set_allocated_color_description(::osi3::ColorDescription* value);
  void unsafe_arena_set_allocated_color_description(::osi3::ColorDescription* value);
  ::osi3::ColorDescription* unsafe_arena_release_color_description();

  private:
  const ::osi3::ColorDescription& _internal_color_description() const;
  ::osi3::ColorDescription* _internal_mutable_color_description();

  public:
  // optional double existence_probability = 1;
  bool has_existence_probability() const;
  void clear_existence_probability() ;
  double existence_probability() const;
  void set_existence_probability(double value);

  private:
  double _internal_existence_probability() const;
  void _internal_set_existence_probability(double value);

  public:
  // optional .osi3.CameraDetection.ImageShapeType image_shape_type = 4;
  bool has_image_shape_type() const;
  void clear_image_shape_type() ;
  ::osi3::CameraDetection_ImageShapeType image_shape_type() const;
  void set_image_shape_type(::osi3::CameraDetection_ImageShapeType value);

  private:
  ::osi3::CameraDetection_ImageShapeType _internal_image_shape_type() const;
  void _internal_set_image_shape_type(::osi3::CameraDetection_ImageShapeType value);

  public:
  // optional bool shape_classification_background = 5;
  bool has_shape_classification_background() const;
  void clear_shape_classification_background() ;
  bool shape_classification_background() const;
  void set_shape_classification_background(bool value);

  private:
  bool _internal_shape_classification_background() const;
  void _internal_set_shape_classification_background(bool value);

  public:
  // optional bool shape_classification_foreground = 6;
  bool has_shape_classification_foreground() const;
  void clear_shape_classification_foreground() ;
  bool shape_classification_foreground() const;
  void set_shape_classification_foreground(bool value);

  private:
  bool _internal_shape_classification_foreground() const;
  void _internal_set_shape_classification_foreground(bool value);

  public:
  // optional bool shape_classification_flat = 7;
  bool has_shape_classification_flat() const;
  void clear_shape_classification_flat() ;
  bool shape_classification_flat() const;
  void set_shape_classification_flat(bool value);

  private:
  bool _internal_shape_classification_flat() const;
  void _internal_set_shape_classification_flat(bool value);

  public:
  // optional bool shape_classification_upright = 8;
  bool has_shape_classification_upright() const;
  void clear_shape_classification_upright() ;
  bool shape_classification_upright() const;
  void set_shape_classification_upright(bool value);

  private:
  bool _internal_shape_classification_upright() const;
  void _internal_set_shape_classification_upright(bool value);

  public:
  // optional bool shape_classification_ground = 9;
  bool has_shape_classification_ground() const;
  void clear_shape_classification_ground() ;
  bool shape_classification_ground() const;
  void set_shape_classification_ground(bool value);

  private:
  bool _internal_shape_classification_ground() const;
  void _internal_set_shape_classification_ground(bool value);

  public:
  // optional bool shape_classification_sky = 10;
  bool has_shape_classification_sky() const;
  void clear_shape_classification_sky() ;
  bool shape_classification_sky() const;
  void set_shape_classification_sky(bool value);

  private:
  bool _internal_shape_classification_sky() const;
  void _internal_set_shape_classification_sky(bool value);

  public:
  // optional bool shape_classification_vegetation = 11;
  bool has_shape_classification_vegetation() const;
  void clear_shape_classification_vegetation() ;
  bool shape_classification_vegetation() const;
  void set_shape_classification_vegetation(bool value);

  private:
  bool _internal_shape_classification_vegetation() const;
  void _internal_set_shape_classification_vegetation(bool value);

  public:
  // optional bool shape_classification_road = 12;
  bool has_shape_classification_road() const;
  void clear_shape_classification_road() ;
  bool shape_classification_road() const;
  void set_shape_classification_road(bool value);

  private:
  bool _internal_shape_classification_road() const;
  void _internal_set_shape_classification_road(bool value);

  public:
  // optional bool shape_classification_non_driving_lane = 13;
  bool has_shape_classification_non_driving_lane() const;
  void clear_shape_classification_non_driving_lane() ;
  bool shape_classification_non_driving_lane() const;
  void set_shape_classification_non_driving_lane(bool value);

  private:
  bool _internal_shape_classification_non_driving_lane() const;
  void _internal_set_shape_classification_non_driving_lane(bool value);

  public:
  // optional bool shape_classification_non_road = 14;
  bool has_shape_classification_non_road() const;
  void clear_shape_classification_non_road() ;
  bool shape_classification_non_road() const;
  void set_shape_classification_non_road(bool value);

  private:
  bool _internal_shape_classification_non_road() const;
  void _internal_set_shape_classification_non_road(bool value);

  public:
  // optional bool shape_classification_stationary_object = 15;
  bool has_shape_classification_stationary_object() const;
  void clear_shape_classification_stationary_object() ;
  bool shape_classification_stationary_object() const;
  void set_shape_classification_stationary_object(bool value);

  private:
  bool _internal_shape_classification_stationary_object() const;
  void _internal_set_shape_classification_stationary_object(bool value);

  public:
  // optional bool shape_classification_moving_object = 16;
  bool has_shape_classification_moving_object() const;
  void clear_shape_classification_moving_object() ;
  bool shape_classification_moving_object() const;
  void set_shape_classification_moving_object(bool value);

  private:
  bool _internal_shape_classification_moving_object() const;
  void _internal_set_shape_classification_moving_object(bool value);

  public:
  // optional bool shape_classification_landmark = 17;
  bool has_shape_classification_landmark() const;
  void clear_shape_classification_landmark() ;
  bool shape_classification_landmark() const;
  void set_shape_classification_landmark(bool value);

  private:
  bool _internal_shape_classification_landmark() const;
  void _internal_set_shape_classification_landmark(bool value);

  public:
  // optional bool shape_classification_traffic_sign = 18;
  bool has_shape_classification_traffic_sign() const;
  void clear_shape_classification_traffic_sign() ;
  bool shape_classification_traffic_sign() const;
  void set_shape_classification_traffic_sign(bool value);

  private:
  bool _internal_shape_classification_traffic_sign() const;
  void _internal_set_shape_classification_traffic_sign(bool value);

  public:
  // optional bool shape_classification_traffic_light = 19;
  bool has_shape_classification_traffic_light() const;
  void clear_shape_classification_traffic_light() ;
  bool shape_classification_traffic_light() const;
  void set_shape_classification_traffic_light(bool value);

  private:
  bool _internal_shape_classification_traffic_light() const;
  void _internal_set_shape_classification_traffic_light(bool value);

  public:
  // optional bool shape_classification_road_marking = 20;
  bool has_shape_classification_road_marking() const;
  void clear_shape_classification_road_marking() ;
  bool shape_classification_road_marking() const;
  void set_shape_classification_road_marking(bool value);

  private:
  bool _internal_shape_classification_road_marking() const;
  void _internal_set_shape_classification_road_marking(bool value);

  public:
  // optional bool shape_classification_vehicle = 21;
  bool has_shape_classification_vehicle() const;
  void clear_shape_classification_vehicle() ;
  bool shape_classification_vehicle() const;
  void set_shape_classification_vehicle(bool value);

  private:
  bool _internal_shape_classification_vehicle() const;
  void _internal_set_shape_classification_vehicle(bool value);

  public:
  // optional bool shape_classification_pedestrian = 22;
  bool has_shape_classification_pedestrian() const;
  void clear_shape_classification_pedestrian() ;
  bool shape_classification_pedestrian() const;
  void set_shape_classification_pedestrian(bool value);

  private:
  bool _internal_shape_classification_pedestrian() const;
  void _internal_set_shape_classification_pedestrian(bool value);

  public:
  // optional bool shape_classification_animal = 23;
  bool has_shape_classification_animal() const;
  void clear_shape_classification_animal() ;
  bool shape_classification_animal() const;
  void set_shape_classification_animal(bool value);

  private:
  bool _internal_shape_classification_animal() const;
  void _internal_set_shape_classification_animal(bool value);

  public:
  // optional bool shape_classification_pedestrian_front = 24;
  bool has_shape_classification_pedestrian_front() const;
  void clear_shape_classification_pedestrian_front() ;
  bool shape_classification_pedestrian_front() const;
  void set_shape_classification_pedestrian_front(bool value);

  private:
  bool _internal_shape_classification_pedestrian_front() const;
  void _internal_set_shape_classification_pedestrian_front(bool value);

  public:
  // optional bool shape_classification_pedestrian_side = 25;
  bool has_shape_classification_pedestrian_side() const;
  void clear_shape_classification_pedestrian_side() ;
  bool shape_classification_pedestrian_side() const;
  void set_shape_classification_pedestrian_side(bool value);

  private:
  bool _internal_shape_classification_pedestrian_side() const;
  void _internal_set_shape_classification_pedestrian_side(bool value);

  public:
  // optional bool shape_classification_pedestrian_rear = 26;
  bool has_shape_classification_pedestrian_rear() const;
  void clear_shape_classification_pedestrian_rear() ;
  bool shape_classification_pedestrian_rear() const;
  void set_shape_classification_pedestrian_rear(bool value);

  private:
  bool _internal_shape_classification_pedestrian_rear() const;
  void _internal_set_shape_classification_pedestrian_rear(bool value);

  public:
  // optional .osi3.CameraDetection.Color color = 28;
  bool has_color() const;
  void clear_color() ;
  ::osi3::CameraDetection_Color color() const;
  void set_color(::osi3::CameraDetection_Color value);

  private:
  ::osi3::CameraDetection_Color _internal_color() const;
  void _internal_set_color(::osi3::CameraDetection_Color value);

  public:
  // optional double shape_classification_probability = 27;
  bool has_shape_classification_probability() const;
  void clear_shape_classification_probability() ;
  double shape_classification_probability() const;
  void set_shape_classification_probability(double value);

  private:
  double _internal_shape_classification_probability() const;
  void _internal_set_shape_classification_probability(double value);

  public:
  // optional double color_probability = 29;
  bool has_color_probability() const;
  void clear_color_probability() ;
  double color_probability() const;
  void set_color_probability(double value);

  private:
  double _internal_color_probability() const;
  void _internal_set_color_probability(double value);

  public:
  // optional uint32 first_point_index = 31;
  bool has_first_point_index() const;
  void clear_first_point_index() ;
  ::uint32_t first_point_index() const;
  void set_first_point_index(::uint32_t value);

  private:
  ::uint32_t _internal_first_point_index() const;
  void _internal_set_first_point_index(::uint32_t value);

  public:
  // optional uint32 number_of_points = 32;
  bool has_number_of_points() const;
  void clear_number_of_points() ;
  ::uint32_t number_of_points() const;
  void set_number_of_points(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_points() const;
  void _internal_set_number_of_points(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.CameraDetection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 33, 6,
      0, 7>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CameraDetection& from_msg);
    ::google::protobuf::internal::HasBits<2> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::osi3::Identifier* object_id_;
    ::osi3::Timestamp* time_difference_;
    ::osi3::Identifier* ambiguity_id_;
    ::osi3::ColorDescription* color_description_;
    double existence_probability_;
    int image_shape_type_;
    bool shape_classification_background_;
    bool shape_classification_foreground_;
    bool shape_classification_flat_;
    bool shape_classification_upright_;
    bool shape_classification_ground_;
    bool shape_classification_sky_;
    bool shape_classification_vegetation_;
    bool shape_classification_road_;
    bool shape_classification_non_driving_lane_;
    bool shape_classification_non_road_;
    bool shape_classification_stationary_object_;
    bool shape_classification_moving_object_;
    bool shape_classification_landmark_;
    bool shape_classification_traffic_sign_;
    bool shape_classification_traffic_light_;
    bool shape_classification_road_marking_;
    bool shape_classification_vehicle_;
    bool shape_classification_pedestrian_;
    bool shape_classification_animal_;
    bool shape_classification_pedestrian_front_;
    bool shape_classification_pedestrian_side_;
    bool shape_classification_pedestrian_rear_;
    int color_;
    double shape_classification_probability_;
    double color_probability_;
    ::uint32_t first_point_index_;
    ::uint32_t number_of_points_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class UltrasonicDetectionData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.UltrasonicDetectionData) */ {
 public:
  inline UltrasonicDetectionData() : UltrasonicDetectionData(nullptr) {}
  ~UltrasonicDetectionData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UltrasonicDetectionData* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UltrasonicDetectionData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UltrasonicDetectionData(
      ::google::protobuf::internal::ConstantInitialized);

  inline UltrasonicDetectionData(const UltrasonicDetectionData& from) : UltrasonicDetectionData(nullptr, from) {}
  inline UltrasonicDetectionData(UltrasonicDetectionData&& from) noexcept
      : UltrasonicDetectionData(nullptr, std::move(from)) {}
  inline UltrasonicDetectionData& operator=(const UltrasonicDetectionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline UltrasonicDetectionData& operator=(UltrasonicDetectionData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UltrasonicDetectionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const UltrasonicDetectionData* internal_default_instance() {
    return reinterpret_cast<const UltrasonicDetectionData*>(
        &_UltrasonicDetectionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(UltrasonicDetectionData& a, UltrasonicDetectionData& b) { a.Swap(&b); }
  inline void Swap(UltrasonicDetectionData* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UltrasonicDetectionData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UltrasonicDetectionData* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UltrasonicDetectionData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UltrasonicDetectionData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UltrasonicDetectionData& from) { UltrasonicDetectionData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UltrasonicDetectionData* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.UltrasonicDetectionData"; }

 protected:
  explicit UltrasonicDetectionData(::google::protobuf::Arena* arena);
  UltrasonicDetectionData(::google::protobuf::Arena* arena, const UltrasonicDetectionData& from);
  UltrasonicDetectionData(::google::protobuf::Arena* arena, UltrasonicDetectionData&& from) noexcept
      : UltrasonicDetectionData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDetectionFieldNumber = 2,
    kIndirectDetectionFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kSpecificHeaderFieldNumber = 3,
  };
  // repeated .osi3.UltrasonicDetection detection = 2;
  int detection_size() const;
  private:
  int _internal_detection_size() const;

  public:
  void clear_detection() ;
  ::osi3::UltrasonicDetection* mutable_detection(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicDetection>* mutable_detection();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicDetection>& _internal_detection() const;
  ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicDetection>* _internal_mutable_detection();
  public:
  const ::osi3::UltrasonicDetection& detection(int index) const;
  ::osi3::UltrasonicDetection* add_detection();
  const ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicDetection>& detection() const;
  // repeated .osi3.UltrasonicIndirectDetection indirect_detection = 4;
  int indirect_detection_size() const;
  private:
  int _internal_indirect_detection_size() const;

  public:
  void clear_indirect_detection() ;
  ::osi3::UltrasonicIndirectDetection* mutable_indirect_detection(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicIndirectDetection>* mutable_indirect_detection();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicIndirectDetection>& _internal_indirect_detection() const;
  ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicIndirectDetection>* _internal_mutable_indirect_detection();
  public:
  const ::osi3::UltrasonicIndirectDetection& indirect_detection(int index) const;
  ::osi3::UltrasonicIndirectDetection* add_indirect_detection();
  const ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicIndirectDetection>& indirect_detection() const;
  // optional .osi3.SensorDetectionHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::osi3::SensorDetectionHeader& header() const;
  PROTOBUF_NODISCARD ::osi3::SensorDetectionHeader* release_header();
  ::osi3::SensorDetectionHeader* mutable_header();
  void set_allocated_header(::osi3::SensorDetectionHeader* value);
  void unsafe_arena_set_allocated_header(::osi3::SensorDetectionHeader* value);
  ::osi3::SensorDetectionHeader* unsafe_arena_release_header();

  private:
  const ::osi3::SensorDetectionHeader& _internal_header() const;
  ::osi3::SensorDetectionHeader* _internal_mutable_header();

  public:
  // optional .osi3.UltrasonicDetectionSpecificHeader specific_header = 3;
  bool has_specific_header() const;
  void clear_specific_header() ;
  const ::osi3::UltrasonicDetectionSpecificHeader& specific_header() const;
  PROTOBUF_NODISCARD ::osi3::UltrasonicDetectionSpecificHeader* release_specific_header();
  ::osi3::UltrasonicDetectionSpecificHeader* mutable_specific_header();
  void set_allocated_specific_header(::osi3::UltrasonicDetectionSpecificHeader* value);
  void unsafe_arena_set_allocated_specific_header(::osi3::UltrasonicDetectionSpecificHeader* value);
  ::osi3::UltrasonicDetectionSpecificHeader* unsafe_arena_release_specific_header();

  private:
  const ::osi3::UltrasonicDetectionSpecificHeader& _internal_specific_header() const;
  ::osi3::UltrasonicDetectionSpecificHeader* _internal_mutable_specific_header();

  public:
  // @@protoc_insertion_point(class_scope:osi3.UltrasonicDetectionData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UltrasonicDetectionData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicDetection > detection_;
    ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicIndirectDetection > indirect_detection_;
    ::osi3::SensorDetectionHeader* header_;
    ::osi3::UltrasonicDetectionSpecificHeader* specific_header_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class RadarDetectionData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.RadarDetectionData) */ {
 public:
  inline RadarDetectionData() : RadarDetectionData(nullptr) {}
  ~RadarDetectionData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RadarDetectionData* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RadarDetectionData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RadarDetectionData(
      ::google::protobuf::internal::ConstantInitialized);

  inline RadarDetectionData(const RadarDetectionData& from) : RadarDetectionData(nullptr, from) {}
  inline RadarDetectionData(RadarDetectionData&& from) noexcept
      : RadarDetectionData(nullptr, std::move(from)) {}
  inline RadarDetectionData& operator=(const RadarDetectionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadarDetectionData& operator=(RadarDetectionData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadarDetectionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadarDetectionData* internal_default_instance() {
    return reinterpret_cast<const RadarDetectionData*>(
        &_RadarDetectionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(RadarDetectionData& a, RadarDetectionData& b) { a.Swap(&b); }
  inline void Swap(RadarDetectionData* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadarDetectionData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RadarDetectionData* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RadarDetectionData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RadarDetectionData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RadarDetectionData& from) { RadarDetectionData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RadarDetectionData* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.RadarDetectionData"; }

 protected:
  explicit RadarDetectionData(::google::protobuf::Arena* arena);
  RadarDetectionData(::google::protobuf::Arena* arena, const RadarDetectionData& from);
  RadarDetectionData(::google::protobuf::Arena* arena, RadarDetectionData&& from) noexcept
      : RadarDetectionData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDetectionFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .osi3.RadarDetection detection = 2;
  int detection_size() const;
  private:
  int _internal_detection_size() const;

  public:
  void clear_detection() ;
  ::osi3::RadarDetection* mutable_detection(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::RadarDetection>* mutable_detection();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::RadarDetection>& _internal_detection() const;
  ::google::protobuf::RepeatedPtrField<::osi3::RadarDetection>* _internal_mutable_detection();
  public:
  const ::osi3::RadarDetection& detection(int index) const;
  ::osi3::RadarDetection* add_detection();
  const ::google::protobuf::RepeatedPtrField<::osi3::RadarDetection>& detection() const;
  // optional .osi3.SensorDetectionHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::osi3::SensorDetectionHeader& header() const;
  PROTOBUF_NODISCARD ::osi3::SensorDetectionHeader* release_header();
  ::osi3::SensorDetectionHeader* mutable_header();
  void set_allocated_header(::osi3::SensorDetectionHeader* value);
  void unsafe_arena_set_allocated_header(::osi3::SensorDetectionHeader* value);
  ::osi3::SensorDetectionHeader* unsafe_arena_release_header();

  private:
  const ::osi3::SensorDetectionHeader& _internal_header() const;
  ::osi3::SensorDetectionHeader* _internal_mutable_header();

  public:
  // @@protoc_insertion_point(class_scope:osi3.RadarDetectionData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RadarDetectionData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::osi3::RadarDetection > detection_;
    ::osi3::SensorDetectionHeader* header_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class LidarDetectionData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.LidarDetectionData) */ {
 public:
  inline LidarDetectionData() : LidarDetectionData(nullptr) {}
  ~LidarDetectionData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LidarDetectionData* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LidarDetectionData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LidarDetectionData(
      ::google::protobuf::internal::ConstantInitialized);

  inline LidarDetectionData(const LidarDetectionData& from) : LidarDetectionData(nullptr, from) {}
  inline LidarDetectionData(LidarDetectionData&& from) noexcept
      : LidarDetectionData(nullptr, std::move(from)) {}
  inline LidarDetectionData& operator=(const LidarDetectionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline LidarDetectionData& operator=(LidarDetectionData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LidarDetectionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const LidarDetectionData* internal_default_instance() {
    return reinterpret_cast<const LidarDetectionData*>(
        &_LidarDetectionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(LidarDetectionData& a, LidarDetectionData& b) { a.Swap(&b); }
  inline void Swap(LidarDetectionData* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LidarDetectionData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LidarDetectionData* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LidarDetectionData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LidarDetectionData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LidarDetectionData& from) { LidarDetectionData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LidarDetectionData* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.LidarDetectionData"; }

 protected:
  explicit LidarDetectionData(::google::protobuf::Arena* arena);
  LidarDetectionData(::google::protobuf::Arena* arena, const LidarDetectionData& from);
  LidarDetectionData(::google::protobuf::Arena* arena, LidarDetectionData&& from) noexcept
      : LidarDetectionData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDetectionFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .osi3.LidarDetection detection = 2;
  int detection_size() const;
  private:
  int _internal_detection_size() const;

  public:
  void clear_detection() ;
  ::osi3::LidarDetection* mutable_detection(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::LidarDetection>* mutable_detection();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::LidarDetection>& _internal_detection() const;
  ::google::protobuf::RepeatedPtrField<::osi3::LidarDetection>* _internal_mutable_detection();
  public:
  const ::osi3::LidarDetection& detection(int index) const;
  ::osi3::LidarDetection* add_detection();
  const ::google::protobuf::RepeatedPtrField<::osi3::LidarDetection>& detection() const;
  // optional .osi3.SensorDetectionHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::osi3::SensorDetectionHeader& header() const;
  PROTOBUF_NODISCARD ::osi3::SensorDetectionHeader* release_header();
  ::osi3::SensorDetectionHeader* mutable_header();
  void set_allocated_header(::osi3::SensorDetectionHeader* value);
  void unsafe_arena_set_allocated_header(::osi3::SensorDetectionHeader* value);
  ::osi3::SensorDetectionHeader* unsafe_arena_release_header();

  private:
  const ::osi3::SensorDetectionHeader& _internal_header() const;
  ::osi3::SensorDetectionHeader* _internal_mutable_header();

  public:
  // @@protoc_insertion_point(class_scope:osi3.LidarDetectionData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LidarDetectionData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::osi3::LidarDetection > detection_;
    ::osi3::SensorDetectionHeader* header_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class CameraDetectionData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.CameraDetectionData) */ {
 public:
  inline CameraDetectionData() : CameraDetectionData(nullptr) {}
  ~CameraDetectionData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CameraDetectionData* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CameraDetectionData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CameraDetectionData(
      ::google::protobuf::internal::ConstantInitialized);

  inline CameraDetectionData(const CameraDetectionData& from) : CameraDetectionData(nullptr, from) {}
  inline CameraDetectionData(CameraDetectionData&& from) noexcept
      : CameraDetectionData(nullptr, std::move(from)) {}
  inline CameraDetectionData& operator=(const CameraDetectionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraDetectionData& operator=(CameraDetectionData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraDetectionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraDetectionData* internal_default_instance() {
    return reinterpret_cast<const CameraDetectionData*>(
        &_CameraDetectionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(CameraDetectionData& a, CameraDetectionData& b) { a.Swap(&b); }
  inline void Swap(CameraDetectionData* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraDetectionData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CameraDetectionData* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CameraDetectionData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CameraDetectionData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CameraDetectionData& from) { CameraDetectionData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CameraDetectionData* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.CameraDetectionData"; }

 protected:
  explicit CameraDetectionData(::google::protobuf::Arena* arena);
  CameraDetectionData(::google::protobuf::Arena* arena, const CameraDetectionData& from);
  CameraDetectionData(::google::protobuf::Arena* arena, CameraDetectionData&& from) noexcept
      : CameraDetectionData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDetectionFieldNumber = 2,
    kPointFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kSpecificHeaderFieldNumber = 3,
  };
  // repeated .osi3.CameraDetection detection = 2;
  int detection_size() const;
  private:
  int _internal_detection_size() const;

  public:
  void clear_detection() ;
  ::osi3::CameraDetection* mutable_detection(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::CameraDetection>* mutable_detection();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::CameraDetection>& _internal_detection() const;
  ::google::protobuf::RepeatedPtrField<::osi3::CameraDetection>* _internal_mutable_detection();
  public:
  const ::osi3::CameraDetection& detection(int index) const;
  ::osi3::CameraDetection* add_detection();
  const ::google::protobuf::RepeatedPtrField<::osi3::CameraDetection>& detection() const;
  // repeated .osi3.CameraPoint point = 4;
  int point_size() const;
  private:
  int _internal_point_size() const;

  public:
  void clear_point() ;
  ::osi3::CameraPoint* mutable_point(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::CameraPoint>* mutable_point();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::CameraPoint>& _internal_point() const;
  ::google::protobuf::RepeatedPtrField<::osi3::CameraPoint>* _internal_mutable_point();
  public:
  const ::osi3::CameraPoint& point(int index) const;
  ::osi3::CameraPoint* add_point();
  const ::google::protobuf::RepeatedPtrField<::osi3::CameraPoint>& point() const;
  // optional .osi3.SensorDetectionHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::osi3::SensorDetectionHeader& header() const;
  PROTOBUF_NODISCARD ::osi3::SensorDetectionHeader* release_header();
  ::osi3::SensorDetectionHeader* mutable_header();
  void set_allocated_header(::osi3::SensorDetectionHeader* value);
  void unsafe_arena_set_allocated_header(::osi3::SensorDetectionHeader* value);
  ::osi3::SensorDetectionHeader* unsafe_arena_release_header();

  private:
  const ::osi3::SensorDetectionHeader& _internal_header() const;
  ::osi3::SensorDetectionHeader* _internal_mutable_header();

  public:
  // optional .osi3.CameraDetectionSpecificHeader specific_header = 3;
  bool has_specific_header() const;
  void clear_specific_header() ;
  const ::osi3::CameraDetectionSpecificHeader& specific_header() const;
  PROTOBUF_NODISCARD ::osi3::CameraDetectionSpecificHeader* release_specific_header();
  ::osi3::CameraDetectionSpecificHeader* mutable_specific_header();
  void set_allocated_specific_header(::osi3::CameraDetectionSpecificHeader* value);
  void unsafe_arena_set_allocated_specific_header(::osi3::CameraDetectionSpecificHeader* value);
  ::osi3::CameraDetectionSpecificHeader* unsafe_arena_release_specific_header();

  private:
  const ::osi3::CameraDetectionSpecificHeader& _internal_specific_header() const;
  ::osi3::CameraDetectionSpecificHeader* _internal_mutable_specific_header();

  public:
  // @@protoc_insertion_point(class_scope:osi3.CameraDetectionData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CameraDetectionData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::osi3::CameraDetection > detection_;
    ::google::protobuf::RepeatedPtrField< ::osi3::CameraPoint > point_;
    ::osi3::SensorDetectionHeader* header_;
    ::osi3::CameraDetectionSpecificHeader* specific_header_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class FeatureData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.FeatureData) */ {
 public:
  inline FeatureData() : FeatureData(nullptr) {}
  ~FeatureData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FeatureData* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FeatureData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FeatureData(
      ::google::protobuf::internal::ConstantInitialized);

  inline FeatureData(const FeatureData& from) : FeatureData(nullptr, from) {}
  inline FeatureData(FeatureData&& from) noexcept
      : FeatureData(nullptr, std::move(from)) {}
  inline FeatureData& operator=(const FeatureData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeatureData& operator=(FeatureData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeatureData& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeatureData* internal_default_instance() {
    return reinterpret_cast<const FeatureData*>(
        &_FeatureData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(FeatureData& a, FeatureData& b) { a.Swap(&b); }
  inline void Swap(FeatureData* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeatureData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeatureData* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FeatureData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FeatureData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FeatureData& from) { FeatureData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FeatureData* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.FeatureData"; }

 protected:
  explicit FeatureData(::google::protobuf::Arena* arena);
  FeatureData(::google::protobuf::Arena* arena, const FeatureData& from);
  FeatureData(::google::protobuf::Arena* arena, FeatureData&& from) noexcept
      : FeatureData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRadarSensorFieldNumber = 2,
    kLidarSensorFieldNumber = 3,
    kUltrasonicSensorFieldNumber = 4,
    kCameraSensorFieldNumber = 5,
    kVersionFieldNumber = 1,
  };
  // repeated .osi3.RadarDetectionData radar_sensor = 2;
  int radar_sensor_size() const;
  private:
  int _internal_radar_sensor_size() const;

  public:
  void clear_radar_sensor() ;
  ::osi3::RadarDetectionData* mutable_radar_sensor(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::RadarDetectionData>* mutable_radar_sensor();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::RadarDetectionData>& _internal_radar_sensor() const;
  ::google::protobuf::RepeatedPtrField<::osi3::RadarDetectionData>* _internal_mutable_radar_sensor();
  public:
  const ::osi3::RadarDetectionData& radar_sensor(int index) const;
  ::osi3::RadarDetectionData* add_radar_sensor();
  const ::google::protobuf::RepeatedPtrField<::osi3::RadarDetectionData>& radar_sensor() const;
  // repeated .osi3.LidarDetectionData lidar_sensor = 3;
  int lidar_sensor_size() const;
  private:
  int _internal_lidar_sensor_size() const;

  public:
  void clear_lidar_sensor() ;
  ::osi3::LidarDetectionData* mutable_lidar_sensor(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::LidarDetectionData>* mutable_lidar_sensor();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::LidarDetectionData>& _internal_lidar_sensor() const;
  ::google::protobuf::RepeatedPtrField<::osi3::LidarDetectionData>* _internal_mutable_lidar_sensor();
  public:
  const ::osi3::LidarDetectionData& lidar_sensor(int index) const;
  ::osi3::LidarDetectionData* add_lidar_sensor();
  const ::google::protobuf::RepeatedPtrField<::osi3::LidarDetectionData>& lidar_sensor() const;
  // repeated .osi3.UltrasonicDetectionData ultrasonic_sensor = 4;
  int ultrasonic_sensor_size() const;
  private:
  int _internal_ultrasonic_sensor_size() const;

  public:
  void clear_ultrasonic_sensor() ;
  ::osi3::UltrasonicDetectionData* mutable_ultrasonic_sensor(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicDetectionData>* mutable_ultrasonic_sensor();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicDetectionData>& _internal_ultrasonic_sensor() const;
  ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicDetectionData>* _internal_mutable_ultrasonic_sensor();
  public:
  const ::osi3::UltrasonicDetectionData& ultrasonic_sensor(int index) const;
  ::osi3::UltrasonicDetectionData* add_ultrasonic_sensor();
  const ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicDetectionData>& ultrasonic_sensor() const;
  // repeated .osi3.CameraDetectionData camera_sensor = 5;
  int camera_sensor_size() const;
  private:
  int _internal_camera_sensor_size() const;

  public:
  void clear_camera_sensor() ;
  ::osi3::CameraDetectionData* mutable_camera_sensor(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::CameraDetectionData>* mutable_camera_sensor();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::CameraDetectionData>& _internal_camera_sensor() const;
  ::google::protobuf::RepeatedPtrField<::osi3::CameraDetectionData>* _internal_mutable_camera_sensor();
  public:
  const ::osi3::CameraDetectionData& camera_sensor(int index) const;
  ::osi3::CameraDetectionData* add_camera_sensor();
  const ::google::protobuf::RepeatedPtrField<::osi3::CameraDetectionData>& camera_sensor() const;
  // optional .osi3.InterfaceVersion version = 1;
  bool has_version() const;
  void clear_version() ;
  const ::osi3::InterfaceVersion& version() const;
  PROTOBUF_NODISCARD ::osi3::InterfaceVersion* release_version();
  ::osi3::InterfaceVersion* mutable_version();
  void set_allocated_version(::osi3::InterfaceVersion* value);
  void unsafe_arena_set_allocated_version(::osi3::InterfaceVersion* value);
  ::osi3::InterfaceVersion* unsafe_arena_release_version();

  private:
  const ::osi3::InterfaceVersion& _internal_version() const;
  ::osi3::InterfaceVersion* _internal_mutable_version();

  public:
  // @@protoc_insertion_point(class_scope:osi3.FeatureData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 5,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FeatureData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::osi3::RadarDetectionData > radar_sensor_;
    ::google::protobuf::RepeatedPtrField< ::osi3::LidarDetectionData > lidar_sensor_;
    ::google::protobuf::RepeatedPtrField< ::osi3::UltrasonicDetectionData > ultrasonic_sensor_;
    ::google::protobuf::RepeatedPtrField< ::osi3::CameraDetectionData > camera_sensor_;
    ::osi3::InterfaceVersion* version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// FeatureData

// optional .osi3.InterfaceVersion version = 1;
inline bool FeatureData::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.version_ != nullptr);
  return value;
}
inline const ::osi3::InterfaceVersion& FeatureData::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::InterfaceVersion* p = _impl_.version_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::InterfaceVersion&>(::osi3::_InterfaceVersion_default_instance_);
}
inline const ::osi3::InterfaceVersion& FeatureData::version() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.FeatureData.version)
  return _internal_version();
}
inline void FeatureData::unsafe_arena_set_allocated_version(::osi3::InterfaceVersion* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.version_);
  }
  _impl_.version_ = reinterpret_cast<::osi3::InterfaceVersion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.FeatureData.version)
}
inline ::osi3::InterfaceVersion* FeatureData::release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::InterfaceVersion* released = _impl_.version_;
  _impl_.version_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::InterfaceVersion* FeatureData::unsafe_arena_release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.FeatureData.version)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::InterfaceVersion* temp = _impl_.version_;
  _impl_.version_ = nullptr;
  return temp;
}
inline ::osi3::InterfaceVersion* FeatureData::_internal_mutable_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.version_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::InterfaceVersion>(GetArena());
    _impl_.version_ = reinterpret_cast<::osi3::InterfaceVersion*>(p);
  }
  return _impl_.version_;
}
inline ::osi3::InterfaceVersion* FeatureData::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::InterfaceVersion* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.version)
  return _msg;
}
inline void FeatureData::set_allocated_version(::osi3::InterfaceVersion* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.version_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.version_ = reinterpret_cast<::osi3::InterfaceVersion*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.FeatureData.version)
}

// repeated .osi3.RadarDetectionData radar_sensor = 2;
inline int FeatureData::_internal_radar_sensor_size() const {
  return _internal_radar_sensor().size();
}
inline int FeatureData::radar_sensor_size() const {
  return _internal_radar_sensor_size();
}
inline void FeatureData::clear_radar_sensor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.radar_sensor_.Clear();
}
inline ::osi3::RadarDetectionData* FeatureData::mutable_radar_sensor(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.radar_sensor)
  return _internal_mutable_radar_sensor()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::RadarDetectionData>* FeatureData::mutable_radar_sensor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.FeatureData.radar_sensor)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_radar_sensor();
}
inline const ::osi3::RadarDetectionData& FeatureData::radar_sensor(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.FeatureData.radar_sensor)
  return _internal_radar_sensor().Get(index);
}
inline ::osi3::RadarDetectionData* FeatureData::add_radar_sensor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::RadarDetectionData* _add = _internal_mutable_radar_sensor()->Add();
  // @@protoc_insertion_point(field_add:osi3.FeatureData.radar_sensor)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::RadarDetectionData>& FeatureData::radar_sensor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.FeatureData.radar_sensor)
  return _internal_radar_sensor();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::RadarDetectionData>&
FeatureData::_internal_radar_sensor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.radar_sensor_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::RadarDetectionData>*
FeatureData::_internal_mutable_radar_sensor() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.radar_sensor_;
}

// repeated .osi3.LidarDetectionData lidar_sensor = 3;
inline int FeatureData::_internal_lidar_sensor_size() const {
  return _internal_lidar_sensor().size();
}
inline int FeatureData::lidar_sensor_size() const {
  return _internal_lidar_sensor_size();
}
inline void FeatureData::clear_lidar_sensor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lidar_sensor_.Clear();
}
inline ::osi3::LidarDetectionData* FeatureData::mutable_lidar_sensor(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.lidar_sensor)
  return _internal_mutable_lidar_sensor()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::LidarDetectionData>* FeatureData::mutable_lidar_sensor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.FeatureData.lidar_sensor)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_lidar_sensor();
}
inline const ::osi3::LidarDetectionData& FeatureData::lidar_sensor(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.FeatureData.lidar_sensor)
  return _internal_lidar_sensor().Get(index);
}
inline ::osi3::LidarDetectionData* FeatureData::add_lidar_sensor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::LidarDetectionData* _add = _internal_mutable_lidar_sensor()->Add();
  // @@protoc_insertion_point(field_add:osi3.FeatureData.lidar_sensor)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::LidarDetectionData>& FeatureData::lidar_sensor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.FeatureData.lidar_sensor)
  return _internal_lidar_sensor();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::LidarDetectionData>&
FeatureData::_internal_lidar_sensor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lidar_sensor_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::LidarDetectionData>*
FeatureData::_internal_mutable_lidar_sensor() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.lidar_sensor_;
}

// repeated .osi3.UltrasonicDetectionData ultrasonic_sensor = 4;
inline int FeatureData::_internal_ultrasonic_sensor_size() const {
  return _internal_ultrasonic_sensor().size();
}
inline int FeatureData::ultrasonic_sensor_size() const {
  return _internal_ultrasonic_sensor_size();
}
inline void FeatureData::clear_ultrasonic_sensor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ultrasonic_sensor_.Clear();
}
inline ::osi3::UltrasonicDetectionData* FeatureData::mutable_ultrasonic_sensor(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.ultrasonic_sensor)
  return _internal_mutable_ultrasonic_sensor()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicDetectionData>* FeatureData::mutable_ultrasonic_sensor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.FeatureData.ultrasonic_sensor)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ultrasonic_sensor();
}
inline const ::osi3::UltrasonicDetectionData& FeatureData::ultrasonic_sensor(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.FeatureData.ultrasonic_sensor)
  return _internal_ultrasonic_sensor().Get(index);
}
inline ::osi3::UltrasonicDetectionData* FeatureData::add_ultrasonic_sensor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::UltrasonicDetectionData* _add = _internal_mutable_ultrasonic_sensor()->Add();
  // @@protoc_insertion_point(field_add:osi3.FeatureData.ultrasonic_sensor)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicDetectionData>& FeatureData::ultrasonic_sensor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.FeatureData.ultrasonic_sensor)
  return _internal_ultrasonic_sensor();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicDetectionData>&
FeatureData::_internal_ultrasonic_sensor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ultrasonic_sensor_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicDetectionData>*
FeatureData::_internal_mutable_ultrasonic_sensor() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ultrasonic_sensor_;
}

// repeated .osi3.CameraDetectionData camera_sensor = 5;
inline int FeatureData::_internal_camera_sensor_size() const {
  return _internal_camera_sensor().size();
}
inline int FeatureData::camera_sensor_size() const {
  return _internal_camera_sensor_size();
}
inline void FeatureData::clear_camera_sensor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.camera_sensor_.Clear();
}
inline ::osi3::CameraDetectionData* FeatureData::mutable_camera_sensor(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.camera_sensor)
  return _internal_mutable_camera_sensor()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::CameraDetectionData>* FeatureData::mutable_camera_sensor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.FeatureData.camera_sensor)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_camera_sensor();
}
inline const ::osi3::CameraDetectionData& FeatureData::camera_sensor(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.FeatureData.camera_sensor)
  return _internal_camera_sensor().Get(index);
}
inline ::osi3::CameraDetectionData* FeatureData::add_camera_sensor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::CameraDetectionData* _add = _internal_mutable_camera_sensor()->Add();
  // @@protoc_insertion_point(field_add:osi3.FeatureData.camera_sensor)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::CameraDetectionData>& FeatureData::camera_sensor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.FeatureData.camera_sensor)
  return _internal_camera_sensor();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::CameraDetectionData>&
FeatureData::_internal_camera_sensor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.camera_sensor_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::CameraDetectionData>*
FeatureData::_internal_mutable_camera_sensor() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.camera_sensor_;
}

// -------------------------------------------------------------------

// SensorDetectionHeader

// optional .osi3.Timestamp measurement_time = 1;
inline bool SensorDetectionHeader::has_measurement_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.measurement_time_ != nullptr);
  return value;
}
inline const ::osi3::Timestamp& SensorDetectionHeader::_internal_measurement_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Timestamp* p = _impl_.measurement_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Timestamp&>(::osi3::_Timestamp_default_instance_);
}
inline const ::osi3::Timestamp& SensorDetectionHeader::measurement_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.measurement_time)
  return _internal_measurement_time();
}
inline void SensorDetectionHeader::unsafe_arena_set_allocated_measurement_time(::osi3::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.measurement_time_);
  }
  _impl_.measurement_time_ = reinterpret_cast<::osi3::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.SensorDetectionHeader.measurement_time)
}
inline ::osi3::Timestamp* SensorDetectionHeader::release_measurement_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Timestamp* released = _impl_.measurement_time_;
  _impl_.measurement_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Timestamp* SensorDetectionHeader::unsafe_arena_release_measurement_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.SensorDetectionHeader.measurement_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Timestamp* temp = _impl_.measurement_time_;
  _impl_.measurement_time_ = nullptr;
  return temp;
}
inline ::osi3::Timestamp* SensorDetectionHeader::_internal_mutable_measurement_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.measurement_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Timestamp>(GetArena());
    _impl_.measurement_time_ = reinterpret_cast<::osi3::Timestamp*>(p);
  }
  return _impl_.measurement_time_;
}
inline ::osi3::Timestamp* SensorDetectionHeader::mutable_measurement_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::Timestamp* _msg = _internal_mutable_measurement_time();
  // @@protoc_insertion_point(field_mutable:osi3.SensorDetectionHeader.measurement_time)
  return _msg;
}
inline void SensorDetectionHeader::set_allocated_measurement_time(::osi3::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.measurement_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.measurement_time_ = reinterpret_cast<::osi3::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.SensorDetectionHeader.measurement_time)
}

// optional uint64 cycle_counter = 2;
inline bool SensorDetectionHeader::has_cycle_counter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SensorDetectionHeader::clear_cycle_counter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cycle_counter_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t SensorDetectionHeader::cycle_counter() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.cycle_counter)
  return _internal_cycle_counter();
}
inline void SensorDetectionHeader::set_cycle_counter(::uint64_t value) {
  _internal_set_cycle_counter(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:osi3.SensorDetectionHeader.cycle_counter)
}
inline ::uint64_t SensorDetectionHeader::_internal_cycle_counter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cycle_counter_;
}
inline void SensorDetectionHeader::_internal_set_cycle_counter(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cycle_counter_ = value;
}

// optional .osi3.MountingPosition mounting_position = 3;
inline bool SensorDetectionHeader::has_mounting_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mounting_position_ != nullptr);
  return value;
}
inline const ::osi3::MountingPosition& SensorDetectionHeader::_internal_mounting_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::MountingPosition* p = _impl_.mounting_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::MountingPosition&>(::osi3::_MountingPosition_default_instance_);
}
inline const ::osi3::MountingPosition& SensorDetectionHeader::mounting_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.mounting_position)
  return _internal_mounting_position();
}
inline void SensorDetectionHeader::unsafe_arena_set_allocated_mounting_position(::osi3::MountingPosition* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mounting_position_);
  }
  _impl_.mounting_position_ = reinterpret_cast<::osi3::MountingPosition*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.SensorDetectionHeader.mounting_position)
}
inline ::osi3::MountingPosition* SensorDetectionHeader::release_mounting_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::MountingPosition* released = _impl_.mounting_position_;
  _impl_.mounting_position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::MountingPosition* SensorDetectionHeader::unsafe_arena_release_mounting_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.SensorDetectionHeader.mounting_position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::MountingPosition* temp = _impl_.mounting_position_;
  _impl_.mounting_position_ = nullptr;
  return temp;
}
inline ::osi3::MountingPosition* SensorDetectionHeader::_internal_mutable_mounting_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mounting_position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::MountingPosition>(GetArena());
    _impl_.mounting_position_ = reinterpret_cast<::osi3::MountingPosition*>(p);
  }
  return _impl_.mounting_position_;
}
inline ::osi3::MountingPosition* SensorDetectionHeader::mutable_mounting_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::osi3::MountingPosition* _msg = _internal_mutable_mounting_position();
  // @@protoc_insertion_point(field_mutable:osi3.SensorDetectionHeader.mounting_position)
  return _msg;
}
inline void SensorDetectionHeader::set_allocated_mounting_position(::osi3::MountingPosition* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mounting_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.mounting_position_ = reinterpret_cast<::osi3::MountingPosition*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.SensorDetectionHeader.mounting_position)
}

// optional .osi3.MountingPosition mounting_position_rmse = 4;
inline bool SensorDetectionHeader::has_mounting_position_rmse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mounting_position_rmse_ != nullptr);
  return value;
}
inline const ::osi3::MountingPosition& SensorDetectionHeader::_internal_mounting_position_rmse() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::MountingPosition* p = _impl_.mounting_position_rmse_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::MountingPosition&>(::osi3::_MountingPosition_default_instance_);
}
inline const ::osi3::MountingPosition& SensorDetectionHeader::mounting_position_rmse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.mounting_position_rmse)
  return _internal_mounting_position_rmse();
}
inline void SensorDetectionHeader::unsafe_arena_set_allocated_mounting_position_rmse(::osi3::MountingPosition* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mounting_position_rmse_);
  }
  _impl_.mounting_position_rmse_ = reinterpret_cast<::osi3::MountingPosition*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.SensorDetectionHeader.mounting_position_rmse)
}
inline ::osi3::MountingPosition* SensorDetectionHeader::release_mounting_position_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::MountingPosition* released = _impl_.mounting_position_rmse_;
  _impl_.mounting_position_rmse_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::MountingPosition* SensorDetectionHeader::unsafe_arena_release_mounting_position_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.SensorDetectionHeader.mounting_position_rmse)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::MountingPosition* temp = _impl_.mounting_position_rmse_;
  _impl_.mounting_position_rmse_ = nullptr;
  return temp;
}
inline ::osi3::MountingPosition* SensorDetectionHeader::_internal_mutable_mounting_position_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mounting_position_rmse_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::MountingPosition>(GetArena());
    _impl_.mounting_position_rmse_ = reinterpret_cast<::osi3::MountingPosition*>(p);
  }
  return _impl_.mounting_position_rmse_;
}
inline ::osi3::MountingPosition* SensorDetectionHeader::mutable_mounting_position_rmse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::osi3::MountingPosition* _msg = _internal_mutable_mounting_position_rmse();
  // @@protoc_insertion_point(field_mutable:osi3.SensorDetectionHeader.mounting_position_rmse)
  return _msg;
}
inline void SensorDetectionHeader::set_allocated_mounting_position_rmse(::osi3::MountingPosition* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mounting_position_rmse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.mounting_position_rmse_ = reinterpret_cast<::osi3::MountingPosition*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.SensorDetectionHeader.mounting_position_rmse)
}

// optional .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
inline bool SensorDetectionHeader::has_data_qualifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SensorDetectionHeader::clear_data_qualifier() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_qualifier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::osi3::SensorDetectionHeader_DataQualifier SensorDetectionHeader::data_qualifier() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.data_qualifier)
  return _internal_data_qualifier();
}
inline void SensorDetectionHeader::set_data_qualifier(::osi3::SensorDetectionHeader_DataQualifier value) {
  _internal_set_data_qualifier(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:osi3.SensorDetectionHeader.data_qualifier)
}
inline ::osi3::SensorDetectionHeader_DataQualifier SensorDetectionHeader::_internal_data_qualifier() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::osi3::SensorDetectionHeader_DataQualifier>(_impl_.data_qualifier_);
}
inline void SensorDetectionHeader::_internal_set_data_qualifier(::osi3::SensorDetectionHeader_DataQualifier value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::osi3::SensorDetectionHeader_DataQualifier_IsValid(value));
  _impl_.data_qualifier_ = value;
}

// optional uint32 number_of_valid_detections = 6;
inline bool SensorDetectionHeader::has_number_of_valid_detections() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SensorDetectionHeader::clear_number_of_valid_detections() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_of_valid_detections_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t SensorDetectionHeader::number_of_valid_detections() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.number_of_valid_detections)
  return _internal_number_of_valid_detections();
}
inline void SensorDetectionHeader::set_number_of_valid_detections(::uint32_t value) {
  _internal_set_number_of_valid_detections(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:osi3.SensorDetectionHeader.number_of_valid_detections)
}
inline ::uint32_t SensorDetectionHeader::_internal_number_of_valid_detections() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.number_of_valid_detections_;
}
inline void SensorDetectionHeader::_internal_set_number_of_valid_detections(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_of_valid_detections_ = value;
}

// optional .osi3.Identifier sensor_id = 7;
inline bool SensorDetectionHeader::has_sensor_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sensor_id_ != nullptr);
  return value;
}
inline const ::osi3::Identifier& SensorDetectionHeader::_internal_sensor_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Identifier* p = _impl_.sensor_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Identifier&>(::osi3::_Identifier_default_instance_);
}
inline const ::osi3::Identifier& SensorDetectionHeader::sensor_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.sensor_id)
  return _internal_sensor_id();
}
inline void SensorDetectionHeader::unsafe_arena_set_allocated_sensor_id(::osi3::Identifier* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sensor_id_);
  }
  _impl_.sensor_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.SensorDetectionHeader.sensor_id)
}
inline ::osi3::Identifier* SensorDetectionHeader::release_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::osi3::Identifier* released = _impl_.sensor_id_;
  _impl_.sensor_id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Identifier* SensorDetectionHeader::unsafe_arena_release_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.SensorDetectionHeader.sensor_id)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::osi3::Identifier* temp = _impl_.sensor_id_;
  _impl_.sensor_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* SensorDetectionHeader::_internal_mutable_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sensor_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Identifier>(GetArena());
    _impl_.sensor_id_ = reinterpret_cast<::osi3::Identifier*>(p);
  }
  return _impl_.sensor_id_;
}
inline ::osi3::Identifier* SensorDetectionHeader::mutable_sensor_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::osi3::Identifier* _msg = _internal_mutable_sensor_id();
  // @@protoc_insertion_point(field_mutable:osi3.SensorDetectionHeader.sensor_id)
  return _msg;
}
inline void SensorDetectionHeader::set_allocated_sensor_id(::osi3::Identifier* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sensor_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.sensor_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.SensorDetectionHeader.sensor_id)
}

// optional .osi3.SensorDetectionHeader.ExtendedQualifier extended_qualifier = 8;
inline bool SensorDetectionHeader::has_extended_qualifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void SensorDetectionHeader::clear_extended_qualifier() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extended_qualifier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::osi3::SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::extended_qualifier() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.extended_qualifier)
  return _internal_extended_qualifier();
}
inline void SensorDetectionHeader::set_extended_qualifier(::osi3::SensorDetectionHeader_ExtendedQualifier value) {
  _internal_set_extended_qualifier(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:osi3.SensorDetectionHeader.extended_qualifier)
}
inline ::osi3::SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::_internal_extended_qualifier() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::osi3::SensorDetectionHeader_ExtendedQualifier>(_impl_.extended_qualifier_);
}
inline void SensorDetectionHeader::_internal_set_extended_qualifier(::osi3::SensorDetectionHeader_ExtendedQualifier value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::osi3::SensorDetectionHeader_ExtendedQualifier_IsValid(value));
  _impl_.extended_qualifier_ = value;
}

// -------------------------------------------------------------------

// RadarDetectionData

// optional .osi3.SensorDetectionHeader header = 1;
inline bool RadarDetectionData::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void RadarDetectionData::clear_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::osi3::SensorDetectionHeader& RadarDetectionData::_internal_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::SensorDetectionHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::SensorDetectionHeader&>(::osi3::_SensorDetectionHeader_default_instance_);
}
inline const ::osi3::SensorDetectionHeader& RadarDetectionData::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.RadarDetectionData.header)
  return _internal_header();
}
inline void RadarDetectionData::unsafe_arena_set_allocated_header(::osi3::SensorDetectionHeader* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::osi3::SensorDetectionHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.RadarDetectionData.header)
}
inline ::osi3::SensorDetectionHeader* RadarDetectionData::release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::SensorDetectionHeader* released = _impl_.header_;
  _impl_.header_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::SensorDetectionHeader* RadarDetectionData::unsafe_arena_release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.RadarDetectionData.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::SensorDetectionHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::osi3::SensorDetectionHeader* RadarDetectionData::_internal_mutable_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::SensorDetectionHeader>(GetArena());
    _impl_.header_ = reinterpret_cast<::osi3::SensorDetectionHeader*>(p);
  }
  return _impl_.header_;
}
inline ::osi3::SensorDetectionHeader* RadarDetectionData::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::SensorDetectionHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetectionData.header)
  return _msg;
}
inline void RadarDetectionData::set_allocated_header(::osi3::SensorDetectionHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::osi3::SensorDetectionHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetectionData.header)
}

// repeated .osi3.RadarDetection detection = 2;
inline int RadarDetectionData::_internal_detection_size() const {
  return _internal_detection().size();
}
inline int RadarDetectionData::detection_size() const {
  return _internal_detection_size();
}
inline void RadarDetectionData::clear_detection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.detection_.Clear();
}
inline ::osi3::RadarDetection* RadarDetectionData::mutable_detection(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetectionData.detection)
  return _internal_mutable_detection()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::RadarDetection>* RadarDetectionData::mutable_detection()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.RadarDetectionData.detection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_detection();
}
inline const ::osi3::RadarDetection& RadarDetectionData::detection(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.RadarDetectionData.detection)
  return _internal_detection().Get(index);
}
inline ::osi3::RadarDetection* RadarDetectionData::add_detection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::RadarDetection* _add = _internal_mutable_detection()->Add();
  // @@protoc_insertion_point(field_add:osi3.RadarDetectionData.detection)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::RadarDetection>& RadarDetectionData::detection() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.RadarDetectionData.detection)
  return _internal_detection();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::RadarDetection>&
RadarDetectionData::_internal_detection() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.detection_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::RadarDetection>*
RadarDetectionData::_internal_mutable_detection() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.detection_;
}

// -------------------------------------------------------------------

// RadarDetection

// optional double existence_probability = 1;
inline bool RadarDetection::has_existence_probability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RadarDetection::clear_existence_probability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.existence_probability_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double RadarDetection::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.existence_probability)
  return _internal_existence_probability();
}
inline void RadarDetection::set_existence_probability(double value) {
  _internal_set_existence_probability(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.existence_probability)
}
inline double RadarDetection::_internal_existence_probability() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.existence_probability_;
}
inline void RadarDetection::_internal_set_existence_probability(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.existence_probability_ = value;
}

// optional .osi3.Identifier object_id = 2;
inline bool RadarDetection::has_object_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_id_ != nullptr);
  return value;
}
inline const ::osi3::Identifier& RadarDetection::_internal_object_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Identifier* p = _impl_.object_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Identifier&>(::osi3::_Identifier_default_instance_);
}
inline const ::osi3::Identifier& RadarDetection::object_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.object_id)
  return _internal_object_id();
}
inline void RadarDetection::unsafe_arena_set_allocated_object_id(::osi3::Identifier* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_id_);
  }
  _impl_.object_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.RadarDetection.object_id)
}
inline ::osi3::Identifier* RadarDetection::release_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Identifier* released = _impl_.object_id_;
  _impl_.object_id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Identifier* RadarDetection::unsafe_arena_release_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.RadarDetection.object_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Identifier* temp = _impl_.object_id_;
  _impl_.object_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* RadarDetection::_internal_mutable_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.object_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Identifier>(GetArena());
    _impl_.object_id_ = reinterpret_cast<::osi3::Identifier*>(p);
  }
  return _impl_.object_id_;
}
inline ::osi3::Identifier* RadarDetection::mutable_object_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::Identifier* _msg = _internal_mutable_object_id();
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetection.object_id)
  return _msg;
}
inline void RadarDetection::set_allocated_object_id(::osi3::Identifier* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.object_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetection.object_id)
}

// optional .osi3.Spherical3d position = 3;
inline bool RadarDetection::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::osi3::Spherical3d& RadarDetection::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Spherical3d* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Spherical3d&>(::osi3::_Spherical3d_default_instance_);
}
inline const ::osi3::Spherical3d& RadarDetection::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.position)
  return _internal_position();
}
inline void RadarDetection::unsafe_arena_set_allocated_position(::osi3::Spherical3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::osi3::Spherical3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.RadarDetection.position)
}
inline ::osi3::Spherical3d* RadarDetection::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Spherical3d* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Spherical3d* RadarDetection::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.RadarDetection.position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Spherical3d* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::osi3::Spherical3d* RadarDetection::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Spherical3d>(GetArena());
    _impl_.position_ = reinterpret_cast<::osi3::Spherical3d*>(p);
  }
  return _impl_.position_;
}
inline ::osi3::Spherical3d* RadarDetection::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::osi3::Spherical3d* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetection.position)
  return _msg;
}
inline void RadarDetection::set_allocated_position(::osi3::Spherical3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.position_ = reinterpret_cast<::osi3::Spherical3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetection.position)
}

// optional .osi3.Spherical3d position_rmse = 4;
inline bool RadarDetection::has_position_rmse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_rmse_ != nullptr);
  return value;
}
inline const ::osi3::Spherical3d& RadarDetection::_internal_position_rmse() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Spherical3d* p = _impl_.position_rmse_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Spherical3d&>(::osi3::_Spherical3d_default_instance_);
}
inline const ::osi3::Spherical3d& RadarDetection::position_rmse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.position_rmse)
  return _internal_position_rmse();
}
inline void RadarDetection::unsafe_arena_set_allocated_position_rmse(::osi3::Spherical3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_rmse_);
  }
  _impl_.position_rmse_ = reinterpret_cast<::osi3::Spherical3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.RadarDetection.position_rmse)
}
inline ::osi3::Spherical3d* RadarDetection::release_position_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::Spherical3d* released = _impl_.position_rmse_;
  _impl_.position_rmse_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Spherical3d* RadarDetection::unsafe_arena_release_position_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.RadarDetection.position_rmse)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::Spherical3d* temp = _impl_.position_rmse_;
  _impl_.position_rmse_ = nullptr;
  return temp;
}
inline ::osi3::Spherical3d* RadarDetection::_internal_mutable_position_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_rmse_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Spherical3d>(GetArena());
    _impl_.position_rmse_ = reinterpret_cast<::osi3::Spherical3d*>(p);
  }
  return _impl_.position_rmse_;
}
inline ::osi3::Spherical3d* RadarDetection::mutable_position_rmse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::osi3::Spherical3d* _msg = _internal_mutable_position_rmse();
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetection.position_rmse)
  return _msg;
}
inline void RadarDetection::set_allocated_position_rmse(::osi3::Spherical3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_rmse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.position_rmse_ = reinterpret_cast<::osi3::Spherical3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetection.position_rmse)
}

// optional double radial_velocity = 5;
inline bool RadarDetection::has_radial_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RadarDetection::clear_radial_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.radial_velocity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double RadarDetection::radial_velocity() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.radial_velocity)
  return _internal_radial_velocity();
}
inline void RadarDetection::set_radial_velocity(double value) {
  _internal_set_radial_velocity(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.radial_velocity)
}
inline double RadarDetection::_internal_radial_velocity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.radial_velocity_;
}
inline void RadarDetection::_internal_set_radial_velocity(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.radial_velocity_ = value;
}

// optional double radial_velocity_rmse = 6;
inline bool RadarDetection::has_radial_velocity_rmse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void RadarDetection::clear_radial_velocity_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.radial_velocity_rmse_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double RadarDetection::radial_velocity_rmse() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.radial_velocity_rmse)
  return _internal_radial_velocity_rmse();
}
inline void RadarDetection::set_radial_velocity_rmse(double value) {
  _internal_set_radial_velocity_rmse(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.radial_velocity_rmse)
}
inline double RadarDetection::_internal_radial_velocity_rmse() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.radial_velocity_rmse_;
}
inline void RadarDetection::_internal_set_radial_velocity_rmse(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.radial_velocity_rmse_ = value;
}

// optional double rcs = 7;
inline bool RadarDetection::has_rcs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void RadarDetection::clear_rcs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rcs_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double RadarDetection::rcs() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.rcs)
  return _internal_rcs();
}
inline void RadarDetection::set_rcs(double value) {
  _internal_set_rcs(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.rcs)
}
inline double RadarDetection::_internal_rcs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rcs_;
}
inline void RadarDetection::_internal_set_rcs(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rcs_ = value;
}

// optional double snr = 8;
inline bool RadarDetection::has_snr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void RadarDetection::clear_snr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snr_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double RadarDetection::snr() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.snr)
  return _internal_snr();
}
inline void RadarDetection::set_snr(double value) {
  _internal_set_snr(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.snr)
}
inline double RadarDetection::_internal_snr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.snr_;
}
inline void RadarDetection::_internal_set_snr(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snr_ = value;
}

// optional double point_target_probability = 9;
inline bool RadarDetection::has_point_target_probability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void RadarDetection::clear_point_target_probability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.point_target_probability_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline double RadarDetection::point_target_probability() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.point_target_probability)
  return _internal_point_target_probability();
}
inline void RadarDetection::set_point_target_probability(double value) {
  _internal_set_point_target_probability(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.point_target_probability)
}
inline double RadarDetection::_internal_point_target_probability() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.point_target_probability_;
}
inline void RadarDetection::_internal_set_point_target_probability(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.point_target_probability_ = value;
}

// optional .osi3.Identifier ambiguity_id = 10;
inline bool RadarDetection::has_ambiguity_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ambiguity_id_ != nullptr);
  return value;
}
inline const ::osi3::Identifier& RadarDetection::_internal_ambiguity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Identifier* p = _impl_.ambiguity_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Identifier&>(::osi3::_Identifier_default_instance_);
}
inline const ::osi3::Identifier& RadarDetection::ambiguity_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.ambiguity_id)
  return _internal_ambiguity_id();
}
inline void RadarDetection::unsafe_arena_set_allocated_ambiguity_id(::osi3::Identifier* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ambiguity_id_);
  }
  _impl_.ambiguity_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.RadarDetection.ambiguity_id)
}
inline ::osi3::Identifier* RadarDetection::release_ambiguity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::osi3::Identifier* released = _impl_.ambiguity_id_;
  _impl_.ambiguity_id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Identifier* RadarDetection::unsafe_arena_release_ambiguity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.RadarDetection.ambiguity_id)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::osi3::Identifier* temp = _impl_.ambiguity_id_;
  _impl_.ambiguity_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* RadarDetection::_internal_mutable_ambiguity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ambiguity_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Identifier>(GetArena());
    _impl_.ambiguity_id_ = reinterpret_cast<::osi3::Identifier*>(p);
  }
  return _impl_.ambiguity_id_;
}
inline ::osi3::Identifier* RadarDetection::mutable_ambiguity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::osi3::Identifier* _msg = _internal_mutable_ambiguity_id();
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetection.ambiguity_id)
  return _msg;
}
inline void RadarDetection::set_allocated_ambiguity_id(::osi3::Identifier* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ambiguity_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.ambiguity_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetection.ambiguity_id)
}

// optional .osi3.DetectionClassification classification = 11;
inline bool RadarDetection::has_classification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void RadarDetection::clear_classification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.classification_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::osi3::DetectionClassification RadarDetection::classification() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.classification)
  return _internal_classification();
}
inline void RadarDetection::set_classification(::osi3::DetectionClassification value) {
  _internal_set_classification(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.classification)
}
inline ::osi3::DetectionClassification RadarDetection::_internal_classification() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::osi3::DetectionClassification>(_impl_.classification_);
}
inline void RadarDetection::_internal_set_classification(::osi3::DetectionClassification value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::osi3::DetectionClassification_IsValid(value));
  _impl_.classification_ = value;
}

// -------------------------------------------------------------------

// LidarDetectionData

// optional .osi3.SensorDetectionHeader header = 1;
inline bool LidarDetectionData::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void LidarDetectionData::clear_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::osi3::SensorDetectionHeader& LidarDetectionData::_internal_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::SensorDetectionHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::SensorDetectionHeader&>(::osi3::_SensorDetectionHeader_default_instance_);
}
inline const ::osi3::SensorDetectionHeader& LidarDetectionData::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.LidarDetectionData.header)
  return _internal_header();
}
inline void LidarDetectionData::unsafe_arena_set_allocated_header(::osi3::SensorDetectionHeader* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::osi3::SensorDetectionHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.LidarDetectionData.header)
}
inline ::osi3::SensorDetectionHeader* LidarDetectionData::release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::SensorDetectionHeader* released = _impl_.header_;
  _impl_.header_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::SensorDetectionHeader* LidarDetectionData::unsafe_arena_release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.LidarDetectionData.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::SensorDetectionHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::osi3::SensorDetectionHeader* LidarDetectionData::_internal_mutable_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::SensorDetectionHeader>(GetArena());
    _impl_.header_ = reinterpret_cast<::osi3::SensorDetectionHeader*>(p);
  }
  return _impl_.header_;
}
inline ::osi3::SensorDetectionHeader* LidarDetectionData::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::SensorDetectionHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetectionData.header)
  return _msg;
}
inline void LidarDetectionData::set_allocated_header(::osi3::SensorDetectionHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::osi3::SensorDetectionHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.LidarDetectionData.header)
}

// repeated .osi3.LidarDetection detection = 2;
inline int LidarDetectionData::_internal_detection_size() const {
  return _internal_detection().size();
}
inline int LidarDetectionData::detection_size() const {
  return _internal_detection_size();
}
inline void LidarDetectionData::clear_detection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.detection_.Clear();
}
inline ::osi3::LidarDetection* LidarDetectionData::mutable_detection(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetectionData.detection)
  return _internal_mutable_detection()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::LidarDetection>* LidarDetectionData::mutable_detection()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.LidarDetectionData.detection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_detection();
}
inline const ::osi3::LidarDetection& LidarDetectionData::detection(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.LidarDetectionData.detection)
  return _internal_detection().Get(index);
}
inline ::osi3::LidarDetection* LidarDetectionData::add_detection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::LidarDetection* _add = _internal_mutable_detection()->Add();
  // @@protoc_insertion_point(field_add:osi3.LidarDetectionData.detection)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::LidarDetection>& LidarDetectionData::detection() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.LidarDetectionData.detection)
  return _internal_detection();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::LidarDetection>&
LidarDetectionData::_internal_detection() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.detection_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::LidarDetection>*
LidarDetectionData::_internal_mutable_detection() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.detection_;
}

// -------------------------------------------------------------------

// LidarDetection

// optional double existence_probability = 1;
inline bool LidarDetection::has_existence_probability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void LidarDetection::clear_existence_probability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.existence_probability_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double LidarDetection::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.existence_probability)
  return _internal_existence_probability();
}
inline void LidarDetection::set_existence_probability(double value) {
  _internal_set_existence_probability(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.existence_probability)
}
inline double LidarDetection::_internal_existence_probability() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.existence_probability_;
}
inline void LidarDetection::_internal_set_existence_probability(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.existence_probability_ = value;
}

// optional .osi3.Identifier object_id = 2;
inline bool LidarDetection::has_object_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_id_ != nullptr);
  return value;
}
inline const ::osi3::Identifier& LidarDetection::_internal_object_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Identifier* p = _impl_.object_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Identifier&>(::osi3::_Identifier_default_instance_);
}
inline const ::osi3::Identifier& LidarDetection::object_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.object_id)
  return _internal_object_id();
}
inline void LidarDetection::unsafe_arena_set_allocated_object_id(::osi3::Identifier* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_id_);
  }
  _impl_.object_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.LidarDetection.object_id)
}
inline ::osi3::Identifier* LidarDetection::release_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Identifier* released = _impl_.object_id_;
  _impl_.object_id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Identifier* LidarDetection::unsafe_arena_release_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.LidarDetection.object_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Identifier* temp = _impl_.object_id_;
  _impl_.object_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* LidarDetection::_internal_mutable_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.object_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Identifier>(GetArena());
    _impl_.object_id_ = reinterpret_cast<::osi3::Identifier*>(p);
  }
  return _impl_.object_id_;
}
inline ::osi3::Identifier* LidarDetection::mutable_object_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::Identifier* _msg = _internal_mutable_object_id();
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetection.object_id)
  return _msg;
}
inline void LidarDetection::set_allocated_object_id(::osi3::Identifier* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.object_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.LidarDetection.object_id)
}

// optional .osi3.Spherical3d position = 3;
inline bool LidarDetection::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::osi3::Spherical3d& LidarDetection::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Spherical3d* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Spherical3d&>(::osi3::_Spherical3d_default_instance_);
}
inline const ::osi3::Spherical3d& LidarDetection::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.position)
  return _internal_position();
}
inline void LidarDetection::unsafe_arena_set_allocated_position(::osi3::Spherical3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::osi3::Spherical3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.LidarDetection.position)
}
inline ::osi3::Spherical3d* LidarDetection::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Spherical3d* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Spherical3d* LidarDetection::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.LidarDetection.position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Spherical3d* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::osi3::Spherical3d* LidarDetection::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Spherical3d>(GetArena());
    _impl_.position_ = reinterpret_cast<::osi3::Spherical3d*>(p);
  }
  return _impl_.position_;
}
inline ::osi3::Spherical3d* LidarDetection::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::osi3::Spherical3d* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetection.position)
  return _msg;
}
inline void LidarDetection::set_allocated_position(::osi3::Spherical3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.position_ = reinterpret_cast<::osi3::Spherical3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.LidarDetection.position)
}

// optional .osi3.Spherical3d position_rmse = 4;
inline bool LidarDetection::has_position_rmse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_rmse_ != nullptr);
  return value;
}
inline const ::osi3::Spherical3d& LidarDetection::_internal_position_rmse() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Spherical3d* p = _impl_.position_rmse_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Spherical3d&>(::osi3::_Spherical3d_default_instance_);
}
inline const ::osi3::Spherical3d& LidarDetection::position_rmse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.position_rmse)
  return _internal_position_rmse();
}
inline void LidarDetection::unsafe_arena_set_allocated_position_rmse(::osi3::Spherical3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_rmse_);
  }
  _impl_.position_rmse_ = reinterpret_cast<::osi3::Spherical3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.LidarDetection.position_rmse)
}
inline ::osi3::Spherical3d* LidarDetection::release_position_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::Spherical3d* released = _impl_.position_rmse_;
  _impl_.position_rmse_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Spherical3d* LidarDetection::unsafe_arena_release_position_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.LidarDetection.position_rmse)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::Spherical3d* temp = _impl_.position_rmse_;
  _impl_.position_rmse_ = nullptr;
  return temp;
}
inline ::osi3::Spherical3d* LidarDetection::_internal_mutable_position_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_rmse_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Spherical3d>(GetArena());
    _impl_.position_rmse_ = reinterpret_cast<::osi3::Spherical3d*>(p);
  }
  return _impl_.position_rmse_;
}
inline ::osi3::Spherical3d* LidarDetection::mutable_position_rmse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::osi3::Spherical3d* _msg = _internal_mutable_position_rmse();
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetection.position_rmse)
  return _msg;
}
inline void LidarDetection::set_allocated_position_rmse(::osi3::Spherical3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_rmse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.position_rmse_ = reinterpret_cast<::osi3::Spherical3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.LidarDetection.position_rmse)
}

// optional double height = 5;
inline bool LidarDetection::has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void LidarDetection::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double LidarDetection::height() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.height)
  return _internal_height();
}
inline void LidarDetection::set_height(double value) {
  _internal_set_height(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.height)
}
inline double LidarDetection::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void LidarDetection::_internal_set_height(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// optional double height_rmse = 6;
inline bool LidarDetection::has_height_rmse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void LidarDetection::clear_height_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_rmse_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double LidarDetection::height_rmse() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.height_rmse)
  return _internal_height_rmse();
}
inline void LidarDetection::set_height_rmse(double value) {
  _internal_set_height_rmse(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.height_rmse)
}
inline double LidarDetection::_internal_height_rmse() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_rmse_;
}
inline void LidarDetection::_internal_set_height_rmse(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_rmse_ = value;
}

// optional double intensity = 7;
inline bool LidarDetection::has_intensity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void LidarDetection::clear_intensity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.intensity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double LidarDetection::intensity() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.intensity)
  return _internal_intensity();
}
inline void LidarDetection::set_intensity(double value) {
  _internal_set_intensity(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.intensity)
}
inline double LidarDetection::_internal_intensity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.intensity_;
}
inline void LidarDetection::_internal_set_intensity(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.intensity_ = value;
}

// optional double free_space_probability = 8;
inline bool LidarDetection::has_free_space_probability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void LidarDetection::clear_free_space_probability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.free_space_probability_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double LidarDetection::free_space_probability() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.free_space_probability)
  return _internal_free_space_probability();
}
inline void LidarDetection::set_free_space_probability(double value) {
  _internal_set_free_space_probability(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.free_space_probability)
}
inline double LidarDetection::_internal_free_space_probability() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.free_space_probability_;
}
inline void LidarDetection::_internal_set_free_space_probability(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.free_space_probability_ = value;
}

// optional .osi3.DetectionClassification classification = 9;
inline bool LidarDetection::has_classification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void LidarDetection::clear_classification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.classification_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::osi3::DetectionClassification LidarDetection::classification() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.classification)
  return _internal_classification();
}
inline void LidarDetection::set_classification(::osi3::DetectionClassification value) {
  _internal_set_classification(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.classification)
}
inline ::osi3::DetectionClassification LidarDetection::_internal_classification() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::osi3::DetectionClassification>(_impl_.classification_);
}
inline void LidarDetection::_internal_set_classification(::osi3::DetectionClassification value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::osi3::DetectionClassification_IsValid(value));
  _impl_.classification_ = value;
}

// optional double reflectivity = 10;
inline bool LidarDetection::has_reflectivity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void LidarDetection::clear_reflectivity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reflectivity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double LidarDetection::reflectivity() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.reflectivity)
  return _internal_reflectivity();
}
inline void LidarDetection::set_reflectivity(double value) {
  _internal_set_reflectivity(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.reflectivity)
}
inline double LidarDetection::_internal_reflectivity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reflectivity_;
}
inline void LidarDetection::_internal_set_reflectivity(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reflectivity_ = value;
}

// optional double echo_pulse_width = 11;
inline bool LidarDetection::has_echo_pulse_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void LidarDetection::clear_echo_pulse_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.echo_pulse_width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline double LidarDetection::echo_pulse_width() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.echo_pulse_width)
  return _internal_echo_pulse_width();
}
inline void LidarDetection::set_echo_pulse_width(double value) {
  _internal_set_echo_pulse_width(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.echo_pulse_width)
}
inline double LidarDetection::_internal_echo_pulse_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.echo_pulse_width_;
}
inline void LidarDetection::_internal_set_echo_pulse_width(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.echo_pulse_width_ = value;
}

// -------------------------------------------------------------------

// UltrasonicDetectionSpecificHeader

// optional double max_range = 1;
inline bool UltrasonicDetectionSpecificHeader::has_max_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UltrasonicDetectionSpecificHeader::clear_max_range() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_range_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double UltrasonicDetectionSpecificHeader::max_range() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionSpecificHeader.max_range)
  return _internal_max_range();
}
inline void UltrasonicDetectionSpecificHeader::set_max_range(double value) {
  _internal_set_max_range(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicDetectionSpecificHeader.max_range)
}
inline double UltrasonicDetectionSpecificHeader::_internal_max_range() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_range_;
}
inline void UltrasonicDetectionSpecificHeader::_internal_set_max_range(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_range_ = value;
}

// optional uint32 number_of_valid_indirect_detections = 2;
inline bool UltrasonicDetectionSpecificHeader::has_number_of_valid_indirect_detections() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UltrasonicDetectionSpecificHeader::clear_number_of_valid_indirect_detections() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_of_valid_indirect_detections_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t UltrasonicDetectionSpecificHeader::number_of_valid_indirect_detections() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionSpecificHeader.number_of_valid_indirect_detections)
  return _internal_number_of_valid_indirect_detections();
}
inline void UltrasonicDetectionSpecificHeader::set_number_of_valid_indirect_detections(::uint32_t value) {
  _internal_set_number_of_valid_indirect_detections(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicDetectionSpecificHeader.number_of_valid_indirect_detections)
}
inline ::uint32_t UltrasonicDetectionSpecificHeader::_internal_number_of_valid_indirect_detections() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.number_of_valid_indirect_detections_;
}
inline void UltrasonicDetectionSpecificHeader::_internal_set_number_of_valid_indirect_detections(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_of_valid_indirect_detections_ = value;
}

// -------------------------------------------------------------------

// UltrasonicDetectionData

// optional .osi3.SensorDetectionHeader header = 1;
inline bool UltrasonicDetectionData::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void UltrasonicDetectionData::clear_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::osi3::SensorDetectionHeader& UltrasonicDetectionData::_internal_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::SensorDetectionHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::SensorDetectionHeader&>(::osi3::_SensorDetectionHeader_default_instance_);
}
inline const ::osi3::SensorDetectionHeader& UltrasonicDetectionData::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionData.header)
  return _internal_header();
}
inline void UltrasonicDetectionData::unsafe_arena_set_allocated_header(::osi3::SensorDetectionHeader* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::osi3::SensorDetectionHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.UltrasonicDetectionData.header)
}
inline ::osi3::SensorDetectionHeader* UltrasonicDetectionData::release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::SensorDetectionHeader* released = _impl_.header_;
  _impl_.header_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::SensorDetectionHeader* UltrasonicDetectionData::unsafe_arena_release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.UltrasonicDetectionData.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::SensorDetectionHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::osi3::SensorDetectionHeader* UltrasonicDetectionData::_internal_mutable_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::SensorDetectionHeader>(GetArena());
    _impl_.header_ = reinterpret_cast<::osi3::SensorDetectionHeader*>(p);
  }
  return _impl_.header_;
}
inline ::osi3::SensorDetectionHeader* UltrasonicDetectionData::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::SensorDetectionHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicDetectionData.header)
  return _msg;
}
inline void UltrasonicDetectionData::set_allocated_header(::osi3::SensorDetectionHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::osi3::SensorDetectionHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicDetectionData.header)
}

// optional .osi3.UltrasonicDetectionSpecificHeader specific_header = 3;
inline bool UltrasonicDetectionData::has_specific_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.specific_header_ != nullptr);
  return value;
}
inline void UltrasonicDetectionData::clear_specific_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.specific_header_ != nullptr) _impl_.specific_header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::osi3::UltrasonicDetectionSpecificHeader& UltrasonicDetectionData::_internal_specific_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::UltrasonicDetectionSpecificHeader* p = _impl_.specific_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::UltrasonicDetectionSpecificHeader&>(::osi3::_UltrasonicDetectionSpecificHeader_default_instance_);
}
inline const ::osi3::UltrasonicDetectionSpecificHeader& UltrasonicDetectionData::specific_header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionData.specific_header)
  return _internal_specific_header();
}
inline void UltrasonicDetectionData::unsafe_arena_set_allocated_specific_header(::osi3::UltrasonicDetectionSpecificHeader* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.specific_header_);
  }
  _impl_.specific_header_ = reinterpret_cast<::osi3::UltrasonicDetectionSpecificHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.UltrasonicDetectionData.specific_header)
}
inline ::osi3::UltrasonicDetectionSpecificHeader* UltrasonicDetectionData::release_specific_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::UltrasonicDetectionSpecificHeader* released = _impl_.specific_header_;
  _impl_.specific_header_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::UltrasonicDetectionSpecificHeader* UltrasonicDetectionData::unsafe_arena_release_specific_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.UltrasonicDetectionData.specific_header)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::UltrasonicDetectionSpecificHeader* temp = _impl_.specific_header_;
  _impl_.specific_header_ = nullptr;
  return temp;
}
inline ::osi3::UltrasonicDetectionSpecificHeader* UltrasonicDetectionData::_internal_mutable_specific_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.specific_header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::UltrasonicDetectionSpecificHeader>(GetArena());
    _impl_.specific_header_ = reinterpret_cast<::osi3::UltrasonicDetectionSpecificHeader*>(p);
  }
  return _impl_.specific_header_;
}
inline ::osi3::UltrasonicDetectionSpecificHeader* UltrasonicDetectionData::mutable_specific_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::osi3::UltrasonicDetectionSpecificHeader* _msg = _internal_mutable_specific_header();
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicDetectionData.specific_header)
  return _msg;
}
inline void UltrasonicDetectionData::set_allocated_specific_header(::osi3::UltrasonicDetectionSpecificHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.specific_header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.specific_header_ = reinterpret_cast<::osi3::UltrasonicDetectionSpecificHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicDetectionData.specific_header)
}

// repeated .osi3.UltrasonicDetection detection = 2;
inline int UltrasonicDetectionData::_internal_detection_size() const {
  return _internal_detection().size();
}
inline int UltrasonicDetectionData::detection_size() const {
  return _internal_detection_size();
}
inline void UltrasonicDetectionData::clear_detection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.detection_.Clear();
}
inline ::osi3::UltrasonicDetection* UltrasonicDetectionData::mutable_detection(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicDetectionData.detection)
  return _internal_mutable_detection()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicDetection>* UltrasonicDetectionData::mutable_detection()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.UltrasonicDetectionData.detection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_detection();
}
inline const ::osi3::UltrasonicDetection& UltrasonicDetectionData::detection(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionData.detection)
  return _internal_detection().Get(index);
}
inline ::osi3::UltrasonicDetection* UltrasonicDetectionData::add_detection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::UltrasonicDetection* _add = _internal_mutable_detection()->Add();
  // @@protoc_insertion_point(field_add:osi3.UltrasonicDetectionData.detection)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicDetection>& UltrasonicDetectionData::detection() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.UltrasonicDetectionData.detection)
  return _internal_detection();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicDetection>&
UltrasonicDetectionData::_internal_detection() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.detection_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicDetection>*
UltrasonicDetectionData::_internal_mutable_detection() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.detection_;
}

// repeated .osi3.UltrasonicIndirectDetection indirect_detection = 4;
inline int UltrasonicDetectionData::_internal_indirect_detection_size() const {
  return _internal_indirect_detection().size();
}
inline int UltrasonicDetectionData::indirect_detection_size() const {
  return _internal_indirect_detection_size();
}
inline void UltrasonicDetectionData::clear_indirect_detection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.indirect_detection_.Clear();
}
inline ::osi3::UltrasonicIndirectDetection* UltrasonicDetectionData::mutable_indirect_detection(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicDetectionData.indirect_detection)
  return _internal_mutable_indirect_detection()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicIndirectDetection>* UltrasonicDetectionData::mutable_indirect_detection()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.UltrasonicDetectionData.indirect_detection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_indirect_detection();
}
inline const ::osi3::UltrasonicIndirectDetection& UltrasonicDetectionData::indirect_detection(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionData.indirect_detection)
  return _internal_indirect_detection().Get(index);
}
inline ::osi3::UltrasonicIndirectDetection* UltrasonicDetectionData::add_indirect_detection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::UltrasonicIndirectDetection* _add = _internal_mutable_indirect_detection()->Add();
  // @@protoc_insertion_point(field_add:osi3.UltrasonicDetectionData.indirect_detection)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicIndirectDetection>& UltrasonicDetectionData::indirect_detection() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.UltrasonicDetectionData.indirect_detection)
  return _internal_indirect_detection();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicIndirectDetection>&
UltrasonicDetectionData::_internal_indirect_detection() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.indirect_detection_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::UltrasonicIndirectDetection>*
UltrasonicDetectionData::_internal_mutable_indirect_detection() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.indirect_detection_;
}

// -------------------------------------------------------------------

// UltrasonicDetection

// optional double existence_probability = 1;
inline bool UltrasonicDetection::has_existence_probability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UltrasonicDetection::clear_existence_probability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.existence_probability_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double UltrasonicDetection::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetection.existence_probability)
  return _internal_existence_probability();
}
inline void UltrasonicDetection::set_existence_probability(double value) {
  _internal_set_existence_probability(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicDetection.existence_probability)
}
inline double UltrasonicDetection::_internal_existence_probability() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.existence_probability_;
}
inline void UltrasonicDetection::_internal_set_existence_probability(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.existence_probability_ = value;
}

// optional .osi3.Identifier object_id = 2;
inline bool UltrasonicDetection::has_object_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_id_ != nullptr);
  return value;
}
inline const ::osi3::Identifier& UltrasonicDetection::_internal_object_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Identifier* p = _impl_.object_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Identifier&>(::osi3::_Identifier_default_instance_);
}
inline const ::osi3::Identifier& UltrasonicDetection::object_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetection.object_id)
  return _internal_object_id();
}
inline void UltrasonicDetection::unsafe_arena_set_allocated_object_id(::osi3::Identifier* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_id_);
  }
  _impl_.object_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.UltrasonicDetection.object_id)
}
inline ::osi3::Identifier* UltrasonicDetection::release_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Identifier* released = _impl_.object_id_;
  _impl_.object_id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Identifier* UltrasonicDetection::unsafe_arena_release_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.UltrasonicDetection.object_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Identifier* temp = _impl_.object_id_;
  _impl_.object_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* UltrasonicDetection::_internal_mutable_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.object_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Identifier>(GetArena());
    _impl_.object_id_ = reinterpret_cast<::osi3::Identifier*>(p);
  }
  return _impl_.object_id_;
}
inline ::osi3::Identifier* UltrasonicDetection::mutable_object_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::Identifier* _msg = _internal_mutable_object_id();
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicDetection.object_id)
  return _msg;
}
inline void UltrasonicDetection::set_allocated_object_id(::osi3::Identifier* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.object_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicDetection.object_id)
}

// optional double distance = 3;
inline bool UltrasonicDetection::has_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UltrasonicDetection::clear_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double UltrasonicDetection::distance() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetection.distance)
  return _internal_distance();
}
inline void UltrasonicDetection::set_distance(double value) {
  _internal_set_distance(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicDetection.distance)
}
inline double UltrasonicDetection::_internal_distance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.distance_;
}
inline void UltrasonicDetection::_internal_set_distance(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_ = value;
}

// -------------------------------------------------------------------

// UltrasonicIndirectDetection

// optional double existence_probability = 1;
inline bool UltrasonicIndirectDetection::has_existence_probability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UltrasonicIndirectDetection::clear_existence_probability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.existence_probability_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double UltrasonicIndirectDetection::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.existence_probability)
  return _internal_existence_probability();
}
inline void UltrasonicIndirectDetection::set_existence_probability(double value) {
  _internal_set_existence_probability(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicIndirectDetection.existence_probability)
}
inline double UltrasonicIndirectDetection::_internal_existence_probability() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.existence_probability_;
}
inline void UltrasonicIndirectDetection::_internal_set_existence_probability(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.existence_probability_ = value;
}

// optional .osi3.Identifier object_id = 2;
inline bool UltrasonicIndirectDetection::has_object_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_id_ != nullptr);
  return value;
}
inline const ::osi3::Identifier& UltrasonicIndirectDetection::_internal_object_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Identifier* p = _impl_.object_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Identifier&>(::osi3::_Identifier_default_instance_);
}
inline const ::osi3::Identifier& UltrasonicIndirectDetection::object_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.object_id)
  return _internal_object_id();
}
inline void UltrasonicIndirectDetection::unsafe_arena_set_allocated_object_id(::osi3::Identifier* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_id_);
  }
  _impl_.object_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.UltrasonicIndirectDetection.object_id)
}
inline ::osi3::Identifier* UltrasonicIndirectDetection::release_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Identifier* released = _impl_.object_id_;
  _impl_.object_id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Identifier* UltrasonicIndirectDetection::unsafe_arena_release_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.UltrasonicIndirectDetection.object_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Identifier* temp = _impl_.object_id_;
  _impl_.object_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* UltrasonicIndirectDetection::_internal_mutable_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.object_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Identifier>(GetArena());
    _impl_.object_id_ = reinterpret_cast<::osi3::Identifier*>(p);
  }
  return _impl_.object_id_;
}
inline ::osi3::Identifier* UltrasonicIndirectDetection::mutable_object_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::Identifier* _msg = _internal_mutable_object_id();
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicIndirectDetection.object_id)
  return _msg;
}
inline void UltrasonicIndirectDetection::set_allocated_object_id(::osi3::Identifier* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.object_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicIndirectDetection.object_id)
}

// optional double ellipsoid_radial = 3;
inline bool UltrasonicIndirectDetection::has_ellipsoid_radial() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void UltrasonicIndirectDetection::clear_ellipsoid_radial() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ellipsoid_radial_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double UltrasonicIndirectDetection::ellipsoid_radial() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.ellipsoid_radial)
  return _internal_ellipsoid_radial();
}
inline void UltrasonicIndirectDetection::set_ellipsoid_radial(double value) {
  _internal_set_ellipsoid_radial(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicIndirectDetection.ellipsoid_radial)
}
inline double UltrasonicIndirectDetection::_internal_ellipsoid_radial() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ellipsoid_radial_;
}
inline void UltrasonicIndirectDetection::_internal_set_ellipsoid_radial(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ellipsoid_radial_ = value;
}

// optional double ellipsoid_axial = 4;
inline bool UltrasonicIndirectDetection::has_ellipsoid_axial() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void UltrasonicIndirectDetection::clear_ellipsoid_axial() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ellipsoid_axial_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double UltrasonicIndirectDetection::ellipsoid_axial() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.ellipsoid_axial)
  return _internal_ellipsoid_axial();
}
inline void UltrasonicIndirectDetection::set_ellipsoid_axial(double value) {
  _internal_set_ellipsoid_axial(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicIndirectDetection.ellipsoid_axial)
}
inline double UltrasonicIndirectDetection::_internal_ellipsoid_axial() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ellipsoid_axial_;
}
inline void UltrasonicIndirectDetection::_internal_set_ellipsoid_axial(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ellipsoid_axial_ = value;
}

// optional .osi3.Identifier receiver_id = 5;
inline bool UltrasonicIndirectDetection::has_receiver_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.receiver_id_ != nullptr);
  return value;
}
inline const ::osi3::Identifier& UltrasonicIndirectDetection::_internal_receiver_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Identifier* p = _impl_.receiver_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Identifier&>(::osi3::_Identifier_default_instance_);
}
inline const ::osi3::Identifier& UltrasonicIndirectDetection::receiver_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.receiver_id)
  return _internal_receiver_id();
}
inline void UltrasonicIndirectDetection::unsafe_arena_set_allocated_receiver_id(::osi3::Identifier* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.receiver_id_);
  }
  _impl_.receiver_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.UltrasonicIndirectDetection.receiver_id)
}
inline ::osi3::Identifier* UltrasonicIndirectDetection::release_receiver_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Identifier* released = _impl_.receiver_id_;
  _impl_.receiver_id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Identifier* UltrasonicIndirectDetection::unsafe_arena_release_receiver_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.UltrasonicIndirectDetection.receiver_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Identifier* temp = _impl_.receiver_id_;
  _impl_.receiver_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* UltrasonicIndirectDetection::_internal_mutable_receiver_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.receiver_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Identifier>(GetArena());
    _impl_.receiver_id_ = reinterpret_cast<::osi3::Identifier*>(p);
  }
  return _impl_.receiver_id_;
}
inline ::osi3::Identifier* UltrasonicIndirectDetection::mutable_receiver_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::osi3::Identifier* _msg = _internal_mutable_receiver_id();
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicIndirectDetection.receiver_id)
  return _msg;
}
inline void UltrasonicIndirectDetection::set_allocated_receiver_id(::osi3::Identifier* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.receiver_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.receiver_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicIndirectDetection.receiver_id)
}

// optional .osi3.Vector3d receiver_origin = 6;
inline bool UltrasonicIndirectDetection::has_receiver_origin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.receiver_origin_ != nullptr);
  return value;
}
inline const ::osi3::Vector3d& UltrasonicIndirectDetection::_internal_receiver_origin() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Vector3d* p = _impl_.receiver_origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Vector3d&>(::osi3::_Vector3d_default_instance_);
}
inline const ::osi3::Vector3d& UltrasonicIndirectDetection::receiver_origin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.receiver_origin)
  return _internal_receiver_origin();
}
inline void UltrasonicIndirectDetection::unsafe_arena_set_allocated_receiver_origin(::osi3::Vector3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.receiver_origin_);
  }
  _impl_.receiver_origin_ = reinterpret_cast<::osi3::Vector3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.UltrasonicIndirectDetection.receiver_origin)
}
inline ::osi3::Vector3d* UltrasonicIndirectDetection::release_receiver_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::Vector3d* released = _impl_.receiver_origin_;
  _impl_.receiver_origin_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Vector3d* UltrasonicIndirectDetection::unsafe_arena_release_receiver_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.UltrasonicIndirectDetection.receiver_origin)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::Vector3d* temp = _impl_.receiver_origin_;
  _impl_.receiver_origin_ = nullptr;
  return temp;
}
inline ::osi3::Vector3d* UltrasonicIndirectDetection::_internal_mutable_receiver_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.receiver_origin_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Vector3d>(GetArena());
    _impl_.receiver_origin_ = reinterpret_cast<::osi3::Vector3d*>(p);
  }
  return _impl_.receiver_origin_;
}
inline ::osi3::Vector3d* UltrasonicIndirectDetection::mutable_receiver_origin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::osi3::Vector3d* _msg = _internal_mutable_receiver_origin();
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicIndirectDetection.receiver_origin)
  return _msg;
}
inline void UltrasonicIndirectDetection::set_allocated_receiver_origin(::osi3::Vector3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.receiver_origin_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.receiver_origin_ = reinterpret_cast<::osi3::Vector3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicIndirectDetection.receiver_origin)
}

// -------------------------------------------------------------------

// CameraDetectionSpecificHeader

// optional uint32 number_of_valid_points = 1;
inline bool CameraDetectionSpecificHeader::has_number_of_valid_points() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CameraDetectionSpecificHeader::clear_number_of_valid_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_of_valid_points_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t CameraDetectionSpecificHeader::number_of_valid_points() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetectionSpecificHeader.number_of_valid_points)
  return _internal_number_of_valid_points();
}
inline void CameraDetectionSpecificHeader::set_number_of_valid_points(::uint32_t value) {
  _internal_set_number_of_valid_points(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetectionSpecificHeader.number_of_valid_points)
}
inline ::uint32_t CameraDetectionSpecificHeader::_internal_number_of_valid_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.number_of_valid_points_;
}
inline void CameraDetectionSpecificHeader::_internal_set_number_of_valid_points(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_of_valid_points_ = value;
}

// -------------------------------------------------------------------

// CameraDetectionData

// optional .osi3.SensorDetectionHeader header = 1;
inline bool CameraDetectionData::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void CameraDetectionData::clear_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::osi3::SensorDetectionHeader& CameraDetectionData::_internal_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::SensorDetectionHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::SensorDetectionHeader&>(::osi3::_SensorDetectionHeader_default_instance_);
}
inline const ::osi3::SensorDetectionHeader& CameraDetectionData::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.CameraDetectionData.header)
  return _internal_header();
}
inline void CameraDetectionData::unsafe_arena_set_allocated_header(::osi3::SensorDetectionHeader* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::osi3::SensorDetectionHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.CameraDetectionData.header)
}
inline ::osi3::SensorDetectionHeader* CameraDetectionData::release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::SensorDetectionHeader* released = _impl_.header_;
  _impl_.header_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::SensorDetectionHeader* CameraDetectionData::unsafe_arena_release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.CameraDetectionData.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::SensorDetectionHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::osi3::SensorDetectionHeader* CameraDetectionData::_internal_mutable_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::SensorDetectionHeader>(GetArena());
    _impl_.header_ = reinterpret_cast<::osi3::SensorDetectionHeader*>(p);
  }
  return _impl_.header_;
}
inline ::osi3::SensorDetectionHeader* CameraDetectionData::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::SensorDetectionHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetectionData.header)
  return _msg;
}
inline void CameraDetectionData::set_allocated_header(::osi3::SensorDetectionHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::osi3::SensorDetectionHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraDetectionData.header)
}

// optional .osi3.CameraDetectionSpecificHeader specific_header = 3;
inline bool CameraDetectionData::has_specific_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.specific_header_ != nullptr);
  return value;
}
inline void CameraDetectionData::clear_specific_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.specific_header_ != nullptr) _impl_.specific_header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::osi3::CameraDetectionSpecificHeader& CameraDetectionData::_internal_specific_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::CameraDetectionSpecificHeader* p = _impl_.specific_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::CameraDetectionSpecificHeader&>(::osi3::_CameraDetectionSpecificHeader_default_instance_);
}
inline const ::osi3::CameraDetectionSpecificHeader& CameraDetectionData::specific_header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.CameraDetectionData.specific_header)
  return _internal_specific_header();
}
inline void CameraDetectionData::unsafe_arena_set_allocated_specific_header(::osi3::CameraDetectionSpecificHeader* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.specific_header_);
  }
  _impl_.specific_header_ = reinterpret_cast<::osi3::CameraDetectionSpecificHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.CameraDetectionData.specific_header)
}
inline ::osi3::CameraDetectionSpecificHeader* CameraDetectionData::release_specific_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::CameraDetectionSpecificHeader* released = _impl_.specific_header_;
  _impl_.specific_header_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::CameraDetectionSpecificHeader* CameraDetectionData::unsafe_arena_release_specific_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.CameraDetectionData.specific_header)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::CameraDetectionSpecificHeader* temp = _impl_.specific_header_;
  _impl_.specific_header_ = nullptr;
  return temp;
}
inline ::osi3::CameraDetectionSpecificHeader* CameraDetectionData::_internal_mutable_specific_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.specific_header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::CameraDetectionSpecificHeader>(GetArena());
    _impl_.specific_header_ = reinterpret_cast<::osi3::CameraDetectionSpecificHeader*>(p);
  }
  return _impl_.specific_header_;
}
inline ::osi3::CameraDetectionSpecificHeader* CameraDetectionData::mutable_specific_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::osi3::CameraDetectionSpecificHeader* _msg = _internal_mutable_specific_header();
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetectionData.specific_header)
  return _msg;
}
inline void CameraDetectionData::set_allocated_specific_header(::osi3::CameraDetectionSpecificHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.specific_header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.specific_header_ = reinterpret_cast<::osi3::CameraDetectionSpecificHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraDetectionData.specific_header)
}

// repeated .osi3.CameraDetection detection = 2;
inline int CameraDetectionData::_internal_detection_size() const {
  return _internal_detection().size();
}
inline int CameraDetectionData::detection_size() const {
  return _internal_detection_size();
}
inline void CameraDetectionData::clear_detection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.detection_.Clear();
}
inline ::osi3::CameraDetection* CameraDetectionData::mutable_detection(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetectionData.detection)
  return _internal_mutable_detection()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::CameraDetection>* CameraDetectionData::mutable_detection()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.CameraDetectionData.detection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_detection();
}
inline const ::osi3::CameraDetection& CameraDetectionData::detection(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.CameraDetectionData.detection)
  return _internal_detection().Get(index);
}
inline ::osi3::CameraDetection* CameraDetectionData::add_detection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::CameraDetection* _add = _internal_mutable_detection()->Add();
  // @@protoc_insertion_point(field_add:osi3.CameraDetectionData.detection)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::CameraDetection>& CameraDetectionData::detection() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.CameraDetectionData.detection)
  return _internal_detection();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::CameraDetection>&
CameraDetectionData::_internal_detection() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.detection_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::CameraDetection>*
CameraDetectionData::_internal_mutable_detection() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.detection_;
}

// repeated .osi3.CameraPoint point = 4;
inline int CameraDetectionData::_internal_point_size() const {
  return _internal_point().size();
}
inline int CameraDetectionData::point_size() const {
  return _internal_point_size();
}
inline void CameraDetectionData::clear_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.point_.Clear();
}
inline ::osi3::CameraPoint* CameraDetectionData::mutable_point(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetectionData.point)
  return _internal_mutable_point()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::CameraPoint>* CameraDetectionData::mutable_point()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.CameraDetectionData.point)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_point();
}
inline const ::osi3::CameraPoint& CameraDetectionData::point(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.CameraDetectionData.point)
  return _internal_point().Get(index);
}
inline ::osi3::CameraPoint* CameraDetectionData::add_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::CameraPoint* _add = _internal_mutable_point()->Add();
  // @@protoc_insertion_point(field_add:osi3.CameraDetectionData.point)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::CameraPoint>& CameraDetectionData::point() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.CameraDetectionData.point)
  return _internal_point();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::CameraPoint>&
CameraDetectionData::_internal_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.point_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::CameraPoint>*
CameraDetectionData::_internal_mutable_point() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.point_;
}

// -------------------------------------------------------------------

// CameraDetection

// optional double existence_probability = 1;
inline bool CameraDetection::has_existence_probability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CameraDetection::clear_existence_probability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.existence_probability_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double CameraDetection::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.existence_probability)
  return _internal_existence_probability();
}
inline void CameraDetection::set_existence_probability(double value) {
  _internal_set_existence_probability(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.existence_probability)
}
inline double CameraDetection::_internal_existence_probability() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.existence_probability_;
}
inline void CameraDetection::_internal_set_existence_probability(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.existence_probability_ = value;
}

// optional .osi3.Identifier object_id = 2;
inline bool CameraDetection::has_object_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_id_ != nullptr);
  return value;
}
inline const ::osi3::Identifier& CameraDetection::_internal_object_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Identifier* p = _impl_.object_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Identifier&>(::osi3::_Identifier_default_instance_);
}
inline const ::osi3::Identifier& CameraDetection::object_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.object_id)
  return _internal_object_id();
}
inline void CameraDetection::unsafe_arena_set_allocated_object_id(::osi3::Identifier* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_id_);
  }
  _impl_.object_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.CameraDetection.object_id)
}
inline ::osi3::Identifier* CameraDetection::release_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Identifier* released = _impl_.object_id_;
  _impl_.object_id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Identifier* CameraDetection::unsafe_arena_release_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.CameraDetection.object_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Identifier* temp = _impl_.object_id_;
  _impl_.object_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* CameraDetection::_internal_mutable_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.object_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Identifier>(GetArena());
    _impl_.object_id_ = reinterpret_cast<::osi3::Identifier*>(p);
  }
  return _impl_.object_id_;
}
inline ::osi3::Identifier* CameraDetection::mutable_object_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::Identifier* _msg = _internal_mutable_object_id();
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetection.object_id)
  return _msg;
}
inline void CameraDetection::set_allocated_object_id(::osi3::Identifier* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.object_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraDetection.object_id)
}

// optional .osi3.Timestamp time_difference = 3;
inline bool CameraDetection::has_time_difference() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_difference_ != nullptr);
  return value;
}
inline const ::osi3::Timestamp& CameraDetection::_internal_time_difference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Timestamp* p = _impl_.time_difference_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Timestamp&>(::osi3::_Timestamp_default_instance_);
}
inline const ::osi3::Timestamp& CameraDetection::time_difference() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.time_difference)
  return _internal_time_difference();
}
inline void CameraDetection::unsafe_arena_set_allocated_time_difference(::osi3::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_difference_);
  }
  _impl_.time_difference_ = reinterpret_cast<::osi3::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.CameraDetection.time_difference)
}
inline ::osi3::Timestamp* CameraDetection::release_time_difference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Timestamp* released = _impl_.time_difference_;
  _impl_.time_difference_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Timestamp* CameraDetection::unsafe_arena_release_time_difference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.CameraDetection.time_difference)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Timestamp* temp = _impl_.time_difference_;
  _impl_.time_difference_ = nullptr;
  return temp;
}
inline ::osi3::Timestamp* CameraDetection::_internal_mutable_time_difference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.time_difference_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Timestamp>(GetArena());
    _impl_.time_difference_ = reinterpret_cast<::osi3::Timestamp*>(p);
  }
  return _impl_.time_difference_;
}
inline ::osi3::Timestamp* CameraDetection::mutable_time_difference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::osi3::Timestamp* _msg = _internal_mutable_time_difference();
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetection.time_difference)
  return _msg;
}
inline void CameraDetection::set_allocated_time_difference(::osi3::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_difference_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.time_difference_ = reinterpret_cast<::osi3::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraDetection.time_difference)
}

// optional .osi3.CameraDetection.ImageShapeType image_shape_type = 4;
inline bool CameraDetection::has_image_shape_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CameraDetection::clear_image_shape_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.image_shape_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::osi3::CameraDetection_ImageShapeType CameraDetection::image_shape_type() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.image_shape_type)
  return _internal_image_shape_type();
}
inline void CameraDetection::set_image_shape_type(::osi3::CameraDetection_ImageShapeType value) {
  _internal_set_image_shape_type(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.image_shape_type)
}
inline ::osi3::CameraDetection_ImageShapeType CameraDetection::_internal_image_shape_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::osi3::CameraDetection_ImageShapeType>(_impl_.image_shape_type_);
}
inline void CameraDetection::_internal_set_image_shape_type(::osi3::CameraDetection_ImageShapeType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::osi3::CameraDetection_ImageShapeType_IsValid(value));
  _impl_.image_shape_type_ = value;
}

// optional bool shape_classification_background = 5;
inline bool CameraDetection::has_shape_classification_background() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_background() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_background_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool CameraDetection::shape_classification_background() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_background)
  return _internal_shape_classification_background();
}
inline void CameraDetection::set_shape_classification_background(bool value) {
  _internal_set_shape_classification_background(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_background)
}
inline bool CameraDetection::_internal_shape_classification_background() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_background_;
}
inline void CameraDetection::_internal_set_shape_classification_background(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_background_ = value;
}

// optional bool shape_classification_foreground = 6;
inline bool CameraDetection::has_shape_classification_foreground() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_foreground() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_foreground_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool CameraDetection::shape_classification_foreground() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_foreground)
  return _internal_shape_classification_foreground();
}
inline void CameraDetection::set_shape_classification_foreground(bool value) {
  _internal_set_shape_classification_foreground(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_foreground)
}
inline bool CameraDetection::_internal_shape_classification_foreground() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_foreground_;
}
inline void CameraDetection::_internal_set_shape_classification_foreground(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_foreground_ = value;
}

// optional bool shape_classification_flat = 7;
inline bool CameraDetection::has_shape_classification_flat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_flat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_flat_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool CameraDetection::shape_classification_flat() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_flat)
  return _internal_shape_classification_flat();
}
inline void CameraDetection::set_shape_classification_flat(bool value) {
  _internal_set_shape_classification_flat(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_flat)
}
inline bool CameraDetection::_internal_shape_classification_flat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_flat_;
}
inline void CameraDetection::_internal_set_shape_classification_flat(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_flat_ = value;
}

// optional bool shape_classification_upright = 8;
inline bool CameraDetection::has_shape_classification_upright() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_upright() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_upright_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool CameraDetection::shape_classification_upright() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_upright)
  return _internal_shape_classification_upright();
}
inline void CameraDetection::set_shape_classification_upright(bool value) {
  _internal_set_shape_classification_upright(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_upright)
}
inline bool CameraDetection::_internal_shape_classification_upright() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_upright_;
}
inline void CameraDetection::_internal_set_shape_classification_upright(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_upright_ = value;
}

// optional bool shape_classification_ground = 9;
inline bool CameraDetection::has_shape_classification_ground() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_ground() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_ground_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool CameraDetection::shape_classification_ground() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_ground)
  return _internal_shape_classification_ground();
}
inline void CameraDetection::set_shape_classification_ground(bool value) {
  _internal_set_shape_classification_ground(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_ground)
}
inline bool CameraDetection::_internal_shape_classification_ground() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_ground_;
}
inline void CameraDetection::_internal_set_shape_classification_ground(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_ground_ = value;
}

// optional bool shape_classification_sky = 10;
inline bool CameraDetection::has_shape_classification_sky() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_sky() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_sky_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool CameraDetection::shape_classification_sky() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_sky)
  return _internal_shape_classification_sky();
}
inline void CameraDetection::set_shape_classification_sky(bool value) {
  _internal_set_shape_classification_sky(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_sky)
}
inline bool CameraDetection::_internal_shape_classification_sky() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_sky_;
}
inline void CameraDetection::_internal_set_shape_classification_sky(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_sky_ = value;
}

// optional bool shape_classification_vegetation = 11;
inline bool CameraDetection::has_shape_classification_vegetation() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_vegetation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_vegetation_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool CameraDetection::shape_classification_vegetation() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_vegetation)
  return _internal_shape_classification_vegetation();
}
inline void CameraDetection::set_shape_classification_vegetation(bool value) {
  _internal_set_shape_classification_vegetation(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_vegetation)
}
inline bool CameraDetection::_internal_shape_classification_vegetation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_vegetation_;
}
inline void CameraDetection::_internal_set_shape_classification_vegetation(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_vegetation_ = value;
}

// optional bool shape_classification_road = 12;
inline bool CameraDetection::has_shape_classification_road() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_road() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_road_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool CameraDetection::shape_classification_road() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_road)
  return _internal_shape_classification_road();
}
inline void CameraDetection::set_shape_classification_road(bool value) {
  _internal_set_shape_classification_road(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_road)
}
inline bool CameraDetection::_internal_shape_classification_road() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_road_;
}
inline void CameraDetection::_internal_set_shape_classification_road(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_road_ = value;
}

// optional bool shape_classification_non_driving_lane = 13;
inline bool CameraDetection::has_shape_classification_non_driving_lane() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_non_driving_lane() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_non_driving_lane_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool CameraDetection::shape_classification_non_driving_lane() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_non_driving_lane)
  return _internal_shape_classification_non_driving_lane();
}
inline void CameraDetection::set_shape_classification_non_driving_lane(bool value) {
  _internal_set_shape_classification_non_driving_lane(value);
  _impl_._has_bits_[0] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_non_driving_lane)
}
inline bool CameraDetection::_internal_shape_classification_non_driving_lane() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_non_driving_lane_;
}
inline void CameraDetection::_internal_set_shape_classification_non_driving_lane(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_non_driving_lane_ = value;
}

// optional bool shape_classification_non_road = 14;
inline bool CameraDetection::has_shape_classification_non_road() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_non_road() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_non_road_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool CameraDetection::shape_classification_non_road() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_non_road)
  return _internal_shape_classification_non_road();
}
inline void CameraDetection::set_shape_classification_non_road(bool value) {
  _internal_set_shape_classification_non_road(value);
  _impl_._has_bits_[0] |= 0x00008000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_non_road)
}
inline bool CameraDetection::_internal_shape_classification_non_road() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_non_road_;
}
inline void CameraDetection::_internal_set_shape_classification_non_road(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_non_road_ = value;
}

// optional bool shape_classification_stationary_object = 15;
inline bool CameraDetection::has_shape_classification_stationary_object() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_stationary_object() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_stationary_object_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool CameraDetection::shape_classification_stationary_object() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_stationary_object)
  return _internal_shape_classification_stationary_object();
}
inline void CameraDetection::set_shape_classification_stationary_object(bool value) {
  _internal_set_shape_classification_stationary_object(value);
  _impl_._has_bits_[0] |= 0x00010000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_stationary_object)
}
inline bool CameraDetection::_internal_shape_classification_stationary_object() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_stationary_object_;
}
inline void CameraDetection::_internal_set_shape_classification_stationary_object(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_stationary_object_ = value;
}

// optional bool shape_classification_moving_object = 16;
inline bool CameraDetection::has_shape_classification_moving_object() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_moving_object() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_moving_object_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool CameraDetection::shape_classification_moving_object() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_moving_object)
  return _internal_shape_classification_moving_object();
}
inline void CameraDetection::set_shape_classification_moving_object(bool value) {
  _internal_set_shape_classification_moving_object(value);
  _impl_._has_bits_[0] |= 0x00020000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_moving_object)
}
inline bool CameraDetection::_internal_shape_classification_moving_object() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_moving_object_;
}
inline void CameraDetection::_internal_set_shape_classification_moving_object(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_moving_object_ = value;
}

// optional bool shape_classification_landmark = 17;
inline bool CameraDetection::has_shape_classification_landmark() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_landmark() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_landmark_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool CameraDetection::shape_classification_landmark() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_landmark)
  return _internal_shape_classification_landmark();
}
inline void CameraDetection::set_shape_classification_landmark(bool value) {
  _internal_set_shape_classification_landmark(value);
  _impl_._has_bits_[0] |= 0x00040000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_landmark)
}
inline bool CameraDetection::_internal_shape_classification_landmark() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_landmark_;
}
inline void CameraDetection::_internal_set_shape_classification_landmark(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_landmark_ = value;
}

// optional bool shape_classification_traffic_sign = 18;
inline bool CameraDetection::has_shape_classification_traffic_sign() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_traffic_sign() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_traffic_sign_ = false;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline bool CameraDetection::shape_classification_traffic_sign() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_traffic_sign)
  return _internal_shape_classification_traffic_sign();
}
inline void CameraDetection::set_shape_classification_traffic_sign(bool value) {
  _internal_set_shape_classification_traffic_sign(value);
  _impl_._has_bits_[0] |= 0x00080000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_traffic_sign)
}
inline bool CameraDetection::_internal_shape_classification_traffic_sign() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_traffic_sign_;
}
inline void CameraDetection::_internal_set_shape_classification_traffic_sign(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_traffic_sign_ = value;
}

// optional bool shape_classification_traffic_light = 19;
inline bool CameraDetection::has_shape_classification_traffic_light() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_traffic_light() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_traffic_light_ = false;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline bool CameraDetection::shape_classification_traffic_light() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_traffic_light)
  return _internal_shape_classification_traffic_light();
}
inline void CameraDetection::set_shape_classification_traffic_light(bool value) {
  _internal_set_shape_classification_traffic_light(value);
  _impl_._has_bits_[0] |= 0x00100000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_traffic_light)
}
inline bool CameraDetection::_internal_shape_classification_traffic_light() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_traffic_light_;
}
inline void CameraDetection::_internal_set_shape_classification_traffic_light(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_traffic_light_ = value;
}

// optional bool shape_classification_road_marking = 20;
inline bool CameraDetection::has_shape_classification_road_marking() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_road_marking() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_road_marking_ = false;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline bool CameraDetection::shape_classification_road_marking() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_road_marking)
  return _internal_shape_classification_road_marking();
}
inline void CameraDetection::set_shape_classification_road_marking(bool value) {
  _internal_set_shape_classification_road_marking(value);
  _impl_._has_bits_[0] |= 0x00200000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_road_marking)
}
inline bool CameraDetection::_internal_shape_classification_road_marking() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_road_marking_;
}
inline void CameraDetection::_internal_set_shape_classification_road_marking(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_road_marking_ = value;
}

// optional bool shape_classification_vehicle = 21;
inline bool CameraDetection::has_shape_classification_vehicle() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_vehicle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_vehicle_ = false;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline bool CameraDetection::shape_classification_vehicle() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_vehicle)
  return _internal_shape_classification_vehicle();
}
inline void CameraDetection::set_shape_classification_vehicle(bool value) {
  _internal_set_shape_classification_vehicle(value);
  _impl_._has_bits_[0] |= 0x00400000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_vehicle)
}
inline bool CameraDetection::_internal_shape_classification_vehicle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_vehicle_;
}
inline void CameraDetection::_internal_set_shape_classification_vehicle(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_vehicle_ = value;
}

// optional bool shape_classification_pedestrian = 22;
inline bool CameraDetection::has_shape_classification_pedestrian() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_pedestrian() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_pedestrian_ = false;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline bool CameraDetection::shape_classification_pedestrian() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_pedestrian)
  return _internal_shape_classification_pedestrian();
}
inline void CameraDetection::set_shape_classification_pedestrian(bool value) {
  _internal_set_shape_classification_pedestrian(value);
  _impl_._has_bits_[0] |= 0x00800000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_pedestrian)
}
inline bool CameraDetection::_internal_shape_classification_pedestrian() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_pedestrian_;
}
inline void CameraDetection::_internal_set_shape_classification_pedestrian(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_pedestrian_ = value;
}

// optional bool shape_classification_animal = 23;
inline bool CameraDetection::has_shape_classification_animal() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_animal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_animal_ = false;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline bool CameraDetection::shape_classification_animal() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_animal)
  return _internal_shape_classification_animal();
}
inline void CameraDetection::set_shape_classification_animal(bool value) {
  _internal_set_shape_classification_animal(value);
  _impl_._has_bits_[0] |= 0x01000000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_animal)
}
inline bool CameraDetection::_internal_shape_classification_animal() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_animal_;
}
inline void CameraDetection::_internal_set_shape_classification_animal(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_animal_ = value;
}

// optional bool shape_classification_pedestrian_front = 24;
inline bool CameraDetection::has_shape_classification_pedestrian_front() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_pedestrian_front() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_pedestrian_front_ = false;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline bool CameraDetection::shape_classification_pedestrian_front() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_pedestrian_front)
  return _internal_shape_classification_pedestrian_front();
}
inline void CameraDetection::set_shape_classification_pedestrian_front(bool value) {
  _internal_set_shape_classification_pedestrian_front(value);
  _impl_._has_bits_[0] |= 0x02000000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_pedestrian_front)
}
inline bool CameraDetection::_internal_shape_classification_pedestrian_front() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_pedestrian_front_;
}
inline void CameraDetection::_internal_set_shape_classification_pedestrian_front(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_pedestrian_front_ = value;
}

// optional bool shape_classification_pedestrian_side = 25;
inline bool CameraDetection::has_shape_classification_pedestrian_side() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_pedestrian_side() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_pedestrian_side_ = false;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline bool CameraDetection::shape_classification_pedestrian_side() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_pedestrian_side)
  return _internal_shape_classification_pedestrian_side();
}
inline void CameraDetection::set_shape_classification_pedestrian_side(bool value) {
  _internal_set_shape_classification_pedestrian_side(value);
  _impl_._has_bits_[0] |= 0x04000000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_pedestrian_side)
}
inline bool CameraDetection::_internal_shape_classification_pedestrian_side() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_pedestrian_side_;
}
inline void CameraDetection::_internal_set_shape_classification_pedestrian_side(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_pedestrian_side_ = value;
}

// optional bool shape_classification_pedestrian_rear = 26;
inline bool CameraDetection::has_shape_classification_pedestrian_rear() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_pedestrian_rear() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_pedestrian_rear_ = false;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline bool CameraDetection::shape_classification_pedestrian_rear() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_pedestrian_rear)
  return _internal_shape_classification_pedestrian_rear();
}
inline void CameraDetection::set_shape_classification_pedestrian_rear(bool value) {
  _internal_set_shape_classification_pedestrian_rear(value);
  _impl_._has_bits_[0] |= 0x08000000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_pedestrian_rear)
}
inline bool CameraDetection::_internal_shape_classification_pedestrian_rear() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_pedestrian_rear_;
}
inline void CameraDetection::_internal_set_shape_classification_pedestrian_rear(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_pedestrian_rear_ = value;
}

// optional double shape_classification_probability = 27;
inline bool CameraDetection::has_shape_classification_probability() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline void CameraDetection::clear_shape_classification_probability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_probability_ = 0;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline double CameraDetection::shape_classification_probability() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_probability)
  return _internal_shape_classification_probability();
}
inline void CameraDetection::set_shape_classification_probability(double value) {
  _internal_set_shape_classification_probability(value);
  _impl_._has_bits_[0] |= 0x20000000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_probability)
}
inline double CameraDetection::_internal_shape_classification_probability() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_classification_probability_;
}
inline void CameraDetection::_internal_set_shape_classification_probability(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_classification_probability_ = value;
}

// optional .osi3.CameraDetection.Color color = 28;
inline bool CameraDetection::has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline void CameraDetection::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = 0;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline ::osi3::CameraDetection_Color CameraDetection::color() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.color)
  return _internal_color();
}
inline void CameraDetection::set_color(::osi3::CameraDetection_Color value) {
  _internal_set_color(value);
  _impl_._has_bits_[0] |= 0x10000000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.color)
}
inline ::osi3::CameraDetection_Color CameraDetection::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::osi3::CameraDetection_Color>(_impl_.color_);
}
inline void CameraDetection::_internal_set_color(::osi3::CameraDetection_Color value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::osi3::CameraDetection_Color_IsValid(value));
  _impl_.color_ = value;
}

// optional double color_probability = 29;
inline bool CameraDetection::has_color_probability() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline void CameraDetection::clear_color_probability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_probability_ = 0;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline double CameraDetection::color_probability() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.color_probability)
  return _internal_color_probability();
}
inline void CameraDetection::set_color_probability(double value) {
  _internal_set_color_probability(value);
  _impl_._has_bits_[0] |= 0x40000000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.color_probability)
}
inline double CameraDetection::_internal_color_probability() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.color_probability_;
}
inline void CameraDetection::_internal_set_color_probability(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_probability_ = value;
}

// optional .osi3.Identifier ambiguity_id = 30;
inline bool CameraDetection::has_ambiguity_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ambiguity_id_ != nullptr);
  return value;
}
inline const ::osi3::Identifier& CameraDetection::_internal_ambiguity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Identifier* p = _impl_.ambiguity_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Identifier&>(::osi3::_Identifier_default_instance_);
}
inline const ::osi3::Identifier& CameraDetection::ambiguity_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.ambiguity_id)
  return _internal_ambiguity_id();
}
inline void CameraDetection::unsafe_arena_set_allocated_ambiguity_id(::osi3::Identifier* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ambiguity_id_);
  }
  _impl_.ambiguity_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.CameraDetection.ambiguity_id)
}
inline ::osi3::Identifier* CameraDetection::release_ambiguity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::Identifier* released = _impl_.ambiguity_id_;
  _impl_.ambiguity_id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Identifier* CameraDetection::unsafe_arena_release_ambiguity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.CameraDetection.ambiguity_id)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::Identifier* temp = _impl_.ambiguity_id_;
  _impl_.ambiguity_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* CameraDetection::_internal_mutable_ambiguity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ambiguity_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Identifier>(GetArena());
    _impl_.ambiguity_id_ = reinterpret_cast<::osi3::Identifier*>(p);
  }
  return _impl_.ambiguity_id_;
}
inline ::osi3::Identifier* CameraDetection::mutable_ambiguity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::osi3::Identifier* _msg = _internal_mutable_ambiguity_id();
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetection.ambiguity_id)
  return _msg;
}
inline void CameraDetection::set_allocated_ambiguity_id(::osi3::Identifier* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ambiguity_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.ambiguity_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraDetection.ambiguity_id)
}

// optional uint32 first_point_index = 31;
inline bool CameraDetection::has_first_point_index() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline void CameraDetection::clear_first_point_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.first_point_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline ::uint32_t CameraDetection::first_point_index() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.first_point_index)
  return _internal_first_point_index();
}
inline void CameraDetection::set_first_point_index(::uint32_t value) {
  _internal_set_first_point_index(value);
  _impl_._has_bits_[0] |= 0x80000000u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.first_point_index)
}
inline ::uint32_t CameraDetection::_internal_first_point_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.first_point_index_;
}
inline void CameraDetection::_internal_set_first_point_index(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.first_point_index_ = value;
}

// optional uint32 number_of_points = 32;
inline bool CameraDetection::has_number_of_points() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline void CameraDetection::clear_number_of_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_of_points_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline ::uint32_t CameraDetection::number_of_points() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.number_of_points)
  return _internal_number_of_points();
}
inline void CameraDetection::set_number_of_points(::uint32_t value) {
  _internal_set_number_of_points(value);
  _impl_._has_bits_[1] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.number_of_points)
}
inline ::uint32_t CameraDetection::_internal_number_of_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.number_of_points_;
}
inline void CameraDetection::_internal_set_number_of_points(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.number_of_points_ = value;
}

// optional .osi3.ColorDescription color_description = 33;
inline bool CameraDetection::has_color_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_description_ != nullptr);
  return value;
}
inline const ::osi3::ColorDescription& CameraDetection::_internal_color_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::ColorDescription* p = _impl_.color_description_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::ColorDescription&>(::osi3::_ColorDescription_default_instance_);
}
inline const ::osi3::ColorDescription& CameraDetection::color_description() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.color_description)
  return _internal_color_description();
}
inline void CameraDetection::unsafe_arena_set_allocated_color_description(::osi3::ColorDescription* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_description_);
  }
  _impl_.color_description_ = reinterpret_cast<::osi3::ColorDescription*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.CameraDetection.color_description)
}
inline ::osi3::ColorDescription* CameraDetection::release_color_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::osi3::ColorDescription* released = _impl_.color_description_;
  _impl_.color_description_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::ColorDescription* CameraDetection::unsafe_arena_release_color_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.CameraDetection.color_description)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::osi3::ColorDescription* temp = _impl_.color_description_;
  _impl_.color_description_ = nullptr;
  return temp;
}
inline ::osi3::ColorDescription* CameraDetection::_internal_mutable_color_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.color_description_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::ColorDescription>(GetArena());
    _impl_.color_description_ = reinterpret_cast<::osi3::ColorDescription*>(p);
  }
  return _impl_.color_description_;
}
inline ::osi3::ColorDescription* CameraDetection::mutable_color_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::osi3::ColorDescription* _msg = _internal_mutable_color_description();
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetection.color_description)
  return _msg;
}
inline void CameraDetection::set_allocated_color_description(::osi3::ColorDescription* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_description_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.color_description_ = reinterpret_cast<::osi3::ColorDescription*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraDetection.color_description)
}

// -------------------------------------------------------------------

// CameraPoint

// optional double existence_probability = 1;
inline bool CameraPoint::has_existence_probability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CameraPoint::clear_existence_probability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.existence_probability_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double CameraPoint::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.CameraPoint.existence_probability)
  return _internal_existence_probability();
}
inline void CameraPoint::set_existence_probability(double value) {
  _internal_set_existence_probability(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.CameraPoint.existence_probability)
}
inline double CameraPoint::_internal_existence_probability() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.existence_probability_;
}
inline void CameraPoint::_internal_set_existence_probability(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.existence_probability_ = value;
}

// optional .osi3.Spherical3d point = 2;
inline bool CameraPoint::has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline const ::osi3::Spherical3d& CameraPoint::_internal_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Spherical3d* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Spherical3d&>(::osi3::_Spherical3d_default_instance_);
}
inline const ::osi3::Spherical3d& CameraPoint::point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.CameraPoint.point)
  return _internal_point();
}
inline void CameraPoint::unsafe_arena_set_allocated_point(::osi3::Spherical3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = reinterpret_cast<::osi3::Spherical3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.CameraPoint.point)
}
inline ::osi3::Spherical3d* CameraPoint::release_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Spherical3d* released = _impl_.point_;
  _impl_.point_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Spherical3d* CameraPoint::unsafe_arena_release_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.CameraPoint.point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Spherical3d* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::osi3::Spherical3d* CameraPoint::_internal_mutable_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.point_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Spherical3d>(GetArena());
    _impl_.point_ = reinterpret_cast<::osi3::Spherical3d*>(p);
  }
  return _impl_.point_;
}
inline ::osi3::Spherical3d* CameraPoint::mutable_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::Spherical3d* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:osi3.CameraPoint.point)
  return _msg;
}
inline void CameraPoint::set_allocated_point(::osi3::Spherical3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.point_ = reinterpret_cast<::osi3::Spherical3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraPoint.point)
}

// optional .osi3.Spherical3d point_rmse = 3;
inline bool CameraPoint::has_point_rmse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_rmse_ != nullptr);
  return value;
}
inline const ::osi3::Spherical3d& CameraPoint::_internal_point_rmse() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Spherical3d* p = _impl_.point_rmse_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Spherical3d&>(::osi3::_Spherical3d_default_instance_);
}
inline const ::osi3::Spherical3d& CameraPoint::point_rmse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.CameraPoint.point_rmse)
  return _internal_point_rmse();
}
inline void CameraPoint::unsafe_arena_set_allocated_point_rmse(::osi3::Spherical3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point_rmse_);
  }
  _impl_.point_rmse_ = reinterpret_cast<::osi3::Spherical3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.CameraPoint.point_rmse)
}
inline ::osi3::Spherical3d* CameraPoint::release_point_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Spherical3d* released = _impl_.point_rmse_;
  _impl_.point_rmse_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Spherical3d* CameraPoint::unsafe_arena_release_point_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.CameraPoint.point_rmse)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Spherical3d* temp = _impl_.point_rmse_;
  _impl_.point_rmse_ = nullptr;
  return temp;
}
inline ::osi3::Spherical3d* CameraPoint::_internal_mutable_point_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.point_rmse_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Spherical3d>(GetArena());
    _impl_.point_rmse_ = reinterpret_cast<::osi3::Spherical3d*>(p);
  }
  return _impl_.point_rmse_;
}
inline ::osi3::Spherical3d* CameraPoint::mutable_point_rmse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::osi3::Spherical3d* _msg = _internal_mutable_point_rmse();
  // @@protoc_insertion_point(field_mutable:osi3.CameraPoint.point_rmse)
  return _msg;
}
inline void CameraPoint::set_allocated_point_rmse(::osi3::Spherical3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point_rmse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.point_rmse_ = reinterpret_cast<::osi3::Spherical3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraPoint.point_rmse)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace osi3


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::osi3::SensorDetectionHeader_DataQualifier> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::osi3::SensorDetectionHeader_DataQualifier>() {
  return ::osi3::SensorDetectionHeader_DataQualifier_descriptor();
}
template <>
struct is_proto_enum<::osi3::SensorDetectionHeader_ExtendedQualifier> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::osi3::SensorDetectionHeader_ExtendedQualifier>() {
  return ::osi3::SensorDetectionHeader_ExtendedQualifier_descriptor();
}
template <>
struct is_proto_enum<::osi3::CameraDetection_Color> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::osi3::CameraDetection_Color>() {
  return ::osi3::CameraDetection_Color_descriptor();
}
template <>
struct is_proto_enum<::osi3::CameraDetection_ImageShapeType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::osi3::CameraDetection_ImageShapeType>() {
  return ::osi3::CameraDetection_ImageShapeType_descriptor();
}
template <>
struct is_proto_enum<::osi3::DetectionClassification> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::osi3::DetectionClassification>() {
  return ::osi3::DetectionClassification_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // osi_5ffeaturedata_2eproto_2epb_2eh
