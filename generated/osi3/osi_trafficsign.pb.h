// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: osi_trafficsign.proto
// Protobuf C++ Version: 5.29.5

#ifndef osi_5ftrafficsign_2eproto_2epb_2eh
#define osi_5ftrafficsign_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029005
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "osi_common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_osi_5ftrafficsign_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_osi_5ftrafficsign_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_osi_5ftrafficsign_2eproto;
namespace osi3 {
class TrafficSign;
struct TrafficSignDefaultTypeInternal;
extern TrafficSignDefaultTypeInternal _TrafficSign_default_instance_;
class TrafficSignValue;
struct TrafficSignValueDefaultTypeInternal;
extern TrafficSignValueDefaultTypeInternal _TrafficSignValue_default_instance_;
class TrafficSign_MainSign;
struct TrafficSign_MainSignDefaultTypeInternal;
extern TrafficSign_MainSignDefaultTypeInternal _TrafficSign_MainSign_default_instance_;
class TrafficSign_MainSign_Classification;
struct TrafficSign_MainSign_ClassificationDefaultTypeInternal;
extern TrafficSign_MainSign_ClassificationDefaultTypeInternal _TrafficSign_MainSign_Classification_default_instance_;
class TrafficSign_SupplementarySign;
struct TrafficSign_SupplementarySignDefaultTypeInternal;
extern TrafficSign_SupplementarySignDefaultTypeInternal _TrafficSign_SupplementarySign_default_instance_;
class TrafficSign_SupplementarySign_Classification;
struct TrafficSign_SupplementarySign_ClassificationDefaultTypeInternal;
extern TrafficSign_SupplementarySign_ClassificationDefaultTypeInternal _TrafficSign_SupplementarySign_Classification_default_instance_;
class TrafficSign_SupplementarySign_Classification_Arrow;
struct TrafficSign_SupplementarySign_Classification_ArrowDefaultTypeInternal;
extern TrafficSign_SupplementarySign_Classification_ArrowDefaultTypeInternal _TrafficSign_SupplementarySign_Classification_Arrow_default_instance_;
}  // namespace osi3
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace osi3 {
enum TrafficSignValue_Unit : int {
  TrafficSignValue_Unit_UNIT_UNKNOWN = 0,
  TrafficSignValue_Unit_UNIT_OTHER = 1,
  TrafficSignValue_Unit_UNIT_NO_UNIT = 2,
  TrafficSignValue_Unit_UNIT_KILOMETER_PER_HOUR = 3,
  TrafficSignValue_Unit_UNIT_MILE_PER_HOUR = 4,
  TrafficSignValue_Unit_UNIT_METER = 5,
  TrafficSignValue_Unit_UNIT_KILOMETER = 6,
  TrafficSignValue_Unit_UNIT_FEET = 7,
  TrafficSignValue_Unit_UNIT_MILE = 8,
  TrafficSignValue_Unit_UNIT_METRIC_TON = 9,
  TrafficSignValue_Unit_UNIT_LONG_TON = 10,
  TrafficSignValue_Unit_UNIT_SHORT_TON = 11,
  TrafficSignValue_Unit_UNIT_MINUTES = 12,
  TrafficSignValue_Unit_UNIT_DAY = 13,
  TrafficSignValue_Unit_UNIT_PERCENTAGE = 14,
};

bool TrafficSignValue_Unit_IsValid(int value);
extern const uint32_t TrafficSignValue_Unit_internal_data_[];
constexpr TrafficSignValue_Unit TrafficSignValue_Unit_Unit_MIN = static_cast<TrafficSignValue_Unit>(0);
constexpr TrafficSignValue_Unit TrafficSignValue_Unit_Unit_MAX = static_cast<TrafficSignValue_Unit>(14);
constexpr int TrafficSignValue_Unit_Unit_ARRAYSIZE = 14 + 1;
const ::google::protobuf::EnumDescriptor*
TrafficSignValue_Unit_descriptor();
template <typename T>
const std::string& TrafficSignValue_Unit_Name(T value) {
  static_assert(std::is_same<T, TrafficSignValue_Unit>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Unit_Name().");
  return TrafficSignValue_Unit_Name(static_cast<TrafficSignValue_Unit>(value));
}
template <>
inline const std::string& TrafficSignValue_Unit_Name(TrafficSignValue_Unit value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrafficSignValue_Unit_descriptor,
                                                 0, 14>(
      static_cast<int>(value));
}
inline bool TrafficSignValue_Unit_Parse(absl::string_view name, TrafficSignValue_Unit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSignValue_Unit>(
      TrafficSignValue_Unit_descriptor(), name, value);
}
enum TrafficSign_MainSign_Classification_Type : int {
  TrafficSign_MainSign_Classification_Type_TYPE_UNKNOWN = 0,
  TrafficSign_MainSign_Classification_Type_TYPE_OTHER = 1,
  TrafficSign_MainSign_Classification_Type_TYPE_DANGER_SPOT = 2,
  TrafficSign_MainSign_Classification_Type_TYPE_ZEBRA_CROSSING = 87,
  TrafficSign_MainSign_Classification_Type_TYPE_FLIGHT = 110,
  TrafficSign_MainSign_Classification_Type_TYPE_CATTLE = 200,
  TrafficSign_MainSign_Classification_Type_TYPE_HORSE_RIDERS = 197,
  TrafficSign_MainSign_Classification_Type_TYPE_AMPHIBIANS = 188,
  TrafficSign_MainSign_Classification_Type_TYPE_FALLING_ROCKS = 96,
  TrafficSign_MainSign_Classification_Type_TYPE_SNOW_OR_ICE = 94,
  TrafficSign_MainSign_Classification_Type_TYPE_LOOSE_GRAVEL = 97,
  TrafficSign_MainSign_Classification_Type_TYPE_WATERSIDE = 102,
  TrafficSign_MainSign_Classification_Type_TYPE_CLEARANCE = 210,
  TrafficSign_MainSign_Classification_Type_TYPE_MOVABLE_BRIDGE = 101,
  TrafficSign_MainSign_Classification_Type_TYPE_RIGHT_BEFORE_LEFT_NEXT_INTERSECTION = 3,
  TrafficSign_MainSign_Classification_Type_TYPE_TURN_LEFT = 4,
  TrafficSign_MainSign_Classification_Type_TYPE_TURN_RIGHT = 5,
  TrafficSign_MainSign_Classification_Type_TYPE_DOUBLE_TURN_LEFT = 6,
  TrafficSign_MainSign_Classification_Type_TYPE_DOUBLE_TURN_RIGHT = 7,
  TrafficSign_MainSign_Classification_Type_TYPE_HILL_DOWNWARDS = 8,
  TrafficSign_MainSign_Classification_Type_TYPE_HILL_UPWARDS = 9,
  TrafficSign_MainSign_Classification_Type_TYPE_UNEVEN_ROAD = 93,
  TrafficSign_MainSign_Classification_Type_TYPE_ROAD_SLIPPERY_WET_OR_DIRTY = 95,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDE_WINDS = 98,
  TrafficSign_MainSign_Classification_Type_TYPE_ROAD_NARROWING = 10,
  TrafficSign_MainSign_Classification_Type_TYPE_ROAD_NARROWING_RIGHT = 12,
  TrafficSign_MainSign_Classification_Type_TYPE_ROAD_NARROWING_LEFT = 11,
  TrafficSign_MainSign_Classification_Type_TYPE_ROAD_WORKS = 13,
  TrafficSign_MainSign_Classification_Type_TYPE_TRAFFIC_QUEUES = 100,
  TrafficSign_MainSign_Classification_Type_TYPE_TWO_WAY_TRAFFIC = 14,
  TrafficSign_MainSign_Classification_Type_TYPE_ATTENTION_TRAFFIC_LIGHT = 15,
  TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIANS = 103,
  TrafficSign_MainSign_Classification_Type_TYPE_CHILDREN_CROSSING = 106,
  TrafficSign_MainSign_Classification_Type_TYPE_CYCLE_ROUTE = 107,
  TrafficSign_MainSign_Classification_Type_TYPE_DEER_CROSSING = 109,
  TrafficSign_MainSign_Classification_Type_TYPE_UNGATED_LEVEL_CROSSING = 144,
  TrafficSign_MainSign_Classification_Type_TYPE_LEVEL_CROSSING_MARKER = 112,
  TrafficSign_MainSign_Classification_Type_TYPE_RAILWAY_TRAFFIC_PRIORITY = 135,
  TrafficSign_MainSign_Classification_Type_TYPE_GIVE_WAY = 16,
  TrafficSign_MainSign_Classification_Type_TYPE_STOP = 17,
  TrafficSign_MainSign_Classification_Type_TYPE_PRIORITY_TO_OPPOSITE_DIRECTION = 18,
  TrafficSign_MainSign_Classification_Type_TYPE_PRIORITY_TO_OPPOSITE_DIRECTION_UPSIDE_DOWN = 19,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_TURN = 20,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_RIGHT_TURN = 21,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_STRAIGHT = 22,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_RIGHT_WAY = 24,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_WAY = 23,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_RIGHT_TURN_AND_STRAIGHT = 26,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_TURN_AND_STRAIGHT = 25,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_TURN_AND_RIGHT_TURN = 27,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_TURN_RIGHT_TURN_AND_STRAIGHT = 28,
  TrafficSign_MainSign_Classification_Type_TYPE_ROUNDABOUT = 29,
  TrafficSign_MainSign_Classification_Type_TYPE_ONEWAY_LEFT = 30,
  TrafficSign_MainSign_Classification_Type_TYPE_ONEWAY_RIGHT = 31,
  TrafficSign_MainSign_Classification_Type_TYPE_PASS_LEFT = 32,
  TrafficSign_MainSign_Classification_Type_TYPE_PASS_RIGHT = 33,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDE_LANE_OPEN_FOR_TRAFFIC = 128,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDE_LANE_CLOSED_FOR_TRAFFIC = 129,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDE_LANE_CLOSING_FOR_TRAFFIC = 130,
  TrafficSign_MainSign_Classification_Type_TYPE_BUS_STOP = 137,
  TrafficSign_MainSign_Classification_Type_TYPE_TAXI_STAND = 138,
  TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_ONLY = 145,
  TrafficSign_MainSign_Classification_Type_TYPE_HORSE_RIDERS_ONLY = 146,
  TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIANS_ONLY = 147,
  TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_PEDESTRIANS_SHARED_ONLY = 148,
  TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_PEDESTRIANS_SEPARATED_LEFT_ONLY = 149,
  TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_PEDESTRIANS_SEPARATED_RIGHT_ONLY = 150,
  TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIAN_ZONE_BEGIN = 151,
  TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIAN_ZONE_END = 152,
  TrafficSign_MainSign_Classification_Type_TYPE_BICYCLE_ROAD_BEGIN = 153,
  TrafficSign_MainSign_Classification_Type_TYPE_BICYCLE_ROAD_END = 154,
  TrafficSign_MainSign_Classification_Type_TYPE_BUS_LANE = 34,
  TrafficSign_MainSign_Classification_Type_TYPE_BUS_LANE_BEGIN = 35,
  TrafficSign_MainSign_Classification_Type_TYPE_BUS_LANE_END = 36,
  TrafficSign_MainSign_Classification_Type_TYPE_ALL_PROHIBITED = 37,
  TrafficSign_MainSign_Classification_Type_TYPE_MOTORIZED_MULTITRACK_PROHIBITED = 38,
  TrafficSign_MainSign_Classification_Type_TYPE_TRUCKS_PROHIBITED = 39,
  TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_PROHIBITED = 40,
  TrafficSign_MainSign_Classification_Type_TYPE_MOTORCYCLES_PROHIBITED = 41,
  TrafficSign_MainSign_Classification_Type_TYPE_MOPEDS_PROHIBITED = 155,
  TrafficSign_MainSign_Classification_Type_TYPE_HORSE_RIDERS_PROHIBITED = 156,
  TrafficSign_MainSign_Classification_Type_TYPE_HORSE_CARRIAGES_PROHIBITED = 157,
  TrafficSign_MainSign_Classification_Type_TYPE_CATTLE_PROHIBITED = 158,
  TrafficSign_MainSign_Classification_Type_TYPE_BUSES_PROHIBITED = 159,
  TrafficSign_MainSign_Classification_Type_TYPE_CARS_PROHIBITED = 160,
  TrafficSign_MainSign_Classification_Type_TYPE_CARS_TRAILERS_PROHIBITED = 161,
  TrafficSign_MainSign_Classification_Type_TYPE_TRUCKS_TRAILERS_PROHIBITED = 162,
  TrafficSign_MainSign_Classification_Type_TYPE_TRACTORS_PROHIBITED = 163,
  TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIANS_PROHIBITED = 42,
  TrafficSign_MainSign_Classification_Type_TYPE_MOTOR_VEHICLES_PROHIBITED = 43,
  TrafficSign_MainSign_Classification_Type_TYPE_HAZARDOUS_GOODS_VEHICLES_PROHIBITED = 164,
  TrafficSign_MainSign_Classification_Type_TYPE_OVER_WEIGHT_VEHICLES_PROHIBITED = 165,
  TrafficSign_MainSign_Classification_Type_TYPE_VEHICLES_AXLE_OVER_WEIGHT_PROHIBITED = 166,
  TrafficSign_MainSign_Classification_Type_TYPE_VEHICLES_EXCESS_WIDTH_PROHIBITED = 167,
  TrafficSign_MainSign_Classification_Type_TYPE_VEHICLES_EXCESS_HEIGHT_PROHIBITED = 168,
  TrafficSign_MainSign_Classification_Type_TYPE_VEHICLES_EXCESS_LENGTH_PROHIBITED = 169,
  TrafficSign_MainSign_Classification_Type_TYPE_DO_NOT_ENTER = 44,
  TrafficSign_MainSign_Classification_Type_TYPE_SNOW_CHAINS_REQUIRED = 170,
  TrafficSign_MainSign_Classification_Type_TYPE_WATER_POLLUTANT_VEHICLES_PROHIBITED = 171,
  TrafficSign_MainSign_Classification_Type_TYPE_ENVIRONMENTAL_ZONE_BEGIN = 45,
  TrafficSign_MainSign_Classification_Type_TYPE_ENVIRONMENTAL_ZONE_END = 46,
  TrafficSign_MainSign_Classification_Type_TYPE_NO_U_TURN_LEFT = 47,
  TrafficSign_MainSign_Classification_Type_TYPE_NO_U_TURN_RIGHT = 48,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_U_TURN_LEFT = 49,
  TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_U_TURN_RIGHT = 50,
  TrafficSign_MainSign_Classification_Type_TYPE_MINIMUM_DISTANCE_FOR_TRUCKS = 51,
  TrafficSign_MainSign_Classification_Type_TYPE_SPEED_LIMIT_BEGIN = 52,
  TrafficSign_MainSign_Classification_Type_TYPE_SPEED_LIMIT_ZONE_BEGIN = 53,
  TrafficSign_MainSign_Classification_Type_TYPE_SPEED_LIMIT_ZONE_END = 54,
  TrafficSign_MainSign_Classification_Type_TYPE_MINIMUM_SPEED_BEGIN = 55,
  TrafficSign_MainSign_Classification_Type_TYPE_OVERTAKING_BAN_BEGIN = 56,
  TrafficSign_MainSign_Classification_Type_TYPE_OVERTAKING_BAN_FOR_TRUCKS_BEGIN = 57,
  TrafficSign_MainSign_Classification_Type_TYPE_SPEED_LIMIT_END = 58,
  TrafficSign_MainSign_Classification_Type_TYPE_MINIMUM_SPEED_END = 59,
  TrafficSign_MainSign_Classification_Type_TYPE_OVERTAKING_BAN_END = 60,
  TrafficSign_MainSign_Classification_Type_TYPE_OVERTAKING_BAN_FOR_TRUCKS_END = 61,
  TrafficSign_MainSign_Classification_Type_TYPE_ALL_RESTRICTIONS_END = 62,
  TrafficSign_MainSign_Classification_Type_TYPE_NO_STOPPING = 63,
  TrafficSign_MainSign_Classification_Type_TYPE_NO_PARKING = 64,
  TrafficSign_MainSign_Classification_Type_TYPE_NO_PARKING_ZONE_BEGIN = 65,
  TrafficSign_MainSign_Classification_Type_TYPE_NO_PARKING_ZONE_END = 66,
  TrafficSign_MainSign_Classification_Type_TYPE_RIGHT_OF_WAY_NEXT_INTERSECTION = 67,
  TrafficSign_MainSign_Classification_Type_TYPE_RIGHT_OF_WAY_BEGIN = 68,
  TrafficSign_MainSign_Classification_Type_TYPE_RIGHT_OF_WAY_END = 69,
  TrafficSign_MainSign_Classification_Type_TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION = 70,
  TrafficSign_MainSign_Classification_Type_TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION_UPSIDE_DOWN = 71,
  TrafficSign_MainSign_Classification_Type_TYPE_TOWN_BEGIN = 72,
  TrafficSign_MainSign_Classification_Type_TYPE_TOWN_END = 73,
  TrafficSign_MainSign_Classification_Type_TYPE_CAR_PARKING = 74,
  TrafficSign_MainSign_Classification_Type_TYPE_CAR_PARKING_ZONE_BEGIN = 75,
  TrafficSign_MainSign_Classification_Type_TYPE_CAR_PARKING_ZONE_END = 76,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_HALF_PARKING_LEFT = 172,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_HALF_PARKING_RIGHT = 173,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PARKING_LEFT = 174,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PARKING_RIGHT = 175,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_LEFT = 176,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_RIGHT = 177,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PERPENDICULAR_PARKING_LEFT = 178,
  TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PERPENDICULAR_PARKING_RIGHT = 179,
  TrafficSign_MainSign_Classification_Type_TYPE_LIVING_STREET_BEGIN = 77,
  TrafficSign_MainSign_Classification_Type_TYPE_LIVING_STREET_END = 78,
  TrafficSign_MainSign_Classification_Type_TYPE_TUNNEL = 79,
  TrafficSign_MainSign_Classification_Type_TYPE_EMERGENCY_STOPPING_LEFT = 80,
  TrafficSign_MainSign_Classification_Type_TYPE_EMERGENCY_STOPPING_RIGHT = 81,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_BEGIN = 82,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_END = 83,
  TrafficSign_MainSign_Classification_Type_TYPE_EXPRESSWAY_BEGIN = 84,
  TrafficSign_MainSign_Classification_Type_TYPE_EXPRESSWAY_END = 85,
  TrafficSign_MainSign_Classification_Type_TYPE_NAMED_HIGHWAY_EXIT = 183,
  TrafficSign_MainSign_Classification_Type_TYPE_NAMED_EXPRESSWAY_EXIT = 184,
  TrafficSign_MainSign_Classification_Type_TYPE_NAMED_ROAD_EXIT = 185,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_EXIT = 86,
  TrafficSign_MainSign_Classification_Type_TYPE_EXPRESSWAY_EXIT = 186,
  TrafficSign_MainSign_Classification_Type_TYPE_ONEWAY_STREET = 187,
  TrafficSign_MainSign_Classification_Type_TYPE_CROSSING_GUARDS = 189,
  TrafficSign_MainSign_Classification_Type_TYPE_DEADEND = 190,
  TrafficSign_MainSign_Classification_Type_TYPE_DEADEND_EXCLUDING_DESIGNATED_ACTORS = 191,
  TrafficSign_MainSign_Classification_Type_TYPE_FIRST_AID_STATION = 194,
  TrafficSign_MainSign_Classification_Type_TYPE_POLICE_STATION = 195,
  TrafficSign_MainSign_Classification_Type_TYPE_TELEPHONE = 196,
  TrafficSign_MainSign_Classification_Type_TYPE_FILLING_STATION = 198,
  TrafficSign_MainSign_Classification_Type_TYPE_HOTEL = 201,
  TrafficSign_MainSign_Classification_Type_TYPE_INN = 202,
  TrafficSign_MainSign_Classification_Type_TYPE_KIOSK = 203,
  TrafficSign_MainSign_Classification_Type_TYPE_TOILET = 204,
  TrafficSign_MainSign_Classification_Type_TYPE_CHAPEL = 205,
  TrafficSign_MainSign_Classification_Type_TYPE_TOURIST_INFO = 206,
  TrafficSign_MainSign_Classification_Type_TYPE_REPAIR_SERVICE = 207,
  TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIAN_UNDERPASS = 208,
  TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIAN_BRIDGE = 209,
  TrafficSign_MainSign_Classification_Type_TYPE_CAMPER_PLACE = 213,
  TrafficSign_MainSign_Classification_Type_TYPE_ADVISORY_SPEED_LIMIT_BEGIN = 214,
  TrafficSign_MainSign_Classification_Type_TYPE_ADVISORY_SPEED_LIMIT_END = 215,
  TrafficSign_MainSign_Classification_Type_TYPE_PLACE_NAME = 216,
  TrafficSign_MainSign_Classification_Type_TYPE_TOURIST_ATTRACTION = 217,
  TrafficSign_MainSign_Classification_Type_TYPE_TOURIST_ROUTE = 218,
  TrafficSign_MainSign_Classification_Type_TYPE_TOURIST_AREA = 219,
  TrafficSign_MainSign_Classification_Type_TYPE_SHOULDER_NOT_PASSABLE_MOTOR_VEHICLES = 220,
  TrafficSign_MainSign_Classification_Type_TYPE_SHOULDER_UNSAFE_TRUCKS_TRACTORS = 221,
  TrafficSign_MainSign_Classification_Type_TYPE_TOLL_BEGIN = 222,
  TrafficSign_MainSign_Classification_Type_TYPE_TOLL_END = 223,
  TrafficSign_MainSign_Classification_Type_TYPE_TOLL_ROAD = 224,
  TrafficSign_MainSign_Classification_Type_TYPE_CUSTOMS = 225,
  TrafficSign_MainSign_Classification_Type_TYPE_INTERNATIONAL_BORDER_INFO = 226,
  TrafficSign_MainSign_Classification_Type_TYPE_STREETLIGHT_RED_BAND = 227,
  TrafficSign_MainSign_Classification_Type_TYPE_FEDERAL_HIGHWAY_ROUTE_NUMBER = 228,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_ROUTE_NUMBER = 229,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_INTERCHANGE_NUMBER = 230,
  TrafficSign_MainSign_Classification_Type_TYPE_EUROPEAN_ROUTE_NUMBER = 231,
  TrafficSign_MainSign_Classification_Type_TYPE_FEDERAL_HIGHWAY_DIRECTION_LEFT = 232,
  TrafficSign_MainSign_Classification_Type_TYPE_FEDERAL_HIGHWAY_DIRECTION_RIGHT = 233,
  TrafficSign_MainSign_Classification_Type_TYPE_PRIMARY_ROAD_DIRECTION_LEFT = 234,
  TrafficSign_MainSign_Classification_Type_TYPE_PRIMARY_ROAD_DIRECTION_RIGHT = 235,
  TrafficSign_MainSign_Classification_Type_TYPE_SECONDARY_ROAD_DIRECTION_LEFT = 236,
  TrafficSign_MainSign_Classification_Type_TYPE_SECONDARY_ROAD_DIRECTION_RIGHT = 237,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_DESIGNATED_ACTORS_LEFT = 238,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_DESIGNATED_ACTORS_RIGHT = 239,
  TrafficSign_MainSign_Classification_Type_TYPE_ROUTING_DESIGNATED_ACTORS = 240,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_TO_HIGHWAY_LEFT = 143,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_TO_HIGHWAY_RIGHT = 108,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_TO_LOCAL_DESTINATION_LEFT = 127,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_TO_LOCAL_DESTINATION_RIGHT = 136,
  TrafficSign_MainSign_Classification_Type_TYPE_CONSOLIDATED_DIRECTIONS = 118,
  TrafficSign_MainSign_Classification_Type_TYPE_STREET_NAME = 119,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_PREANNOUNCEMENT = 120,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_PREANNOUNCEMENT_LANE_CONFIG = 121,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_PREANNOUNCEMENT_HIGHWAY_ENTRIES = 122,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_ANNOUNCEMENT = 123,
  TrafficSign_MainSign_Classification_Type_TYPE_OTHER_ROAD_ANNOUNCEMENT = 124,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_ANNOUNCEMENT_TRUCK_STOP = 125,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_PREANNOUNCEMENT_DIRECTIONS = 126,
  TrafficSign_MainSign_Classification_Type_TYPE_POLE_EXIT = 88,
  TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_DISTANCE_BOARD = 180,
  TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_LEFT = 181,
  TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_RIGHT = 182,
  TrafficSign_MainSign_Classification_Type_TYPE_NUMBERED_DETOUR = 131,
  TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_BEGIN = 132,
  TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_END = 133,
  TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_ROUTING_BOARD = 134,
  TrafficSign_MainSign_Classification_Type_TYPE_OPTIONAL_DETOUR = 111,
  TrafficSign_MainSign_Classification_Type_TYPE_OPTIONAL_DETOUR_ROUTING = 199,
  TrafficSign_MainSign_Classification_Type_TYPE_ROUTE_RECOMMENDATION = 211,
  TrafficSign_MainSign_Classification_Type_TYPE_ROUTE_RECOMMENDATION_END = 212,
  TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LANE_TRANSITION_LEFT = 192,
  TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LANE_TRANSITION_RIGHT = 193,
  TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_RIGHT_LANE_END = 90,
  TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LEFT_LANE_END = 89,
  TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_RIGHT_LANE_BEGIN = 115,
  TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LEFT_LANE_BEGIN = 116,
  TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LANE_CONSOLIDATION = 117,
  TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_CITY_BLOCK = 142,
  TrafficSign_MainSign_Classification_Type_TYPE_GATE = 141,
  TrafficSign_MainSign_Classification_Type_TYPE_POLE_WARNING = 91,
  TrafficSign_MainSign_Classification_Type_TYPE_TRAFFIC_CONE = 140,
  TrafficSign_MainSign_Classification_Type_TYPE_MOBILE_LANE_CLOSURE = 139,
  TrafficSign_MainSign_Classification_Type_TYPE_REFLECTOR_POST = 114,
  TrafficSign_MainSign_Classification_Type_TYPE_DIRECTIONAL_BOARD_WARNING = 113,
  TrafficSign_MainSign_Classification_Type_TYPE_GUIDING_PLATE = 104,
  TrafficSign_MainSign_Classification_Type_TYPE_GUIDING_PLATE_WEDGES = 105,
  TrafficSign_MainSign_Classification_Type_TYPE_PARKING_HAZARD = 99,
  TrafficSign_MainSign_Classification_Type_TYPE_TRAFFIC_LIGHT_GREEN_ARROW = 92,
};

bool TrafficSign_MainSign_Classification_Type_IsValid(int value);
extern const uint32_t TrafficSign_MainSign_Classification_Type_internal_data_[];
constexpr TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification_Type_Type_MIN = static_cast<TrafficSign_MainSign_Classification_Type>(0);
constexpr TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification_Type_Type_MAX = static_cast<TrafficSign_MainSign_Classification_Type>(240);
constexpr int TrafficSign_MainSign_Classification_Type_Type_ARRAYSIZE = 240 + 1;
const ::google::protobuf::EnumDescriptor*
TrafficSign_MainSign_Classification_Type_descriptor();
template <typename T>
const std::string& TrafficSign_MainSign_Classification_Type_Name(T value) {
  static_assert(std::is_same<T, TrafficSign_MainSign_Classification_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return TrafficSign_MainSign_Classification_Type_Name(static_cast<TrafficSign_MainSign_Classification_Type>(value));
}
template <>
inline const std::string& TrafficSign_MainSign_Classification_Type_Name(TrafficSign_MainSign_Classification_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrafficSign_MainSign_Classification_Type_descriptor,
                                                 0, 240>(
      static_cast<int>(value));
}
inline bool TrafficSign_MainSign_Classification_Type_Parse(absl::string_view name, TrafficSign_MainSign_Classification_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_MainSign_Classification_Type>(
      TrafficSign_MainSign_Classification_Type_descriptor(), name, value);
}
enum TrafficSign_MainSign_Classification_DirectionScope : int {
  TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_UNKNOWN = 0,
  TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_OTHER = 1,
  TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_NO_DIRECTION = 2,
  TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_LEFT = 3,
  TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_RIGHT = 4,
  TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_LEFT_RIGHT = 5,
};

bool TrafficSign_MainSign_Classification_DirectionScope_IsValid(int value);
extern const uint32_t TrafficSign_MainSign_Classification_DirectionScope_internal_data_[];
constexpr TrafficSign_MainSign_Classification_DirectionScope TrafficSign_MainSign_Classification_DirectionScope_DirectionScope_MIN = static_cast<TrafficSign_MainSign_Classification_DirectionScope>(0);
constexpr TrafficSign_MainSign_Classification_DirectionScope TrafficSign_MainSign_Classification_DirectionScope_DirectionScope_MAX = static_cast<TrafficSign_MainSign_Classification_DirectionScope>(5);
constexpr int TrafficSign_MainSign_Classification_DirectionScope_DirectionScope_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
TrafficSign_MainSign_Classification_DirectionScope_descriptor();
template <typename T>
const std::string& TrafficSign_MainSign_Classification_DirectionScope_Name(T value) {
  static_assert(std::is_same<T, TrafficSign_MainSign_Classification_DirectionScope>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DirectionScope_Name().");
  return TrafficSign_MainSign_Classification_DirectionScope_Name(static_cast<TrafficSign_MainSign_Classification_DirectionScope>(value));
}
template <>
inline const std::string& TrafficSign_MainSign_Classification_DirectionScope_Name(TrafficSign_MainSign_Classification_DirectionScope value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrafficSign_MainSign_Classification_DirectionScope_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool TrafficSign_MainSign_Classification_DirectionScope_Parse(absl::string_view name, TrafficSign_MainSign_Classification_DirectionScope* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_MainSign_Classification_DirectionScope>(
      TrafficSign_MainSign_Classification_DirectionScope_descriptor(), name, value);
}
enum TrafficSign_SupplementarySign_Classification_Arrow_Direction : int {
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_UNKNOWN = 0,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_OTHER = 1,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_NO_DIRECTION = 2,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_0_DEG = 3,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_45_DEG_RIGHT = 4,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_45_DEG_LEFT = 5,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_90_DEG_RIGHT = 6,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_90_DEG_LEFT = 7,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_135_DEG_RIGHT = 8,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_135_DEG_LEFT = 9,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_180_DEG = 10,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_45_DEG_RIGHT = 11,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_45_DEG_LEFT = 12,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_90_DEG_RIGHT = 13,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_90_DEG_LEFT = 14,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_135_DEG_RIGHT = 15,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_135_DEG_LEFT = 16,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_180_DEG_RIGHT = 17,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_180_DEG_LEFT = 18,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_0_DEG = 19,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_45_DEG_RIGHT = 20,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_45_DEG_LEFT = 21,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_90_DEG_RIGHT = 22,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_90_DEG_LEFT = 23,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_135_DEG_RIGHT = 24,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_135_DEG_LEFT = 25,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_180_DEG = 26,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_LEFT_TO_TURN_0_DEG = 27,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_RIGHT_TO_TURN_0_DEG = 28,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_LEFT_TO_TURN_90_DEG_RIGHT = 29,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_RIGHT_TO_TURN_90_DEG_LEFT = 30,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_LEFT_DRIVE_BACK_TO_TURN_90_DEG_RIGHT = 31,
  TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_RIGHT_DRIVE_BACK_TO_TURN_90_DEG_LEFT = 32,
};

bool TrafficSign_SupplementarySign_Classification_Arrow_Direction_IsValid(int value);
extern const uint32_t TrafficSign_SupplementarySign_Classification_Arrow_Direction_internal_data_[];
constexpr TrafficSign_SupplementarySign_Classification_Arrow_Direction TrafficSign_SupplementarySign_Classification_Arrow_Direction_Direction_MIN = static_cast<TrafficSign_SupplementarySign_Classification_Arrow_Direction>(0);
constexpr TrafficSign_SupplementarySign_Classification_Arrow_Direction TrafficSign_SupplementarySign_Classification_Arrow_Direction_Direction_MAX = static_cast<TrafficSign_SupplementarySign_Classification_Arrow_Direction>(32);
constexpr int TrafficSign_SupplementarySign_Classification_Arrow_Direction_Direction_ARRAYSIZE = 32 + 1;
const ::google::protobuf::EnumDescriptor*
TrafficSign_SupplementarySign_Classification_Arrow_Direction_descriptor();
template <typename T>
const std::string& TrafficSign_SupplementarySign_Classification_Arrow_Direction_Name(T value) {
  static_assert(std::is_same<T, TrafficSign_SupplementarySign_Classification_Arrow_Direction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Direction_Name().");
  return TrafficSign_SupplementarySign_Classification_Arrow_Direction_Name(static_cast<TrafficSign_SupplementarySign_Classification_Arrow_Direction>(value));
}
template <>
inline const std::string& TrafficSign_SupplementarySign_Classification_Arrow_Direction_Name(TrafficSign_SupplementarySign_Classification_Arrow_Direction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrafficSign_SupplementarySign_Classification_Arrow_Direction_descriptor,
                                                 0, 32>(
      static_cast<int>(value));
}
inline bool TrafficSign_SupplementarySign_Classification_Arrow_Direction_Parse(absl::string_view name, TrafficSign_SupplementarySign_Classification_Arrow_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_SupplementarySign_Classification_Arrow_Direction>(
      TrafficSign_SupplementarySign_Classification_Arrow_Direction_descriptor(), name, value);
}
enum TrafficSign_SupplementarySign_Classification_Type : int {
  TrafficSign_SupplementarySign_Classification_Type_TYPE_UNKNOWN = 0,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_OTHER = 1,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_NO_SIGN = 2,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_TEXT = 41,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_SPACE = 39,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_TIME = 26,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_ARROW = 30,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_CONSTRAINED_TO = 46,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_EXCEPT = 45,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_VALID_FOR_DISTANCE = 3,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_LEFT_FOUR_WAY = 27,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_TOP_LEFT_FOUR_WAY = 28,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_STRAIGHT = 32,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_SIDEWAYS = 33,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_TOP_LEFT_THREE_WAY_STRAIGHT = 34,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_FOUR_WAY = 29,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_TOP_RIGHT_FOUR_WAY = 31,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_STRAIGHT = 35,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_SIDEWAY = 36,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_TOP_RIGHT_THREE_WAY_STRAIGHT = 37,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_VALID_IN_DISTANCE = 4,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_STOP_IN = 25,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_LEFT_ARROW = 11,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_LEFT_BEND_ARROW = 13,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_RIGHT_ARROW = 12,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_RIGHT_BEND_ARROW = 14,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_ACCIDENT = 40,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_SNOW = 9,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_FOG = 8,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_ROLLING_HIGHWAY_INFORMATION = 48,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_SERVICES = 47,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_TIME_RANGE = 5,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PARKING_DISC_TIME_RESTRICTION = 43,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_WEIGHT = 6,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_WET = 44,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_PARKING_CONSTRAINT = 42,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_NO_WAITING_SIDE_STRIPES = 38,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_RAIN = 7,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_SNOW_RAIN = 10,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_NIGHT = 19,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_STOP_4_WAY = 21,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_TRUCK = 15,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_TRACTORS_MAY_BE_PASSED = 16,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_HAZARDOUS = 17,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_TRAILER = 18,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_ZONE = 20,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_MOTORCYCLE = 22,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_MOTORCYCLE_ALLOWED = 23,
  TrafficSign_SupplementarySign_Classification_Type_TYPE_CAR = 24,
};

bool TrafficSign_SupplementarySign_Classification_Type_IsValid(int value);
extern const uint32_t TrafficSign_SupplementarySign_Classification_Type_internal_data_[];
constexpr TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification_Type_Type_MIN = static_cast<TrafficSign_SupplementarySign_Classification_Type>(0);
constexpr TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification_Type_Type_MAX = static_cast<TrafficSign_SupplementarySign_Classification_Type>(48);
constexpr int TrafficSign_SupplementarySign_Classification_Type_Type_ARRAYSIZE = 48 + 1;
const ::google::protobuf::EnumDescriptor*
TrafficSign_SupplementarySign_Classification_Type_descriptor();
template <typename T>
const std::string& TrafficSign_SupplementarySign_Classification_Type_Name(T value) {
  static_assert(std::is_same<T, TrafficSign_SupplementarySign_Classification_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return TrafficSign_SupplementarySign_Classification_Type_Name(static_cast<TrafficSign_SupplementarySign_Classification_Type>(value));
}
template <>
inline const std::string& TrafficSign_SupplementarySign_Classification_Type_Name(TrafficSign_SupplementarySign_Classification_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrafficSign_SupplementarySign_Classification_Type_descriptor,
                                                 0, 48>(
      static_cast<int>(value));
}
inline bool TrafficSign_SupplementarySign_Classification_Type_Parse(absl::string_view name, TrafficSign_SupplementarySign_Classification_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_SupplementarySign_Classification_Type>(
      TrafficSign_SupplementarySign_Classification_Type_descriptor(), name, value);
}
enum TrafficSign_SupplementarySign_Classification_Actor : int {
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_UNKNOWN = 0,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_OTHER = 1,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_NO_ACTOR = 2,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_AGRICULTURAL_VEHICLES = 3,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_BICYCLES = 4,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_BUSES = 5,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CAMPERS = 6,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CARAVANS = 7,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CARS = 8,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CARS_WITH_CARAVANS = 9,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CARS_WITH_TRAILERS = 10,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CATTLE = 11,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CHILDREN = 12,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CONSTRUCTION_VEHICLES = 13,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_DELIVERY_VEHICLES = 14,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_DISABLED_PERSONS = 15,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_EBIKES = 16,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_ELECTRIC_VEHICLES = 17,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_EMERGENCY_VEHICLES = 18,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_FERRY_USERS = 19,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_FORESTRY_VEHICLES = 20,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_HAZARDOUS_GOODS_VEHICLES = 21,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_HORSE_CARRIAGES = 22,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_HORSE_RIDERS = 23,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_INLINE_SKATERS = 24,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MEDICAL_VEHICLES = 25,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MILITARY_VEHICLES = 26,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MOPEDS = 27,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MOTORCYCLES = 28,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MOTORIZED_MULTITRACK_VEHICLES = 29,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_OPERATIONAL_AND_UTILITY_VEHICLES = 30,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_PEDESTRIANS = 31,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_PUBLIC_TRANSPORT_VEHICLES = 32,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_RAILROAD_TRAFFIC = 33,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_RESIDENTS = 34,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_SLURRY_TRANSPORT = 35,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TAXIS = 36,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRACTORS = 37,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRAILERS = 38,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRAMS = 39,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRUCKS = 40,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRUCKS_WITH_SEMITRAILERS = 41,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRUCKS_WITH_TRAILERS = 42,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_VEHICLES_WITH_GREEN_BADGES = 43,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_VEHICLES_WITH_RED_BADGES = 44,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_VEHICLES_WITH_YELLOW_BADGES = 45,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_WATER_POLLUTANT_VEHICLES = 46,
  TrafficSign_SupplementarySign_Classification_Actor_ACTOR_WINTER_SPORTSPEOPLE = 47,
};

bool TrafficSign_SupplementarySign_Classification_Actor_IsValid(int value);
extern const uint32_t TrafficSign_SupplementarySign_Classification_Actor_internal_data_[];
constexpr TrafficSign_SupplementarySign_Classification_Actor TrafficSign_SupplementarySign_Classification_Actor_Actor_MIN = static_cast<TrafficSign_SupplementarySign_Classification_Actor>(0);
constexpr TrafficSign_SupplementarySign_Classification_Actor TrafficSign_SupplementarySign_Classification_Actor_Actor_MAX = static_cast<TrafficSign_SupplementarySign_Classification_Actor>(47);
constexpr int TrafficSign_SupplementarySign_Classification_Actor_Actor_ARRAYSIZE = 47 + 1;
const ::google::protobuf::EnumDescriptor*
TrafficSign_SupplementarySign_Classification_Actor_descriptor();
template <typename T>
const std::string& TrafficSign_SupplementarySign_Classification_Actor_Name(T value) {
  static_assert(std::is_same<T, TrafficSign_SupplementarySign_Classification_Actor>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Actor_Name().");
  return TrafficSign_SupplementarySign_Classification_Actor_Name(static_cast<TrafficSign_SupplementarySign_Classification_Actor>(value));
}
template <>
inline const std::string& TrafficSign_SupplementarySign_Classification_Actor_Name(TrafficSign_SupplementarySign_Classification_Actor value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrafficSign_SupplementarySign_Classification_Actor_descriptor,
                                                 0, 47>(
      static_cast<int>(value));
}
inline bool TrafficSign_SupplementarySign_Classification_Actor_Parse(absl::string_view name, TrafficSign_SupplementarySign_Classification_Actor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_SupplementarySign_Classification_Actor>(
      TrafficSign_SupplementarySign_Classification_Actor_descriptor(), name, value);
}
enum TrafficSign_Variability : int {
  TrafficSign_Variability_VARIABILITY_UNKNOWN = 0,
  TrafficSign_Variability_VARIABILITY_OTHER = 1,
  TrafficSign_Variability_VARIABILITY_FIXED = 2,
  TrafficSign_Variability_VARIABILITY_VARIABLE = 3,
};

bool TrafficSign_Variability_IsValid(int value);
extern const uint32_t TrafficSign_Variability_internal_data_[];
constexpr TrafficSign_Variability TrafficSign_Variability_Variability_MIN = static_cast<TrafficSign_Variability>(0);
constexpr TrafficSign_Variability TrafficSign_Variability_Variability_MAX = static_cast<TrafficSign_Variability>(3);
constexpr int TrafficSign_Variability_Variability_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
TrafficSign_Variability_descriptor();
template <typename T>
const std::string& TrafficSign_Variability_Name(T value) {
  static_assert(std::is_same<T, TrafficSign_Variability>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Variability_Name().");
  return TrafficSign_Variability_Name(static_cast<TrafficSign_Variability>(value));
}
template <>
inline const std::string& TrafficSign_Variability_Name(TrafficSign_Variability value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrafficSign_Variability_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool TrafficSign_Variability_Parse(absl::string_view name, TrafficSign_Variability* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_Variability>(
      TrafficSign_Variability_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TrafficSignValue final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.TrafficSignValue) */ {
 public:
  inline TrafficSignValue() : TrafficSignValue(nullptr) {}
  ~TrafficSignValue() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrafficSignValue* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrafficSignValue));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficSignValue(
      ::google::protobuf::internal::ConstantInitialized);

  inline TrafficSignValue(const TrafficSignValue& from) : TrafficSignValue(nullptr, from) {}
  inline TrafficSignValue(TrafficSignValue&& from) noexcept
      : TrafficSignValue(nullptr, std::move(from)) {}
  inline TrafficSignValue& operator=(const TrafficSignValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSignValue& operator=(TrafficSignValue&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSignValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSignValue* internal_default_instance() {
    return reinterpret_cast<const TrafficSignValue*>(
        &_TrafficSignValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(TrafficSignValue& a, TrafficSignValue& b) { a.Swap(&b); }
  inline void Swap(TrafficSignValue* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSignValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSignValue* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrafficSignValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficSignValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrafficSignValue& from) { TrafficSignValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrafficSignValue* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.TrafficSignValue"; }

 protected:
  explicit TrafficSignValue(::google::protobuf::Arena* arena);
  TrafficSignValue(::google::protobuf::Arena* arena, const TrafficSignValue& from);
  TrafficSignValue(::google::protobuf::Arena* arena, TrafficSignValue&& from) noexcept
      : TrafficSignValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Unit = TrafficSignValue_Unit;
  static constexpr Unit UNIT_UNKNOWN = TrafficSignValue_Unit_UNIT_UNKNOWN;
  static constexpr Unit UNIT_OTHER = TrafficSignValue_Unit_UNIT_OTHER;
  static constexpr Unit UNIT_NO_UNIT = TrafficSignValue_Unit_UNIT_NO_UNIT;
  static constexpr Unit UNIT_KILOMETER_PER_HOUR = TrafficSignValue_Unit_UNIT_KILOMETER_PER_HOUR;
  static constexpr Unit UNIT_MILE_PER_HOUR = TrafficSignValue_Unit_UNIT_MILE_PER_HOUR;
  static constexpr Unit UNIT_METER = TrafficSignValue_Unit_UNIT_METER;
  static constexpr Unit UNIT_KILOMETER = TrafficSignValue_Unit_UNIT_KILOMETER;
  static constexpr Unit UNIT_FEET = TrafficSignValue_Unit_UNIT_FEET;
  static constexpr Unit UNIT_MILE = TrafficSignValue_Unit_UNIT_MILE;
  static constexpr Unit UNIT_METRIC_TON = TrafficSignValue_Unit_UNIT_METRIC_TON;
  static constexpr Unit UNIT_LONG_TON = TrafficSignValue_Unit_UNIT_LONG_TON;
  static constexpr Unit UNIT_SHORT_TON = TrafficSignValue_Unit_UNIT_SHORT_TON;
  static constexpr Unit UNIT_MINUTES = TrafficSignValue_Unit_UNIT_MINUTES;
  static constexpr Unit UNIT_DAY = TrafficSignValue_Unit_UNIT_DAY;
  static constexpr Unit UNIT_PERCENTAGE = TrafficSignValue_Unit_UNIT_PERCENTAGE;
  static inline bool Unit_IsValid(int value) {
    return TrafficSignValue_Unit_IsValid(value);
  }
  static constexpr Unit Unit_MIN = TrafficSignValue_Unit_Unit_MIN;
  static constexpr Unit Unit_MAX = TrafficSignValue_Unit_Unit_MAX;
  static constexpr int Unit_ARRAYSIZE = TrafficSignValue_Unit_Unit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Unit_descriptor() {
    return TrafficSignValue_Unit_descriptor();
  }
  template <typename T>
  static inline const std::string& Unit_Name(T value) {
    return TrafficSignValue_Unit_Name(value);
  }
  static inline bool Unit_Parse(absl::string_view name, Unit* value) {
    return TrafficSignValue_Unit_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTextFieldNumber = 3,
    kValueFieldNumber = 1,
    kValueUnitFieldNumber = 2,
  };
  // optional string text = 3;
  bool has_text() const;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // optional double value = 1;
  bool has_value() const;
  void clear_value() ;
  double value() const;
  void set_value(double value);

  private:
  double _internal_value() const;
  void _internal_set_value(double value);

  public:
  // optional .osi3.TrafficSignValue.Unit value_unit = 2;
  bool has_value_unit() const;
  void clear_value_unit() ;
  ::osi3::TrafficSignValue_Unit value_unit() const;
  void set_value_unit(::osi3::TrafficSignValue_Unit value);

  private:
  ::osi3::TrafficSignValue_Unit _internal_value_unit() const;
  void _internal_set_value_unit(::osi3::TrafficSignValue_Unit value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.TrafficSignValue)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      34, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TrafficSignValue& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    double value_;
    int value_unit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ftrafficsign_2eproto;
};
// -------------------------------------------------------------------

class TrafficSign_SupplementarySign_Classification_Arrow final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.TrafficSign.SupplementarySign.Classification.Arrow) */ {
 public:
  inline TrafficSign_SupplementarySign_Classification_Arrow() : TrafficSign_SupplementarySign_Classification_Arrow(nullptr) {}
  ~TrafficSign_SupplementarySign_Classification_Arrow() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrafficSign_SupplementarySign_Classification_Arrow* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrafficSign_SupplementarySign_Classification_Arrow));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficSign_SupplementarySign_Classification_Arrow(
      ::google::protobuf::internal::ConstantInitialized);

  inline TrafficSign_SupplementarySign_Classification_Arrow(const TrafficSign_SupplementarySign_Classification_Arrow& from) : TrafficSign_SupplementarySign_Classification_Arrow(nullptr, from) {}
  inline TrafficSign_SupplementarySign_Classification_Arrow(TrafficSign_SupplementarySign_Classification_Arrow&& from) noexcept
      : TrafficSign_SupplementarySign_Classification_Arrow(nullptr, std::move(from)) {}
  inline TrafficSign_SupplementarySign_Classification_Arrow& operator=(const TrafficSign_SupplementarySign_Classification_Arrow& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_SupplementarySign_Classification_Arrow& operator=(TrafficSign_SupplementarySign_Classification_Arrow&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSign_SupplementarySign_Classification_Arrow& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSign_SupplementarySign_Classification_Arrow* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_SupplementarySign_Classification_Arrow*>(
        &_TrafficSign_SupplementarySign_Classification_Arrow_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(TrafficSign_SupplementarySign_Classification_Arrow& a, TrafficSign_SupplementarySign_Classification_Arrow& b) { a.Swap(&b); }
  inline void Swap(TrafficSign_SupplementarySign_Classification_Arrow* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSign_SupplementarySign_Classification_Arrow* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSign_SupplementarySign_Classification_Arrow* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrafficSign_SupplementarySign_Classification_Arrow>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficSign_SupplementarySign_Classification_Arrow& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrafficSign_SupplementarySign_Classification_Arrow& from) { TrafficSign_SupplementarySign_Classification_Arrow::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrafficSign_SupplementarySign_Classification_Arrow* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.TrafficSign.SupplementarySign.Classification.Arrow"; }

 protected:
  explicit TrafficSign_SupplementarySign_Classification_Arrow(::google::protobuf::Arena* arena);
  TrafficSign_SupplementarySign_Classification_Arrow(::google::protobuf::Arena* arena, const TrafficSign_SupplementarySign_Classification_Arrow& from);
  TrafficSign_SupplementarySign_Classification_Arrow(::google::protobuf::Arena* arena, TrafficSign_SupplementarySign_Classification_Arrow&& from) noexcept
      : TrafficSign_SupplementarySign_Classification_Arrow(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Direction = TrafficSign_SupplementarySign_Classification_Arrow_Direction;
  static constexpr Direction DIRECTION_UNKNOWN = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_UNKNOWN;
  static constexpr Direction DIRECTION_OTHER = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_OTHER;
  static constexpr Direction DIRECTION_NO_DIRECTION = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_NO_DIRECTION;
  static constexpr Direction DIRECTION_DIRECT_0_DEG = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_0_DEG;
  static constexpr Direction DIRECTION_DIRECT_45_DEG_RIGHT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_45_DEG_RIGHT;
  static constexpr Direction DIRECTION_DIRECT_45_DEG_LEFT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_45_DEG_LEFT;
  static constexpr Direction DIRECTION_DIRECT_90_DEG_RIGHT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_90_DEG_RIGHT;
  static constexpr Direction DIRECTION_DIRECT_90_DEG_LEFT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_90_DEG_LEFT;
  static constexpr Direction DIRECTION_DIRECT_135_DEG_RIGHT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_135_DEG_RIGHT;
  static constexpr Direction DIRECTION_DIRECT_135_DEG_LEFT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_135_DEG_LEFT;
  static constexpr Direction DIRECTION_DIRECT_180_DEG = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_DIRECT_180_DEG;
  static constexpr Direction DIRECTION_TURN_45_DEG_RIGHT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_45_DEG_RIGHT;
  static constexpr Direction DIRECTION_TURN_45_DEG_LEFT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_45_DEG_LEFT;
  static constexpr Direction DIRECTION_TURN_90_DEG_RIGHT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_90_DEG_RIGHT;
  static constexpr Direction DIRECTION_TURN_90_DEG_LEFT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_90_DEG_LEFT;
  static constexpr Direction DIRECTION_TURN_135_DEG_RIGHT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_135_DEG_RIGHT;
  static constexpr Direction DIRECTION_TURN_135_DEG_LEFT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_135_DEG_LEFT;
  static constexpr Direction DIRECTION_TURN_180_DEG_RIGHT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_180_DEG_RIGHT;
  static constexpr Direction DIRECTION_TURN_180_DEG_LEFT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_TURN_180_DEG_LEFT;
  static constexpr Direction DIRECTION_CIRCLE_0_DEG = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_0_DEG;
  static constexpr Direction DIRECTION_CIRCLE_45_DEG_RIGHT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_45_DEG_RIGHT;
  static constexpr Direction DIRECTION_CIRCLE_45_DEG_LEFT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_45_DEG_LEFT;
  static constexpr Direction DIRECTION_CIRCLE_90_DEG_RIGHT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_90_DEG_RIGHT;
  static constexpr Direction DIRECTION_CIRCLE_90_DEG_LEFT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_90_DEG_LEFT;
  static constexpr Direction DIRECTION_CIRCLE_135_DEG_RIGHT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_135_DEG_RIGHT;
  static constexpr Direction DIRECTION_CIRCLE_135_DEG_LEFT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_135_DEG_LEFT;
  static constexpr Direction DIRECTION_CIRCLE_180_DEG = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_CIRCLE_180_DEG;
  static constexpr Direction DIRECTION_KEEP_LEFT_TO_TURN_0_DEG = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_LEFT_TO_TURN_0_DEG;
  static constexpr Direction DIRECTION_KEEP_RIGHT_TO_TURN_0_DEG = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_RIGHT_TO_TURN_0_DEG;
  static constexpr Direction DIRECTION_KEEP_LEFT_TO_TURN_90_DEG_RIGHT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_LEFT_TO_TURN_90_DEG_RIGHT;
  static constexpr Direction DIRECTION_KEEP_RIGHT_TO_TURN_90_DEG_LEFT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_RIGHT_TO_TURN_90_DEG_LEFT;
  static constexpr Direction DIRECTION_KEEP_LEFT_DRIVE_BACK_TO_TURN_90_DEG_RIGHT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_LEFT_DRIVE_BACK_TO_TURN_90_DEG_RIGHT;
  static constexpr Direction DIRECTION_KEEP_RIGHT_DRIVE_BACK_TO_TURN_90_DEG_LEFT = TrafficSign_SupplementarySign_Classification_Arrow_Direction_DIRECTION_KEEP_RIGHT_DRIVE_BACK_TO_TURN_90_DEG_LEFT;
  static inline bool Direction_IsValid(int value) {
    return TrafficSign_SupplementarySign_Classification_Arrow_Direction_IsValid(value);
  }
  static constexpr Direction Direction_MIN = TrafficSign_SupplementarySign_Classification_Arrow_Direction_Direction_MIN;
  static constexpr Direction Direction_MAX = TrafficSign_SupplementarySign_Classification_Arrow_Direction_Direction_MAX;
  static constexpr int Direction_ARRAYSIZE = TrafficSign_SupplementarySign_Classification_Arrow_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Direction_descriptor() {
    return TrafficSign_SupplementarySign_Classification_Arrow_Direction_descriptor();
  }
  template <typename T>
  static inline const std::string& Direction_Name(T value) {
    return TrafficSign_SupplementarySign_Classification_Arrow_Direction_Name(value);
  }
  static inline bool Direction_Parse(absl::string_view name, Direction* value) {
    return TrafficSign_SupplementarySign_Classification_Arrow_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kLaneIdFieldNumber = 1,
    kDirectionFieldNumber = 2,
  };
  // repeated .osi3.Identifier lane_id = 1;
  int lane_id_size() const;
  private:
  int _internal_lane_id_size() const;

  public:
  void clear_lane_id() ;
  ::osi3::Identifier* mutable_lane_id(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::Identifier>* mutable_lane_id();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::Identifier>& _internal_lane_id() const;
  ::google::protobuf::RepeatedPtrField<::osi3::Identifier>* _internal_mutable_lane_id();
  public:
  const ::osi3::Identifier& lane_id(int index) const;
  ::osi3::Identifier* add_lane_id();
  const ::google::protobuf::RepeatedPtrField<::osi3::Identifier>& lane_id() const;
  // repeated .osi3.TrafficSign.SupplementarySign.Classification.Arrow.Direction direction = 2;
  int direction_size() const;
  private:
  int _internal_direction_size() const;

  public:
  void clear_direction() ;
  public:
  ::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction direction(int index) const;
  void set_direction(int index, ::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction value);
  void add_direction(::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction value);
  const ::google::protobuf::RepeatedField<int>& direction() const;
  ::google::protobuf::RepeatedField<int>* mutable_direction();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_direction() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_direction();

  public:
  // @@protoc_insertion_point(class_scope:osi3.TrafficSign.SupplementarySign.Classification.Arrow)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TrafficSign_SupplementarySign_Classification_Arrow& from_msg);
    ::google::protobuf::RepeatedPtrField< ::osi3::Identifier > lane_id_;
    ::google::protobuf::RepeatedField<int> direction_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ftrafficsign_2eproto;
};
// -------------------------------------------------------------------

class TrafficSign_SupplementarySign_Classification final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.TrafficSign.SupplementarySign.Classification) */ {
 public:
  inline TrafficSign_SupplementarySign_Classification() : TrafficSign_SupplementarySign_Classification(nullptr) {}
  ~TrafficSign_SupplementarySign_Classification() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrafficSign_SupplementarySign_Classification* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrafficSign_SupplementarySign_Classification));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficSign_SupplementarySign_Classification(
      ::google::protobuf::internal::ConstantInitialized);

  inline TrafficSign_SupplementarySign_Classification(const TrafficSign_SupplementarySign_Classification& from) : TrafficSign_SupplementarySign_Classification(nullptr, from) {}
  inline TrafficSign_SupplementarySign_Classification(TrafficSign_SupplementarySign_Classification&& from) noexcept
      : TrafficSign_SupplementarySign_Classification(nullptr, std::move(from)) {}
  inline TrafficSign_SupplementarySign_Classification& operator=(const TrafficSign_SupplementarySign_Classification& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_SupplementarySign_Classification& operator=(TrafficSign_SupplementarySign_Classification&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSign_SupplementarySign_Classification& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSign_SupplementarySign_Classification* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_SupplementarySign_Classification*>(
        &_TrafficSign_SupplementarySign_Classification_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(TrafficSign_SupplementarySign_Classification& a, TrafficSign_SupplementarySign_Classification& b) { a.Swap(&b); }
  inline void Swap(TrafficSign_SupplementarySign_Classification* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSign_SupplementarySign_Classification* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSign_SupplementarySign_Classification* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrafficSign_SupplementarySign_Classification>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficSign_SupplementarySign_Classification& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrafficSign_SupplementarySign_Classification& from) { TrafficSign_SupplementarySign_Classification::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrafficSign_SupplementarySign_Classification* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.TrafficSign.SupplementarySign.Classification"; }

 protected:
  explicit TrafficSign_SupplementarySign_Classification(::google::protobuf::Arena* arena);
  TrafficSign_SupplementarySign_Classification(::google::protobuf::Arena* arena, const TrafficSign_SupplementarySign_Classification& from);
  TrafficSign_SupplementarySign_Classification(::google::protobuf::Arena* arena, TrafficSign_SupplementarySign_Classification&& from) noexcept
      : TrafficSign_SupplementarySign_Classification(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Arrow = TrafficSign_SupplementarySign_Classification_Arrow;
  using Type = TrafficSign_SupplementarySign_Classification_Type;
  static constexpr Type TYPE_UNKNOWN = TrafficSign_SupplementarySign_Classification_Type_TYPE_UNKNOWN;
  static constexpr Type TYPE_OTHER = TrafficSign_SupplementarySign_Classification_Type_TYPE_OTHER;
  static constexpr Type TYPE_NO_SIGN = TrafficSign_SupplementarySign_Classification_Type_TYPE_NO_SIGN;
  static constexpr Type TYPE_TEXT = TrafficSign_SupplementarySign_Classification_Type_TYPE_TEXT;
  static constexpr Type TYPE_SPACE = TrafficSign_SupplementarySign_Classification_Type_TYPE_SPACE;
  static constexpr Type TYPE_TIME = TrafficSign_SupplementarySign_Classification_Type_TYPE_TIME;
  static constexpr Type TYPE_ARROW = TrafficSign_SupplementarySign_Classification_Type_TYPE_ARROW;
  static constexpr Type TYPE_CONSTRAINED_TO = TrafficSign_SupplementarySign_Classification_Type_TYPE_CONSTRAINED_TO;
  static constexpr Type TYPE_EXCEPT = TrafficSign_SupplementarySign_Classification_Type_TYPE_EXCEPT;
  static constexpr Type TYPE_VALID_FOR_DISTANCE = TrafficSign_SupplementarySign_Classification_Type_TYPE_VALID_FOR_DISTANCE;
  static constexpr Type TYPE_PRIORITY_ROAD_BOTTOM_LEFT_FOUR_WAY = TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_LEFT_FOUR_WAY;
  static constexpr Type TYPE_PRIORITY_ROAD_TOP_LEFT_FOUR_WAY = TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_TOP_LEFT_FOUR_WAY;
  static constexpr Type TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_STRAIGHT = TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_STRAIGHT;
  static constexpr Type TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_SIDEWAYS = TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_SIDEWAYS;
  static constexpr Type TYPE_PRIORITY_ROAD_TOP_LEFT_THREE_WAY_STRAIGHT = TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_TOP_LEFT_THREE_WAY_STRAIGHT;
  static constexpr Type TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_FOUR_WAY = TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_FOUR_WAY;
  static constexpr Type TYPE_PRIORITY_ROAD_TOP_RIGHT_FOUR_WAY = TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_TOP_RIGHT_FOUR_WAY;
  static constexpr Type TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_STRAIGHT = TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_STRAIGHT;
  static constexpr Type TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_SIDEWAY = TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_SIDEWAY;
  static constexpr Type TYPE_PRIORITY_ROAD_TOP_RIGHT_THREE_WAY_STRAIGHT = TrafficSign_SupplementarySign_Classification_Type_TYPE_PRIORITY_ROAD_TOP_RIGHT_THREE_WAY_STRAIGHT;
  static constexpr Type TYPE_VALID_IN_DISTANCE = TrafficSign_SupplementarySign_Classification_Type_TYPE_VALID_IN_DISTANCE;
  static constexpr Type TYPE_STOP_IN = TrafficSign_SupplementarySign_Classification_Type_TYPE_STOP_IN;
  static constexpr Type TYPE_LEFT_ARROW = TrafficSign_SupplementarySign_Classification_Type_TYPE_LEFT_ARROW;
  static constexpr Type TYPE_LEFT_BEND_ARROW = TrafficSign_SupplementarySign_Classification_Type_TYPE_LEFT_BEND_ARROW;
  static constexpr Type TYPE_RIGHT_ARROW = TrafficSign_SupplementarySign_Classification_Type_TYPE_RIGHT_ARROW;
  static constexpr Type TYPE_RIGHT_BEND_ARROW = TrafficSign_SupplementarySign_Classification_Type_TYPE_RIGHT_BEND_ARROW;
  static constexpr Type TYPE_ACCIDENT = TrafficSign_SupplementarySign_Classification_Type_TYPE_ACCIDENT;
  static constexpr Type TYPE_SNOW = TrafficSign_SupplementarySign_Classification_Type_TYPE_SNOW;
  static constexpr Type TYPE_FOG = TrafficSign_SupplementarySign_Classification_Type_TYPE_FOG;
  static constexpr Type TYPE_ROLLING_HIGHWAY_INFORMATION = TrafficSign_SupplementarySign_Classification_Type_TYPE_ROLLING_HIGHWAY_INFORMATION;
  static constexpr Type TYPE_SERVICES = TrafficSign_SupplementarySign_Classification_Type_TYPE_SERVICES;
  static constexpr Type TYPE_TIME_RANGE = TrafficSign_SupplementarySign_Classification_Type_TYPE_TIME_RANGE;
  static constexpr Type TYPE_PARKING_DISC_TIME_RESTRICTION = TrafficSign_SupplementarySign_Classification_Type_TYPE_PARKING_DISC_TIME_RESTRICTION;
  static constexpr Type TYPE_WEIGHT = TrafficSign_SupplementarySign_Classification_Type_TYPE_WEIGHT;
  static constexpr Type TYPE_WET = TrafficSign_SupplementarySign_Classification_Type_TYPE_WET;
  static constexpr Type TYPE_PARKING_CONSTRAINT = TrafficSign_SupplementarySign_Classification_Type_TYPE_PARKING_CONSTRAINT;
  static constexpr Type TYPE_NO_WAITING_SIDE_STRIPES = TrafficSign_SupplementarySign_Classification_Type_TYPE_NO_WAITING_SIDE_STRIPES;
  static constexpr Type TYPE_RAIN = TrafficSign_SupplementarySign_Classification_Type_TYPE_RAIN;
  static constexpr Type TYPE_SNOW_RAIN = TrafficSign_SupplementarySign_Classification_Type_TYPE_SNOW_RAIN;
  static constexpr Type TYPE_NIGHT = TrafficSign_SupplementarySign_Classification_Type_TYPE_NIGHT;
  static constexpr Type TYPE_STOP_4_WAY = TrafficSign_SupplementarySign_Classification_Type_TYPE_STOP_4_WAY;
  static constexpr Type TYPE_TRUCK = TrafficSign_SupplementarySign_Classification_Type_TYPE_TRUCK;
  static constexpr Type TYPE_TRACTORS_MAY_BE_PASSED = TrafficSign_SupplementarySign_Classification_Type_TYPE_TRACTORS_MAY_BE_PASSED;
  static constexpr Type TYPE_HAZARDOUS = TrafficSign_SupplementarySign_Classification_Type_TYPE_HAZARDOUS;
  static constexpr Type TYPE_TRAILER = TrafficSign_SupplementarySign_Classification_Type_TYPE_TRAILER;
  static constexpr Type TYPE_ZONE = TrafficSign_SupplementarySign_Classification_Type_TYPE_ZONE;
  static constexpr Type TYPE_MOTORCYCLE = TrafficSign_SupplementarySign_Classification_Type_TYPE_MOTORCYCLE;
  static constexpr Type TYPE_MOTORCYCLE_ALLOWED = TrafficSign_SupplementarySign_Classification_Type_TYPE_MOTORCYCLE_ALLOWED;
  static constexpr Type TYPE_CAR = TrafficSign_SupplementarySign_Classification_Type_TYPE_CAR;
  static inline bool Type_IsValid(int value) {
    return TrafficSign_SupplementarySign_Classification_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = TrafficSign_SupplementarySign_Classification_Type_Type_MIN;
  static constexpr Type Type_MAX = TrafficSign_SupplementarySign_Classification_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = TrafficSign_SupplementarySign_Classification_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return TrafficSign_SupplementarySign_Classification_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return TrafficSign_SupplementarySign_Classification_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return TrafficSign_SupplementarySign_Classification_Type_Parse(name, value);
  }
  using Actor = TrafficSign_SupplementarySign_Classification_Actor;
  static constexpr Actor ACTOR_UNKNOWN = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_UNKNOWN;
  static constexpr Actor ACTOR_OTHER = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_OTHER;
  static constexpr Actor ACTOR_NO_ACTOR = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_NO_ACTOR;
  static constexpr Actor ACTOR_AGRICULTURAL_VEHICLES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_AGRICULTURAL_VEHICLES;
  static constexpr Actor ACTOR_BICYCLES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_BICYCLES;
  static constexpr Actor ACTOR_BUSES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_BUSES;
  static constexpr Actor ACTOR_CAMPERS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CAMPERS;
  static constexpr Actor ACTOR_CARAVANS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CARAVANS;
  static constexpr Actor ACTOR_CARS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CARS;
  static constexpr Actor ACTOR_CARS_WITH_CARAVANS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CARS_WITH_CARAVANS;
  static constexpr Actor ACTOR_CARS_WITH_TRAILERS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CARS_WITH_TRAILERS;
  static constexpr Actor ACTOR_CATTLE = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CATTLE;
  static constexpr Actor ACTOR_CHILDREN = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CHILDREN;
  static constexpr Actor ACTOR_CONSTRUCTION_VEHICLES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_CONSTRUCTION_VEHICLES;
  static constexpr Actor ACTOR_DELIVERY_VEHICLES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_DELIVERY_VEHICLES;
  static constexpr Actor ACTOR_DISABLED_PERSONS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_DISABLED_PERSONS;
  static constexpr Actor ACTOR_EBIKES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_EBIKES;
  static constexpr Actor ACTOR_ELECTRIC_VEHICLES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_ELECTRIC_VEHICLES;
  static constexpr Actor ACTOR_EMERGENCY_VEHICLES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_EMERGENCY_VEHICLES;
  static constexpr Actor ACTOR_FERRY_USERS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_FERRY_USERS;
  static constexpr Actor ACTOR_FORESTRY_VEHICLES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_FORESTRY_VEHICLES;
  static constexpr Actor ACTOR_HAZARDOUS_GOODS_VEHICLES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_HAZARDOUS_GOODS_VEHICLES;
  static constexpr Actor ACTOR_HORSE_CARRIAGES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_HORSE_CARRIAGES;
  static constexpr Actor ACTOR_HORSE_RIDERS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_HORSE_RIDERS;
  static constexpr Actor ACTOR_INLINE_SKATERS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_INLINE_SKATERS;
  static constexpr Actor ACTOR_MEDICAL_VEHICLES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MEDICAL_VEHICLES;
  static constexpr Actor ACTOR_MILITARY_VEHICLES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MILITARY_VEHICLES;
  static constexpr Actor ACTOR_MOPEDS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MOPEDS;
  static constexpr Actor ACTOR_MOTORCYCLES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MOTORCYCLES;
  static constexpr Actor ACTOR_MOTORIZED_MULTITRACK_VEHICLES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_MOTORIZED_MULTITRACK_VEHICLES;
  static constexpr Actor ACTOR_OPERATIONAL_AND_UTILITY_VEHICLES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_OPERATIONAL_AND_UTILITY_VEHICLES;
  static constexpr Actor ACTOR_PEDESTRIANS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_PEDESTRIANS;
  static constexpr Actor ACTOR_PUBLIC_TRANSPORT_VEHICLES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_PUBLIC_TRANSPORT_VEHICLES;
  static constexpr Actor ACTOR_RAILROAD_TRAFFIC = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_RAILROAD_TRAFFIC;
  static constexpr Actor ACTOR_RESIDENTS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_RESIDENTS;
  static constexpr Actor ACTOR_SLURRY_TRANSPORT = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_SLURRY_TRANSPORT;
  static constexpr Actor ACTOR_TAXIS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TAXIS;
  static constexpr Actor ACTOR_TRACTORS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRACTORS;
  static constexpr Actor ACTOR_TRAILERS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRAILERS;
  static constexpr Actor ACTOR_TRAMS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRAMS;
  static constexpr Actor ACTOR_TRUCKS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRUCKS;
  static constexpr Actor ACTOR_TRUCKS_WITH_SEMITRAILERS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRUCKS_WITH_SEMITRAILERS;
  static constexpr Actor ACTOR_TRUCKS_WITH_TRAILERS = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_TRUCKS_WITH_TRAILERS;
  static constexpr Actor ACTOR_VEHICLES_WITH_GREEN_BADGES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_VEHICLES_WITH_GREEN_BADGES;
  static constexpr Actor ACTOR_VEHICLES_WITH_RED_BADGES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_VEHICLES_WITH_RED_BADGES;
  static constexpr Actor ACTOR_VEHICLES_WITH_YELLOW_BADGES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_VEHICLES_WITH_YELLOW_BADGES;
  static constexpr Actor ACTOR_WATER_POLLUTANT_VEHICLES = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_WATER_POLLUTANT_VEHICLES;
  static constexpr Actor ACTOR_WINTER_SPORTSPEOPLE = TrafficSign_SupplementarySign_Classification_Actor_ACTOR_WINTER_SPORTSPEOPLE;
  static inline bool Actor_IsValid(int value) {
    return TrafficSign_SupplementarySign_Classification_Actor_IsValid(value);
  }
  static constexpr Actor Actor_MIN = TrafficSign_SupplementarySign_Classification_Actor_Actor_MIN;
  static constexpr Actor Actor_MAX = TrafficSign_SupplementarySign_Classification_Actor_Actor_MAX;
  static constexpr int Actor_ARRAYSIZE = TrafficSign_SupplementarySign_Classification_Actor_Actor_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Actor_descriptor() {
    return TrafficSign_SupplementarySign_Classification_Actor_descriptor();
  }
  template <typename T>
  static inline const std::string& Actor_Name(T value) {
    return TrafficSign_SupplementarySign_Classification_Actor_Name(value);
  }
  static inline bool Actor_Parse(absl::string_view name, Actor* value) {
    return TrafficSign_SupplementarySign_Classification_Actor_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 3,
    kAssignedLaneIdFieldNumber = 4,
    kActorFieldNumber = 5,
    kArrowFieldNumber = 6,
    kLogicalLaneAssignmentFieldNumber = 12,
    kCountryFieldNumber = 8,
    kCountryRevisionFieldNumber = 9,
    kCodeFieldNumber = 10,
    kSubCodeFieldNumber = 11,
    kVariabilityFieldNumber = 1,
    kTypeFieldNumber = 2,
    kIsOutOfServiceFieldNumber = 7,
  };
  // repeated .osi3.TrafficSignValue value = 3;
  int value_size() const;
  private:
  int _internal_value_size() const;

  public:
  void clear_value() ;
  ::osi3::TrafficSignValue* mutable_value(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::TrafficSignValue>* mutable_value();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::TrafficSignValue>& _internal_value() const;
  ::google::protobuf::RepeatedPtrField<::osi3::TrafficSignValue>* _internal_mutable_value();
  public:
  const ::osi3::TrafficSignValue& value(int index) const;
  ::osi3::TrafficSignValue* add_value();
  const ::google::protobuf::RepeatedPtrField<::osi3::TrafficSignValue>& value() const;
  // repeated .osi3.Identifier assigned_lane_id = 4;
  int assigned_lane_id_size() const;
  private:
  int _internal_assigned_lane_id_size() const;

  public:
  void clear_assigned_lane_id() ;
  ::osi3::Identifier* mutable_assigned_lane_id(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::Identifier>* mutable_assigned_lane_id();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::Identifier>& _internal_assigned_lane_id() const;
  ::google::protobuf::RepeatedPtrField<::osi3::Identifier>* _internal_mutable_assigned_lane_id();
  public:
  const ::osi3::Identifier& assigned_lane_id(int index) const;
  ::osi3::Identifier* add_assigned_lane_id();
  const ::google::protobuf::RepeatedPtrField<::osi3::Identifier>& assigned_lane_id() const;
  // repeated .osi3.TrafficSign.SupplementarySign.Classification.Actor actor = 5;
  int actor_size() const;
  private:
  int _internal_actor_size() const;

  public:
  void clear_actor() ;
  public:
  ::osi3::TrafficSign_SupplementarySign_Classification_Actor actor(int index) const;
  void set_actor(int index, ::osi3::TrafficSign_SupplementarySign_Classification_Actor value);
  void add_actor(::osi3::TrafficSign_SupplementarySign_Classification_Actor value);
  const ::google::protobuf::RepeatedField<int>& actor() const;
  ::google::protobuf::RepeatedField<int>* mutable_actor();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_actor() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_actor();

  public:
  // repeated .osi3.TrafficSign.SupplementarySign.Classification.Arrow arrow = 6;
  int arrow_size() const;
  private:
  int _internal_arrow_size() const;

  public:
  void clear_arrow() ;
  ::osi3::TrafficSign_SupplementarySign_Classification_Arrow* mutable_arrow(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::TrafficSign_SupplementarySign_Classification_Arrow>* mutable_arrow();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::TrafficSign_SupplementarySign_Classification_Arrow>& _internal_arrow() const;
  ::google::protobuf::RepeatedPtrField<::osi3::TrafficSign_SupplementarySign_Classification_Arrow>* _internal_mutable_arrow();
  public:
  const ::osi3::TrafficSign_SupplementarySign_Classification_Arrow& arrow(int index) const;
  ::osi3::TrafficSign_SupplementarySign_Classification_Arrow* add_arrow();
  const ::google::protobuf::RepeatedPtrField<::osi3::TrafficSign_SupplementarySign_Classification_Arrow>& arrow() const;
  // repeated .osi3.LogicalLaneAssignment logical_lane_assignment = 12;
  int logical_lane_assignment_size() const;
  private:
  int _internal_logical_lane_assignment_size() const;

  public:
  void clear_logical_lane_assignment() ;
  ::osi3::LogicalLaneAssignment* mutable_logical_lane_assignment(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::LogicalLaneAssignment>* mutable_logical_lane_assignment();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::LogicalLaneAssignment>& _internal_logical_lane_assignment() const;
  ::google::protobuf::RepeatedPtrField<::osi3::LogicalLaneAssignment>* _internal_mutable_logical_lane_assignment();
  public:
  const ::osi3::LogicalLaneAssignment& logical_lane_assignment(int index) const;
  ::osi3::LogicalLaneAssignment* add_logical_lane_assignment();
  const ::google::protobuf::RepeatedPtrField<::osi3::LogicalLaneAssignment>& logical_lane_assignment() const;
  // optional string country = 8;
  bool has_country() const;
  void clear_country() ;
  const std::string& country() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_country(Arg_&& arg, Args_... args);
  std::string* mutable_country();
  PROTOBUF_NODISCARD std::string* release_country();
  void set_allocated_country(std::string* value);

  private:
  const std::string& _internal_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country(
      const std::string& value);
  std::string* _internal_mutable_country();

  public:
  // optional string country_revision = 9;
  bool has_country_revision() const;
  void clear_country_revision() ;
  const std::string& country_revision() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_country_revision(Arg_&& arg, Args_... args);
  std::string* mutable_country_revision();
  PROTOBUF_NODISCARD std::string* release_country_revision();
  void set_allocated_country_revision(std::string* value);

  private:
  const std::string& _internal_country_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_revision(
      const std::string& value);
  std::string* _internal_mutable_country_revision();

  public:
  // optional string code = 10;
  bool has_code() const;
  void clear_code() ;
  const std::string& code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code(Arg_&& arg, Args_... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* value);

  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(
      const std::string& value);
  std::string* _internal_mutable_code();

  public:
  // optional string sub_code = 11;
  bool has_sub_code() const;
  void clear_sub_code() ;
  const std::string& sub_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sub_code(Arg_&& arg, Args_... args);
  std::string* mutable_sub_code();
  PROTOBUF_NODISCARD std::string* release_sub_code();
  void set_allocated_sub_code(std::string* value);

  private:
  const std::string& _internal_sub_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sub_code(
      const std::string& value);
  std::string* _internal_mutable_sub_code();

  public:
  // optional .osi3.TrafficSign.Variability variability = 1;
  bool has_variability() const;
  void clear_variability() ;
  ::osi3::TrafficSign_Variability variability() const;
  void set_variability(::osi3::TrafficSign_Variability value);

  private:
  ::osi3::TrafficSign_Variability _internal_variability() const;
  void _internal_set_variability(::osi3::TrafficSign_Variability value);

  public:
  // optional .osi3.TrafficSign.SupplementarySign.Classification.Type type = 2;
  bool has_type() const;
  void clear_type() ;
  ::osi3::TrafficSign_SupplementarySign_Classification_Type type() const;
  void set_type(::osi3::TrafficSign_SupplementarySign_Classification_Type value);

  private:
  ::osi3::TrafficSign_SupplementarySign_Classification_Type _internal_type() const;
  void _internal_set_type(::osi3::TrafficSign_SupplementarySign_Classification_Type value);

  public:
  // optional bool is_out_of_service = 7;
  bool has_is_out_of_service() const;
  void clear_is_out_of_service() ;
  bool is_out_of_service() const;
  void set_is_out_of_service(bool value);

  private:
  bool _internal_is_out_of_service() const;
  void _internal_set_is_out_of_service(bool value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.TrafficSign.SupplementarySign.Classification)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 7,
      101, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TrafficSign_SupplementarySign_Classification& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::osi3::TrafficSignValue > value_;
    ::google::protobuf::RepeatedPtrField< ::osi3::Identifier > assigned_lane_id_;
    ::google::protobuf::RepeatedField<int> actor_;
    ::google::protobuf::RepeatedPtrField< ::osi3::TrafficSign_SupplementarySign_Classification_Arrow > arrow_;
    ::google::protobuf::RepeatedPtrField< ::osi3::LogicalLaneAssignment > logical_lane_assignment_;
    ::google::protobuf::internal::ArenaStringPtr country_;
    ::google::protobuf::internal::ArenaStringPtr country_revision_;
    ::google::protobuf::internal::ArenaStringPtr code_;
    ::google::protobuf::internal::ArenaStringPtr sub_code_;
    int variability_;
    int type_;
    bool is_out_of_service_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ftrafficsign_2eproto;
};
// -------------------------------------------------------------------

class TrafficSign_MainSign_Classification final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.TrafficSign.MainSign.Classification) */ {
 public:
  inline TrafficSign_MainSign_Classification() : TrafficSign_MainSign_Classification(nullptr) {}
  ~TrafficSign_MainSign_Classification() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrafficSign_MainSign_Classification* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrafficSign_MainSign_Classification));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficSign_MainSign_Classification(
      ::google::protobuf::internal::ConstantInitialized);

  inline TrafficSign_MainSign_Classification(const TrafficSign_MainSign_Classification& from) : TrafficSign_MainSign_Classification(nullptr, from) {}
  inline TrafficSign_MainSign_Classification(TrafficSign_MainSign_Classification&& from) noexcept
      : TrafficSign_MainSign_Classification(nullptr, std::move(from)) {}
  inline TrafficSign_MainSign_Classification& operator=(const TrafficSign_MainSign_Classification& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_MainSign_Classification& operator=(TrafficSign_MainSign_Classification&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSign_MainSign_Classification& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSign_MainSign_Classification* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_MainSign_Classification*>(
        &_TrafficSign_MainSign_Classification_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(TrafficSign_MainSign_Classification& a, TrafficSign_MainSign_Classification& b) { a.Swap(&b); }
  inline void Swap(TrafficSign_MainSign_Classification* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSign_MainSign_Classification* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSign_MainSign_Classification* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrafficSign_MainSign_Classification>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficSign_MainSign_Classification& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrafficSign_MainSign_Classification& from) { TrafficSign_MainSign_Classification::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrafficSign_MainSign_Classification* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.TrafficSign.MainSign.Classification"; }

 protected:
  explicit TrafficSign_MainSign_Classification(::google::protobuf::Arena* arena);
  TrafficSign_MainSign_Classification(::google::protobuf::Arena* arena, const TrafficSign_MainSign_Classification& from);
  TrafficSign_MainSign_Classification(::google::protobuf::Arena* arena, TrafficSign_MainSign_Classification&& from) noexcept
      : TrafficSign_MainSign_Classification(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = TrafficSign_MainSign_Classification_Type;
  static constexpr Type TYPE_UNKNOWN = TrafficSign_MainSign_Classification_Type_TYPE_UNKNOWN;
  static constexpr Type TYPE_OTHER = TrafficSign_MainSign_Classification_Type_TYPE_OTHER;
  static constexpr Type TYPE_DANGER_SPOT = TrafficSign_MainSign_Classification_Type_TYPE_DANGER_SPOT;
  static constexpr Type TYPE_ZEBRA_CROSSING = TrafficSign_MainSign_Classification_Type_TYPE_ZEBRA_CROSSING;
  static constexpr Type TYPE_FLIGHT = TrafficSign_MainSign_Classification_Type_TYPE_FLIGHT;
  static constexpr Type TYPE_CATTLE = TrafficSign_MainSign_Classification_Type_TYPE_CATTLE;
  static constexpr Type TYPE_HORSE_RIDERS = TrafficSign_MainSign_Classification_Type_TYPE_HORSE_RIDERS;
  static constexpr Type TYPE_AMPHIBIANS = TrafficSign_MainSign_Classification_Type_TYPE_AMPHIBIANS;
  static constexpr Type TYPE_FALLING_ROCKS = TrafficSign_MainSign_Classification_Type_TYPE_FALLING_ROCKS;
  static constexpr Type TYPE_SNOW_OR_ICE = TrafficSign_MainSign_Classification_Type_TYPE_SNOW_OR_ICE;
  static constexpr Type TYPE_LOOSE_GRAVEL = TrafficSign_MainSign_Classification_Type_TYPE_LOOSE_GRAVEL;
  static constexpr Type TYPE_WATERSIDE = TrafficSign_MainSign_Classification_Type_TYPE_WATERSIDE;
  static constexpr Type TYPE_CLEARANCE = TrafficSign_MainSign_Classification_Type_TYPE_CLEARANCE;
  static constexpr Type TYPE_MOVABLE_BRIDGE = TrafficSign_MainSign_Classification_Type_TYPE_MOVABLE_BRIDGE;
  static constexpr Type TYPE_RIGHT_BEFORE_LEFT_NEXT_INTERSECTION = TrafficSign_MainSign_Classification_Type_TYPE_RIGHT_BEFORE_LEFT_NEXT_INTERSECTION;
  static constexpr Type TYPE_TURN_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_TURN_LEFT;
  static constexpr Type TYPE_TURN_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_TURN_RIGHT;
  static constexpr Type TYPE_DOUBLE_TURN_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_DOUBLE_TURN_LEFT;
  static constexpr Type TYPE_DOUBLE_TURN_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_DOUBLE_TURN_RIGHT;
  static constexpr Type TYPE_HILL_DOWNWARDS = TrafficSign_MainSign_Classification_Type_TYPE_HILL_DOWNWARDS;
  static constexpr Type TYPE_HILL_UPWARDS = TrafficSign_MainSign_Classification_Type_TYPE_HILL_UPWARDS;
  static constexpr Type TYPE_UNEVEN_ROAD = TrafficSign_MainSign_Classification_Type_TYPE_UNEVEN_ROAD;
  static constexpr Type TYPE_ROAD_SLIPPERY_WET_OR_DIRTY = TrafficSign_MainSign_Classification_Type_TYPE_ROAD_SLIPPERY_WET_OR_DIRTY;
  static constexpr Type TYPE_SIDE_WINDS = TrafficSign_MainSign_Classification_Type_TYPE_SIDE_WINDS;
  static constexpr Type TYPE_ROAD_NARROWING = TrafficSign_MainSign_Classification_Type_TYPE_ROAD_NARROWING;
  static constexpr Type TYPE_ROAD_NARROWING_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_ROAD_NARROWING_RIGHT;
  static constexpr Type TYPE_ROAD_NARROWING_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_ROAD_NARROWING_LEFT;
  static constexpr Type TYPE_ROAD_WORKS = TrafficSign_MainSign_Classification_Type_TYPE_ROAD_WORKS;
  static constexpr Type TYPE_TRAFFIC_QUEUES = TrafficSign_MainSign_Classification_Type_TYPE_TRAFFIC_QUEUES;
  static constexpr Type TYPE_TWO_WAY_TRAFFIC = TrafficSign_MainSign_Classification_Type_TYPE_TWO_WAY_TRAFFIC;
  static constexpr Type TYPE_ATTENTION_TRAFFIC_LIGHT = TrafficSign_MainSign_Classification_Type_TYPE_ATTENTION_TRAFFIC_LIGHT;
  static constexpr Type TYPE_PEDESTRIANS = TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIANS;
  static constexpr Type TYPE_CHILDREN_CROSSING = TrafficSign_MainSign_Classification_Type_TYPE_CHILDREN_CROSSING;
  static constexpr Type TYPE_CYCLE_ROUTE = TrafficSign_MainSign_Classification_Type_TYPE_CYCLE_ROUTE;
  static constexpr Type TYPE_DEER_CROSSING = TrafficSign_MainSign_Classification_Type_TYPE_DEER_CROSSING;
  static constexpr Type TYPE_UNGATED_LEVEL_CROSSING = TrafficSign_MainSign_Classification_Type_TYPE_UNGATED_LEVEL_CROSSING;
  static constexpr Type TYPE_LEVEL_CROSSING_MARKER = TrafficSign_MainSign_Classification_Type_TYPE_LEVEL_CROSSING_MARKER;
  static constexpr Type TYPE_RAILWAY_TRAFFIC_PRIORITY = TrafficSign_MainSign_Classification_Type_TYPE_RAILWAY_TRAFFIC_PRIORITY;
  static constexpr Type TYPE_GIVE_WAY = TrafficSign_MainSign_Classification_Type_TYPE_GIVE_WAY;
  static constexpr Type TYPE_STOP = TrafficSign_MainSign_Classification_Type_TYPE_STOP;
  static constexpr Type TYPE_PRIORITY_TO_OPPOSITE_DIRECTION = TrafficSign_MainSign_Classification_Type_TYPE_PRIORITY_TO_OPPOSITE_DIRECTION;
  static constexpr Type TYPE_PRIORITY_TO_OPPOSITE_DIRECTION_UPSIDE_DOWN = TrafficSign_MainSign_Classification_Type_TYPE_PRIORITY_TO_OPPOSITE_DIRECTION_UPSIDE_DOWN;
  static constexpr Type TYPE_PRESCRIBED_LEFT_TURN = TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_TURN;
  static constexpr Type TYPE_PRESCRIBED_RIGHT_TURN = TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_RIGHT_TURN;
  static constexpr Type TYPE_PRESCRIBED_STRAIGHT = TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_STRAIGHT;
  static constexpr Type TYPE_PRESCRIBED_RIGHT_WAY = TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_RIGHT_WAY;
  static constexpr Type TYPE_PRESCRIBED_LEFT_WAY = TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_WAY;
  static constexpr Type TYPE_PRESCRIBED_RIGHT_TURN_AND_STRAIGHT = TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_RIGHT_TURN_AND_STRAIGHT;
  static constexpr Type TYPE_PRESCRIBED_LEFT_TURN_AND_STRAIGHT = TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_TURN_AND_STRAIGHT;
  static constexpr Type TYPE_PRESCRIBED_LEFT_TURN_AND_RIGHT_TURN = TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_TURN_AND_RIGHT_TURN;
  static constexpr Type TYPE_PRESCRIBED_LEFT_TURN_RIGHT_TURN_AND_STRAIGHT = TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_LEFT_TURN_RIGHT_TURN_AND_STRAIGHT;
  static constexpr Type TYPE_ROUNDABOUT = TrafficSign_MainSign_Classification_Type_TYPE_ROUNDABOUT;
  static constexpr Type TYPE_ONEWAY_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_ONEWAY_LEFT;
  static constexpr Type TYPE_ONEWAY_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_ONEWAY_RIGHT;
  static constexpr Type TYPE_PASS_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_PASS_LEFT;
  static constexpr Type TYPE_PASS_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_PASS_RIGHT;
  static constexpr Type TYPE_SIDE_LANE_OPEN_FOR_TRAFFIC = TrafficSign_MainSign_Classification_Type_TYPE_SIDE_LANE_OPEN_FOR_TRAFFIC;
  static constexpr Type TYPE_SIDE_LANE_CLOSED_FOR_TRAFFIC = TrafficSign_MainSign_Classification_Type_TYPE_SIDE_LANE_CLOSED_FOR_TRAFFIC;
  static constexpr Type TYPE_SIDE_LANE_CLOSING_FOR_TRAFFIC = TrafficSign_MainSign_Classification_Type_TYPE_SIDE_LANE_CLOSING_FOR_TRAFFIC;
  static constexpr Type TYPE_BUS_STOP = TrafficSign_MainSign_Classification_Type_TYPE_BUS_STOP;
  static constexpr Type TYPE_TAXI_STAND = TrafficSign_MainSign_Classification_Type_TYPE_TAXI_STAND;
  static constexpr Type TYPE_BICYCLES_ONLY = TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_ONLY;
  static constexpr Type TYPE_HORSE_RIDERS_ONLY = TrafficSign_MainSign_Classification_Type_TYPE_HORSE_RIDERS_ONLY;
  static constexpr Type TYPE_PEDESTRIANS_ONLY = TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIANS_ONLY;
  static constexpr Type TYPE_BICYCLES_PEDESTRIANS_SHARED_ONLY = TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_PEDESTRIANS_SHARED_ONLY;
  static constexpr Type TYPE_BICYCLES_PEDESTRIANS_SEPARATED_LEFT_ONLY = TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_PEDESTRIANS_SEPARATED_LEFT_ONLY;
  static constexpr Type TYPE_BICYCLES_PEDESTRIANS_SEPARATED_RIGHT_ONLY = TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_PEDESTRIANS_SEPARATED_RIGHT_ONLY;
  static constexpr Type TYPE_PEDESTRIAN_ZONE_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIAN_ZONE_BEGIN;
  static constexpr Type TYPE_PEDESTRIAN_ZONE_END = TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIAN_ZONE_END;
  static constexpr Type TYPE_BICYCLE_ROAD_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_BICYCLE_ROAD_BEGIN;
  static constexpr Type TYPE_BICYCLE_ROAD_END = TrafficSign_MainSign_Classification_Type_TYPE_BICYCLE_ROAD_END;
  static constexpr Type TYPE_BUS_LANE = TrafficSign_MainSign_Classification_Type_TYPE_BUS_LANE;
  static constexpr Type TYPE_BUS_LANE_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_BUS_LANE_BEGIN;
  static constexpr Type TYPE_BUS_LANE_END = TrafficSign_MainSign_Classification_Type_TYPE_BUS_LANE_END;
  static constexpr Type TYPE_ALL_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_ALL_PROHIBITED;
  static constexpr Type TYPE_MOTORIZED_MULTITRACK_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_MOTORIZED_MULTITRACK_PROHIBITED;
  static constexpr Type TYPE_TRUCKS_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_TRUCKS_PROHIBITED;
  static constexpr Type TYPE_BICYCLES_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_BICYCLES_PROHIBITED;
  static constexpr Type TYPE_MOTORCYCLES_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_MOTORCYCLES_PROHIBITED;
  static constexpr Type TYPE_MOPEDS_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_MOPEDS_PROHIBITED;
  static constexpr Type TYPE_HORSE_RIDERS_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_HORSE_RIDERS_PROHIBITED;
  static constexpr Type TYPE_HORSE_CARRIAGES_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_HORSE_CARRIAGES_PROHIBITED;
  static constexpr Type TYPE_CATTLE_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_CATTLE_PROHIBITED;
  static constexpr Type TYPE_BUSES_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_BUSES_PROHIBITED;
  static constexpr Type TYPE_CARS_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_CARS_PROHIBITED;
  static constexpr Type TYPE_CARS_TRAILERS_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_CARS_TRAILERS_PROHIBITED;
  static constexpr Type TYPE_TRUCKS_TRAILERS_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_TRUCKS_TRAILERS_PROHIBITED;
  static constexpr Type TYPE_TRACTORS_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_TRACTORS_PROHIBITED;
  static constexpr Type TYPE_PEDESTRIANS_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIANS_PROHIBITED;
  static constexpr Type TYPE_MOTOR_VEHICLES_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_MOTOR_VEHICLES_PROHIBITED;
  static constexpr Type TYPE_HAZARDOUS_GOODS_VEHICLES_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_HAZARDOUS_GOODS_VEHICLES_PROHIBITED;
  static constexpr Type TYPE_OVER_WEIGHT_VEHICLES_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_OVER_WEIGHT_VEHICLES_PROHIBITED;
  static constexpr Type TYPE_VEHICLES_AXLE_OVER_WEIGHT_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_VEHICLES_AXLE_OVER_WEIGHT_PROHIBITED;
  static constexpr Type TYPE_VEHICLES_EXCESS_WIDTH_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_VEHICLES_EXCESS_WIDTH_PROHIBITED;
  static constexpr Type TYPE_VEHICLES_EXCESS_HEIGHT_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_VEHICLES_EXCESS_HEIGHT_PROHIBITED;
  static constexpr Type TYPE_VEHICLES_EXCESS_LENGTH_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_VEHICLES_EXCESS_LENGTH_PROHIBITED;
  static constexpr Type TYPE_DO_NOT_ENTER = TrafficSign_MainSign_Classification_Type_TYPE_DO_NOT_ENTER;
  static constexpr Type TYPE_SNOW_CHAINS_REQUIRED = TrafficSign_MainSign_Classification_Type_TYPE_SNOW_CHAINS_REQUIRED;
  static constexpr Type TYPE_WATER_POLLUTANT_VEHICLES_PROHIBITED = TrafficSign_MainSign_Classification_Type_TYPE_WATER_POLLUTANT_VEHICLES_PROHIBITED;
  static constexpr Type TYPE_ENVIRONMENTAL_ZONE_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_ENVIRONMENTAL_ZONE_BEGIN;
  static constexpr Type TYPE_ENVIRONMENTAL_ZONE_END = TrafficSign_MainSign_Classification_Type_TYPE_ENVIRONMENTAL_ZONE_END;
  static constexpr Type TYPE_NO_U_TURN_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_NO_U_TURN_LEFT;
  static constexpr Type TYPE_NO_U_TURN_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_NO_U_TURN_RIGHT;
  static constexpr Type TYPE_PRESCRIBED_U_TURN_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_U_TURN_LEFT;
  static constexpr Type TYPE_PRESCRIBED_U_TURN_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_PRESCRIBED_U_TURN_RIGHT;
  static constexpr Type TYPE_MINIMUM_DISTANCE_FOR_TRUCKS = TrafficSign_MainSign_Classification_Type_TYPE_MINIMUM_DISTANCE_FOR_TRUCKS;
  static constexpr Type TYPE_SPEED_LIMIT_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_SPEED_LIMIT_BEGIN;
  static constexpr Type TYPE_SPEED_LIMIT_ZONE_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_SPEED_LIMIT_ZONE_BEGIN;
  static constexpr Type TYPE_SPEED_LIMIT_ZONE_END = TrafficSign_MainSign_Classification_Type_TYPE_SPEED_LIMIT_ZONE_END;
  static constexpr Type TYPE_MINIMUM_SPEED_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_MINIMUM_SPEED_BEGIN;
  static constexpr Type TYPE_OVERTAKING_BAN_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_OVERTAKING_BAN_BEGIN;
  static constexpr Type TYPE_OVERTAKING_BAN_FOR_TRUCKS_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_OVERTAKING_BAN_FOR_TRUCKS_BEGIN;
  static constexpr Type TYPE_SPEED_LIMIT_END = TrafficSign_MainSign_Classification_Type_TYPE_SPEED_LIMIT_END;
  static constexpr Type TYPE_MINIMUM_SPEED_END = TrafficSign_MainSign_Classification_Type_TYPE_MINIMUM_SPEED_END;
  static constexpr Type TYPE_OVERTAKING_BAN_END = TrafficSign_MainSign_Classification_Type_TYPE_OVERTAKING_BAN_END;
  static constexpr Type TYPE_OVERTAKING_BAN_FOR_TRUCKS_END = TrafficSign_MainSign_Classification_Type_TYPE_OVERTAKING_BAN_FOR_TRUCKS_END;
  static constexpr Type TYPE_ALL_RESTRICTIONS_END = TrafficSign_MainSign_Classification_Type_TYPE_ALL_RESTRICTIONS_END;
  static constexpr Type TYPE_NO_STOPPING = TrafficSign_MainSign_Classification_Type_TYPE_NO_STOPPING;
  static constexpr Type TYPE_NO_PARKING = TrafficSign_MainSign_Classification_Type_TYPE_NO_PARKING;
  static constexpr Type TYPE_NO_PARKING_ZONE_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_NO_PARKING_ZONE_BEGIN;
  static constexpr Type TYPE_NO_PARKING_ZONE_END = TrafficSign_MainSign_Classification_Type_TYPE_NO_PARKING_ZONE_END;
  static constexpr Type TYPE_RIGHT_OF_WAY_NEXT_INTERSECTION = TrafficSign_MainSign_Classification_Type_TYPE_RIGHT_OF_WAY_NEXT_INTERSECTION;
  static constexpr Type TYPE_RIGHT_OF_WAY_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_RIGHT_OF_WAY_BEGIN;
  static constexpr Type TYPE_RIGHT_OF_WAY_END = TrafficSign_MainSign_Classification_Type_TYPE_RIGHT_OF_WAY_END;
  static constexpr Type TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION = TrafficSign_MainSign_Classification_Type_TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION;
  static constexpr Type TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION_UPSIDE_DOWN = TrafficSign_MainSign_Classification_Type_TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION_UPSIDE_DOWN;
  static constexpr Type TYPE_TOWN_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_TOWN_BEGIN;
  static constexpr Type TYPE_TOWN_END = TrafficSign_MainSign_Classification_Type_TYPE_TOWN_END;
  static constexpr Type TYPE_CAR_PARKING = TrafficSign_MainSign_Classification_Type_TYPE_CAR_PARKING;
  static constexpr Type TYPE_CAR_PARKING_ZONE_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_CAR_PARKING_ZONE_BEGIN;
  static constexpr Type TYPE_CAR_PARKING_ZONE_END = TrafficSign_MainSign_Classification_Type_TYPE_CAR_PARKING_ZONE_END;
  static constexpr Type TYPE_SIDEWALK_HALF_PARKING_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_HALF_PARKING_LEFT;
  static constexpr Type TYPE_SIDEWALK_HALF_PARKING_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_HALF_PARKING_RIGHT;
  static constexpr Type TYPE_SIDEWALK_PARKING_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PARKING_LEFT;
  static constexpr Type TYPE_SIDEWALK_PARKING_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PARKING_RIGHT;
  static constexpr Type TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_LEFT;
  static constexpr Type TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_RIGHT;
  static constexpr Type TYPE_SIDEWALK_PERPENDICULAR_PARKING_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PERPENDICULAR_PARKING_LEFT;
  static constexpr Type TYPE_SIDEWALK_PERPENDICULAR_PARKING_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_SIDEWALK_PERPENDICULAR_PARKING_RIGHT;
  static constexpr Type TYPE_LIVING_STREET_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_LIVING_STREET_BEGIN;
  static constexpr Type TYPE_LIVING_STREET_END = TrafficSign_MainSign_Classification_Type_TYPE_LIVING_STREET_END;
  static constexpr Type TYPE_TUNNEL = TrafficSign_MainSign_Classification_Type_TYPE_TUNNEL;
  static constexpr Type TYPE_EMERGENCY_STOPPING_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_EMERGENCY_STOPPING_LEFT;
  static constexpr Type TYPE_EMERGENCY_STOPPING_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_EMERGENCY_STOPPING_RIGHT;
  static constexpr Type TYPE_HIGHWAY_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_BEGIN;
  static constexpr Type TYPE_HIGHWAY_END = TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_END;
  static constexpr Type TYPE_EXPRESSWAY_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_EXPRESSWAY_BEGIN;
  static constexpr Type TYPE_EXPRESSWAY_END = TrafficSign_MainSign_Classification_Type_TYPE_EXPRESSWAY_END;
  static constexpr Type TYPE_NAMED_HIGHWAY_EXIT = TrafficSign_MainSign_Classification_Type_TYPE_NAMED_HIGHWAY_EXIT;
  static constexpr Type TYPE_NAMED_EXPRESSWAY_EXIT = TrafficSign_MainSign_Classification_Type_TYPE_NAMED_EXPRESSWAY_EXIT;
  static constexpr Type TYPE_NAMED_ROAD_EXIT = TrafficSign_MainSign_Classification_Type_TYPE_NAMED_ROAD_EXIT;
  static constexpr Type TYPE_HIGHWAY_EXIT = TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_EXIT;
  static constexpr Type TYPE_EXPRESSWAY_EXIT = TrafficSign_MainSign_Classification_Type_TYPE_EXPRESSWAY_EXIT;
  static constexpr Type TYPE_ONEWAY_STREET = TrafficSign_MainSign_Classification_Type_TYPE_ONEWAY_STREET;
  static constexpr Type TYPE_CROSSING_GUARDS = TrafficSign_MainSign_Classification_Type_TYPE_CROSSING_GUARDS;
  static constexpr Type TYPE_DEADEND = TrafficSign_MainSign_Classification_Type_TYPE_DEADEND;
  static constexpr Type TYPE_DEADEND_EXCLUDING_DESIGNATED_ACTORS = TrafficSign_MainSign_Classification_Type_TYPE_DEADEND_EXCLUDING_DESIGNATED_ACTORS;
  static constexpr Type TYPE_FIRST_AID_STATION = TrafficSign_MainSign_Classification_Type_TYPE_FIRST_AID_STATION;
  static constexpr Type TYPE_POLICE_STATION = TrafficSign_MainSign_Classification_Type_TYPE_POLICE_STATION;
  static constexpr Type TYPE_TELEPHONE = TrafficSign_MainSign_Classification_Type_TYPE_TELEPHONE;
  static constexpr Type TYPE_FILLING_STATION = TrafficSign_MainSign_Classification_Type_TYPE_FILLING_STATION;
  static constexpr Type TYPE_HOTEL = TrafficSign_MainSign_Classification_Type_TYPE_HOTEL;
  static constexpr Type TYPE_INN = TrafficSign_MainSign_Classification_Type_TYPE_INN;
  static constexpr Type TYPE_KIOSK = TrafficSign_MainSign_Classification_Type_TYPE_KIOSK;
  static constexpr Type TYPE_TOILET = TrafficSign_MainSign_Classification_Type_TYPE_TOILET;
  static constexpr Type TYPE_CHAPEL = TrafficSign_MainSign_Classification_Type_TYPE_CHAPEL;
  static constexpr Type TYPE_TOURIST_INFO = TrafficSign_MainSign_Classification_Type_TYPE_TOURIST_INFO;
  static constexpr Type TYPE_REPAIR_SERVICE = TrafficSign_MainSign_Classification_Type_TYPE_REPAIR_SERVICE;
  static constexpr Type TYPE_PEDESTRIAN_UNDERPASS = TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIAN_UNDERPASS;
  static constexpr Type TYPE_PEDESTRIAN_BRIDGE = TrafficSign_MainSign_Classification_Type_TYPE_PEDESTRIAN_BRIDGE;
  static constexpr Type TYPE_CAMPER_PLACE = TrafficSign_MainSign_Classification_Type_TYPE_CAMPER_PLACE;
  static constexpr Type TYPE_ADVISORY_SPEED_LIMIT_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_ADVISORY_SPEED_LIMIT_BEGIN;
  static constexpr Type TYPE_ADVISORY_SPEED_LIMIT_END = TrafficSign_MainSign_Classification_Type_TYPE_ADVISORY_SPEED_LIMIT_END;
  static constexpr Type TYPE_PLACE_NAME = TrafficSign_MainSign_Classification_Type_TYPE_PLACE_NAME;
  static constexpr Type TYPE_TOURIST_ATTRACTION = TrafficSign_MainSign_Classification_Type_TYPE_TOURIST_ATTRACTION;
  static constexpr Type TYPE_TOURIST_ROUTE = TrafficSign_MainSign_Classification_Type_TYPE_TOURIST_ROUTE;
  static constexpr Type TYPE_TOURIST_AREA = TrafficSign_MainSign_Classification_Type_TYPE_TOURIST_AREA;
  static constexpr Type TYPE_SHOULDER_NOT_PASSABLE_MOTOR_VEHICLES = TrafficSign_MainSign_Classification_Type_TYPE_SHOULDER_NOT_PASSABLE_MOTOR_VEHICLES;
  static constexpr Type TYPE_SHOULDER_UNSAFE_TRUCKS_TRACTORS = TrafficSign_MainSign_Classification_Type_TYPE_SHOULDER_UNSAFE_TRUCKS_TRACTORS;
  static constexpr Type TYPE_TOLL_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_TOLL_BEGIN;
  static constexpr Type TYPE_TOLL_END = TrafficSign_MainSign_Classification_Type_TYPE_TOLL_END;
  static constexpr Type TYPE_TOLL_ROAD = TrafficSign_MainSign_Classification_Type_TYPE_TOLL_ROAD;
  static constexpr Type TYPE_CUSTOMS = TrafficSign_MainSign_Classification_Type_TYPE_CUSTOMS;
  static constexpr Type TYPE_INTERNATIONAL_BORDER_INFO = TrafficSign_MainSign_Classification_Type_TYPE_INTERNATIONAL_BORDER_INFO;
  static constexpr Type TYPE_STREETLIGHT_RED_BAND = TrafficSign_MainSign_Classification_Type_TYPE_STREETLIGHT_RED_BAND;
  static constexpr Type TYPE_FEDERAL_HIGHWAY_ROUTE_NUMBER = TrafficSign_MainSign_Classification_Type_TYPE_FEDERAL_HIGHWAY_ROUTE_NUMBER;
  static constexpr Type TYPE_HIGHWAY_ROUTE_NUMBER = TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_ROUTE_NUMBER;
  static constexpr Type TYPE_HIGHWAY_INTERCHANGE_NUMBER = TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_INTERCHANGE_NUMBER;
  static constexpr Type TYPE_EUROPEAN_ROUTE_NUMBER = TrafficSign_MainSign_Classification_Type_TYPE_EUROPEAN_ROUTE_NUMBER;
  static constexpr Type TYPE_FEDERAL_HIGHWAY_DIRECTION_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_FEDERAL_HIGHWAY_DIRECTION_LEFT;
  static constexpr Type TYPE_FEDERAL_HIGHWAY_DIRECTION_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_FEDERAL_HIGHWAY_DIRECTION_RIGHT;
  static constexpr Type TYPE_PRIMARY_ROAD_DIRECTION_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_PRIMARY_ROAD_DIRECTION_LEFT;
  static constexpr Type TYPE_PRIMARY_ROAD_DIRECTION_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_PRIMARY_ROAD_DIRECTION_RIGHT;
  static constexpr Type TYPE_SECONDARY_ROAD_DIRECTION_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_SECONDARY_ROAD_DIRECTION_LEFT;
  static constexpr Type TYPE_SECONDARY_ROAD_DIRECTION_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_SECONDARY_ROAD_DIRECTION_RIGHT;
  static constexpr Type TYPE_DIRECTION_DESIGNATED_ACTORS_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_DESIGNATED_ACTORS_LEFT;
  static constexpr Type TYPE_DIRECTION_DESIGNATED_ACTORS_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_DESIGNATED_ACTORS_RIGHT;
  static constexpr Type TYPE_ROUTING_DESIGNATED_ACTORS = TrafficSign_MainSign_Classification_Type_TYPE_ROUTING_DESIGNATED_ACTORS;
  static constexpr Type TYPE_DIRECTION_TO_HIGHWAY_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_TO_HIGHWAY_LEFT;
  static constexpr Type TYPE_DIRECTION_TO_HIGHWAY_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_TO_HIGHWAY_RIGHT;
  static constexpr Type TYPE_DIRECTION_TO_LOCAL_DESTINATION_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_TO_LOCAL_DESTINATION_LEFT;
  static constexpr Type TYPE_DIRECTION_TO_LOCAL_DESTINATION_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_TO_LOCAL_DESTINATION_RIGHT;
  static constexpr Type TYPE_CONSOLIDATED_DIRECTIONS = TrafficSign_MainSign_Classification_Type_TYPE_CONSOLIDATED_DIRECTIONS;
  static constexpr Type TYPE_STREET_NAME = TrafficSign_MainSign_Classification_Type_TYPE_STREET_NAME;
  static constexpr Type TYPE_DIRECTION_PREANNOUNCEMENT = TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_PREANNOUNCEMENT;
  static constexpr Type TYPE_DIRECTION_PREANNOUNCEMENT_LANE_CONFIG = TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_PREANNOUNCEMENT_LANE_CONFIG;
  static constexpr Type TYPE_DIRECTION_PREANNOUNCEMENT_HIGHWAY_ENTRIES = TrafficSign_MainSign_Classification_Type_TYPE_DIRECTION_PREANNOUNCEMENT_HIGHWAY_ENTRIES;
  static constexpr Type TYPE_HIGHWAY_ANNOUNCEMENT = TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_ANNOUNCEMENT;
  static constexpr Type TYPE_OTHER_ROAD_ANNOUNCEMENT = TrafficSign_MainSign_Classification_Type_TYPE_OTHER_ROAD_ANNOUNCEMENT;
  static constexpr Type TYPE_HIGHWAY_ANNOUNCEMENT_TRUCK_STOP = TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_ANNOUNCEMENT_TRUCK_STOP;
  static constexpr Type TYPE_HIGHWAY_PREANNOUNCEMENT_DIRECTIONS = TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_PREANNOUNCEMENT_DIRECTIONS;
  static constexpr Type TYPE_POLE_EXIT = TrafficSign_MainSign_Classification_Type_TYPE_POLE_EXIT;
  static constexpr Type TYPE_HIGHWAY_DISTANCE_BOARD = TrafficSign_MainSign_Classification_Type_TYPE_HIGHWAY_DISTANCE_BOARD;
  static constexpr Type TYPE_DETOUR_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_LEFT;
  static constexpr Type TYPE_DETOUR_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_RIGHT;
  static constexpr Type TYPE_NUMBERED_DETOUR = TrafficSign_MainSign_Classification_Type_TYPE_NUMBERED_DETOUR;
  static constexpr Type TYPE_DETOUR_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_BEGIN;
  static constexpr Type TYPE_DETOUR_END = TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_END;
  static constexpr Type TYPE_DETOUR_ROUTING_BOARD = TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_ROUTING_BOARD;
  static constexpr Type TYPE_OPTIONAL_DETOUR = TrafficSign_MainSign_Classification_Type_TYPE_OPTIONAL_DETOUR;
  static constexpr Type TYPE_OPTIONAL_DETOUR_ROUTING = TrafficSign_MainSign_Classification_Type_TYPE_OPTIONAL_DETOUR_ROUTING;
  static constexpr Type TYPE_ROUTE_RECOMMENDATION = TrafficSign_MainSign_Classification_Type_TYPE_ROUTE_RECOMMENDATION;
  static constexpr Type TYPE_ROUTE_RECOMMENDATION_END = TrafficSign_MainSign_Classification_Type_TYPE_ROUTE_RECOMMENDATION_END;
  static constexpr Type TYPE_ANNOUNCE_LANE_TRANSITION_LEFT = TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LANE_TRANSITION_LEFT;
  static constexpr Type TYPE_ANNOUNCE_LANE_TRANSITION_RIGHT = TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LANE_TRANSITION_RIGHT;
  static constexpr Type TYPE_ANNOUNCE_RIGHT_LANE_END = TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_RIGHT_LANE_END;
  static constexpr Type TYPE_ANNOUNCE_LEFT_LANE_END = TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LEFT_LANE_END;
  static constexpr Type TYPE_ANNOUNCE_RIGHT_LANE_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_RIGHT_LANE_BEGIN;
  static constexpr Type TYPE_ANNOUNCE_LEFT_LANE_BEGIN = TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LEFT_LANE_BEGIN;
  static constexpr Type TYPE_ANNOUNCE_LANE_CONSOLIDATION = TrafficSign_MainSign_Classification_Type_TYPE_ANNOUNCE_LANE_CONSOLIDATION;
  static constexpr Type TYPE_DETOUR_CITY_BLOCK = TrafficSign_MainSign_Classification_Type_TYPE_DETOUR_CITY_BLOCK;
  static constexpr Type TYPE_GATE = TrafficSign_MainSign_Classification_Type_TYPE_GATE;
  static constexpr Type TYPE_POLE_WARNING = TrafficSign_MainSign_Classification_Type_TYPE_POLE_WARNING;
  static constexpr Type TYPE_TRAFFIC_CONE = TrafficSign_MainSign_Classification_Type_TYPE_TRAFFIC_CONE;
  static constexpr Type TYPE_MOBILE_LANE_CLOSURE = TrafficSign_MainSign_Classification_Type_TYPE_MOBILE_LANE_CLOSURE;
  static constexpr Type TYPE_REFLECTOR_POST = TrafficSign_MainSign_Classification_Type_TYPE_REFLECTOR_POST;
  static constexpr Type TYPE_DIRECTIONAL_BOARD_WARNING = TrafficSign_MainSign_Classification_Type_TYPE_DIRECTIONAL_BOARD_WARNING;
  static constexpr Type TYPE_GUIDING_PLATE = TrafficSign_MainSign_Classification_Type_TYPE_GUIDING_PLATE;
  static constexpr Type TYPE_GUIDING_PLATE_WEDGES = TrafficSign_MainSign_Classification_Type_TYPE_GUIDING_PLATE_WEDGES;
  static constexpr Type TYPE_PARKING_HAZARD = TrafficSign_MainSign_Classification_Type_TYPE_PARKING_HAZARD;
  static constexpr Type TYPE_TRAFFIC_LIGHT_GREEN_ARROW = TrafficSign_MainSign_Classification_Type_TYPE_TRAFFIC_LIGHT_GREEN_ARROW;
  static inline bool Type_IsValid(int value) {
    return TrafficSign_MainSign_Classification_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = TrafficSign_MainSign_Classification_Type_Type_MIN;
  static constexpr Type Type_MAX = TrafficSign_MainSign_Classification_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = TrafficSign_MainSign_Classification_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return TrafficSign_MainSign_Classification_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return TrafficSign_MainSign_Classification_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return TrafficSign_MainSign_Classification_Type_Parse(name, value);
  }
  using DirectionScope = TrafficSign_MainSign_Classification_DirectionScope;
  static constexpr DirectionScope DIRECTION_SCOPE_UNKNOWN = TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_UNKNOWN;
  static constexpr DirectionScope DIRECTION_SCOPE_OTHER = TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_OTHER;
  static constexpr DirectionScope DIRECTION_SCOPE_NO_DIRECTION = TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_NO_DIRECTION;
  static constexpr DirectionScope DIRECTION_SCOPE_LEFT = TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_LEFT;
  static constexpr DirectionScope DIRECTION_SCOPE_RIGHT = TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_RIGHT;
  static constexpr DirectionScope DIRECTION_SCOPE_LEFT_RIGHT = TrafficSign_MainSign_Classification_DirectionScope_DIRECTION_SCOPE_LEFT_RIGHT;
  static inline bool DirectionScope_IsValid(int value) {
    return TrafficSign_MainSign_Classification_DirectionScope_IsValid(value);
  }
  static constexpr DirectionScope DirectionScope_MIN = TrafficSign_MainSign_Classification_DirectionScope_DirectionScope_MIN;
  static constexpr DirectionScope DirectionScope_MAX = TrafficSign_MainSign_Classification_DirectionScope_DirectionScope_MAX;
  static constexpr int DirectionScope_ARRAYSIZE = TrafficSign_MainSign_Classification_DirectionScope_DirectionScope_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DirectionScope_descriptor() {
    return TrafficSign_MainSign_Classification_DirectionScope_descriptor();
  }
  template <typename T>
  static inline const std::string& DirectionScope_Name(T value) {
    return TrafficSign_MainSign_Classification_DirectionScope_Name(value);
  }
  static inline bool DirectionScope_Parse(absl::string_view name, DirectionScope* value) {
    return TrafficSign_MainSign_Classification_DirectionScope_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kAssignedLaneIdFieldNumber = 5,
    kLogicalLaneAssignmentFieldNumber = 12,
    kCountryFieldNumber = 8,
    kCountryRevisionFieldNumber = 9,
    kCodeFieldNumber = 10,
    kSubCodeFieldNumber = 11,
    kValueFieldNumber = 3,
    kVariabilityFieldNumber = 1,
    kTypeFieldNumber = 2,
    kDirectionScopeFieldNumber = 4,
    kVerticallyMirroredFieldNumber = 6,
    kIsOutOfServiceFieldNumber = 7,
  };
  // repeated .osi3.Identifier assigned_lane_id = 5;
  int assigned_lane_id_size() const;
  private:
  int _internal_assigned_lane_id_size() const;

  public:
  void clear_assigned_lane_id() ;
  ::osi3::Identifier* mutable_assigned_lane_id(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::Identifier>* mutable_assigned_lane_id();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::Identifier>& _internal_assigned_lane_id() const;
  ::google::protobuf::RepeatedPtrField<::osi3::Identifier>* _internal_mutable_assigned_lane_id();
  public:
  const ::osi3::Identifier& assigned_lane_id(int index) const;
  ::osi3::Identifier* add_assigned_lane_id();
  const ::google::protobuf::RepeatedPtrField<::osi3::Identifier>& assigned_lane_id() const;
  // repeated .osi3.LogicalLaneAssignment logical_lane_assignment = 12;
  int logical_lane_assignment_size() const;
  private:
  int _internal_logical_lane_assignment_size() const;

  public:
  void clear_logical_lane_assignment() ;
  ::osi3::LogicalLaneAssignment* mutable_logical_lane_assignment(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::LogicalLaneAssignment>* mutable_logical_lane_assignment();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::LogicalLaneAssignment>& _internal_logical_lane_assignment() const;
  ::google::protobuf::RepeatedPtrField<::osi3::LogicalLaneAssignment>* _internal_mutable_logical_lane_assignment();
  public:
  const ::osi3::LogicalLaneAssignment& logical_lane_assignment(int index) const;
  ::osi3::LogicalLaneAssignment* add_logical_lane_assignment();
  const ::google::protobuf::RepeatedPtrField<::osi3::LogicalLaneAssignment>& logical_lane_assignment() const;
  // optional string country = 8;
  bool has_country() const;
  void clear_country() ;
  const std::string& country() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_country(Arg_&& arg, Args_... args);
  std::string* mutable_country();
  PROTOBUF_NODISCARD std::string* release_country();
  void set_allocated_country(std::string* value);

  private:
  const std::string& _internal_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country(
      const std::string& value);
  std::string* _internal_mutable_country();

  public:
  // optional string country_revision = 9;
  bool has_country_revision() const;
  void clear_country_revision() ;
  const std::string& country_revision() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_country_revision(Arg_&& arg, Args_... args);
  std::string* mutable_country_revision();
  PROTOBUF_NODISCARD std::string* release_country_revision();
  void set_allocated_country_revision(std::string* value);

  private:
  const std::string& _internal_country_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_revision(
      const std::string& value);
  std::string* _internal_mutable_country_revision();

  public:
  // optional string code = 10;
  bool has_code() const;
  void clear_code() ;
  const std::string& code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code(Arg_&& arg, Args_... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* value);

  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(
      const std::string& value);
  std::string* _internal_mutable_code();

  public:
  // optional string sub_code = 11;
  bool has_sub_code() const;
  void clear_sub_code() ;
  const std::string& sub_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sub_code(Arg_&& arg, Args_... args);
  std::string* mutable_sub_code();
  PROTOBUF_NODISCARD std::string* release_sub_code();
  void set_allocated_sub_code(std::string* value);

  private:
  const std::string& _internal_sub_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sub_code(
      const std::string& value);
  std::string* _internal_mutable_sub_code();

  public:
  // optional .osi3.TrafficSignValue value = 3;
  bool has_value() const;
  void clear_value() ;
  const ::osi3::TrafficSignValue& value() const;
  PROTOBUF_NODISCARD ::osi3::TrafficSignValue* release_value();
  ::osi3::TrafficSignValue* mutable_value();
  void set_allocated_value(::osi3::TrafficSignValue* value);
  void unsafe_arena_set_allocated_value(::osi3::TrafficSignValue* value);
  ::osi3::TrafficSignValue* unsafe_arena_release_value();

  private:
  const ::osi3::TrafficSignValue& _internal_value() const;
  ::osi3::TrafficSignValue* _internal_mutable_value();

  public:
  // optional .osi3.TrafficSign.Variability variability = 1;
  bool has_variability() const;
  void clear_variability() ;
  ::osi3::TrafficSign_Variability variability() const;
  void set_variability(::osi3::TrafficSign_Variability value);

  private:
  ::osi3::TrafficSign_Variability _internal_variability() const;
  void _internal_set_variability(::osi3::TrafficSign_Variability value);

  public:
  // optional .osi3.TrafficSign.MainSign.Classification.Type type = 2;
  bool has_type() const;
  void clear_type() ;
  ::osi3::TrafficSign_MainSign_Classification_Type type() const;
  void set_type(::osi3::TrafficSign_MainSign_Classification_Type value);

  private:
  ::osi3::TrafficSign_MainSign_Classification_Type _internal_type() const;
  void _internal_set_type(::osi3::TrafficSign_MainSign_Classification_Type value);

  public:
  // optional .osi3.TrafficSign.MainSign.Classification.DirectionScope direction_scope = 4;
  bool has_direction_scope() const;
  void clear_direction_scope() ;
  ::osi3::TrafficSign_MainSign_Classification_DirectionScope direction_scope() const;
  void set_direction_scope(::osi3::TrafficSign_MainSign_Classification_DirectionScope value);

  private:
  ::osi3::TrafficSign_MainSign_Classification_DirectionScope _internal_direction_scope() const;
  void _internal_set_direction_scope(::osi3::TrafficSign_MainSign_Classification_DirectionScope value);

  public:
  // optional bool vertically_mirrored = 6;
  bool has_vertically_mirrored() const;
  void clear_vertically_mirrored() ;
  bool vertically_mirrored() const;
  void set_vertically_mirrored(bool value);

  private:
  bool _internal_vertically_mirrored() const;
  void _internal_set_vertically_mirrored(bool value);

  public:
  // optional bool is_out_of_service = 7;
  bool has_is_out_of_service() const;
  void clear_is_out_of_service() ;
  bool is_out_of_service() const;
  void set_is_out_of_service(bool value);

  private:
  bool _internal_is_out_of_service() const;
  void _internal_set_is_out_of_service(bool value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.TrafficSign.MainSign.Classification)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 6,
      92, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TrafficSign_MainSign_Classification& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::osi3::Identifier > assigned_lane_id_;
    ::google::protobuf::RepeatedPtrField< ::osi3::LogicalLaneAssignment > logical_lane_assignment_;
    ::google::protobuf::internal::ArenaStringPtr country_;
    ::google::protobuf::internal::ArenaStringPtr country_revision_;
    ::google::protobuf::internal::ArenaStringPtr code_;
    ::google::protobuf::internal::ArenaStringPtr sub_code_;
    ::osi3::TrafficSignValue* value_;
    int variability_;
    int type_;
    int direction_scope_;
    bool vertically_mirrored_;
    bool is_out_of_service_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ftrafficsign_2eproto;
};
// -------------------------------------------------------------------

class TrafficSign_SupplementarySign final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.TrafficSign.SupplementarySign) */ {
 public:
  inline TrafficSign_SupplementarySign() : TrafficSign_SupplementarySign(nullptr) {}
  ~TrafficSign_SupplementarySign() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrafficSign_SupplementarySign* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrafficSign_SupplementarySign));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficSign_SupplementarySign(
      ::google::protobuf::internal::ConstantInitialized);

  inline TrafficSign_SupplementarySign(const TrafficSign_SupplementarySign& from) : TrafficSign_SupplementarySign(nullptr, from) {}
  inline TrafficSign_SupplementarySign(TrafficSign_SupplementarySign&& from) noexcept
      : TrafficSign_SupplementarySign(nullptr, std::move(from)) {}
  inline TrafficSign_SupplementarySign& operator=(const TrafficSign_SupplementarySign& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_SupplementarySign& operator=(TrafficSign_SupplementarySign&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSign_SupplementarySign& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSign_SupplementarySign* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_SupplementarySign*>(
        &_TrafficSign_SupplementarySign_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(TrafficSign_SupplementarySign& a, TrafficSign_SupplementarySign& b) { a.Swap(&b); }
  inline void Swap(TrafficSign_SupplementarySign* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSign_SupplementarySign* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSign_SupplementarySign* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrafficSign_SupplementarySign>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficSign_SupplementarySign& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrafficSign_SupplementarySign& from) { TrafficSign_SupplementarySign::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrafficSign_SupplementarySign* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.TrafficSign.SupplementarySign"; }

 protected:
  explicit TrafficSign_SupplementarySign(::google::protobuf::Arena* arena);
  TrafficSign_SupplementarySign(::google::protobuf::Arena* arena, const TrafficSign_SupplementarySign& from);
  TrafficSign_SupplementarySign(::google::protobuf::Arena* arena, TrafficSign_SupplementarySign&& from) noexcept
      : TrafficSign_SupplementarySign(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Classification = TrafficSign_SupplementarySign_Classification;

  // accessors -------------------------------------------------------
  enum : int {
    kModelReferenceFieldNumber = 3,
    kBaseFieldNumber = 1,
    kClassificationFieldNumber = 2,
  };
  // optional string model_reference = 3;
  bool has_model_reference() const;
  void clear_model_reference() ;
  const std::string& model_reference() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_reference(Arg_&& arg, Args_... args);
  std::string* mutable_model_reference();
  PROTOBUF_NODISCARD std::string* release_model_reference();
  void set_allocated_model_reference(std::string* value);

  private:
  const std::string& _internal_model_reference() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_reference(
      const std::string& value);
  std::string* _internal_mutable_model_reference();

  public:
  // optional .osi3.BaseStationary base = 1;
  bool has_base() const;
  void clear_base() ;
  const ::osi3::BaseStationary& base() const;
  PROTOBUF_NODISCARD ::osi3::BaseStationary* release_base();
  ::osi3::BaseStationary* mutable_base();
  void set_allocated_base(::osi3::BaseStationary* value);
  void unsafe_arena_set_allocated_base(::osi3::BaseStationary* value);
  ::osi3::BaseStationary* unsafe_arena_release_base();

  private:
  const ::osi3::BaseStationary& _internal_base() const;
  ::osi3::BaseStationary* _internal_mutable_base();

  public:
  // optional .osi3.TrafficSign.SupplementarySign.Classification classification = 2;
  bool has_classification() const;
  void clear_classification() ;
  const ::osi3::TrafficSign_SupplementarySign_Classification& classification() const;
  PROTOBUF_NODISCARD ::osi3::TrafficSign_SupplementarySign_Classification* release_classification();
  ::osi3::TrafficSign_SupplementarySign_Classification* mutable_classification();
  void set_allocated_classification(::osi3::TrafficSign_SupplementarySign_Classification* value);
  void unsafe_arena_set_allocated_classification(::osi3::TrafficSign_SupplementarySign_Classification* value);
  ::osi3::TrafficSign_SupplementarySign_Classification* unsafe_arena_release_classification();

  private:
  const ::osi3::TrafficSign_SupplementarySign_Classification& _internal_classification() const;
  ::osi3::TrafficSign_SupplementarySign_Classification* _internal_mutable_classification();

  public:
  // @@protoc_insertion_point(class_scope:osi3.TrafficSign.SupplementarySign)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      58, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TrafficSign_SupplementarySign& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr model_reference_;
    ::osi3::BaseStationary* base_;
    ::osi3::TrafficSign_SupplementarySign_Classification* classification_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ftrafficsign_2eproto;
};
// -------------------------------------------------------------------

class TrafficSign_MainSign final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.TrafficSign.MainSign) */ {
 public:
  inline TrafficSign_MainSign() : TrafficSign_MainSign(nullptr) {}
  ~TrafficSign_MainSign() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrafficSign_MainSign* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrafficSign_MainSign));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficSign_MainSign(
      ::google::protobuf::internal::ConstantInitialized);

  inline TrafficSign_MainSign(const TrafficSign_MainSign& from) : TrafficSign_MainSign(nullptr, from) {}
  inline TrafficSign_MainSign(TrafficSign_MainSign&& from) noexcept
      : TrafficSign_MainSign(nullptr, std::move(from)) {}
  inline TrafficSign_MainSign& operator=(const TrafficSign_MainSign& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_MainSign& operator=(TrafficSign_MainSign&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSign_MainSign& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSign_MainSign* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_MainSign*>(
        &_TrafficSign_MainSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(TrafficSign_MainSign& a, TrafficSign_MainSign& b) { a.Swap(&b); }
  inline void Swap(TrafficSign_MainSign* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSign_MainSign* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSign_MainSign* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrafficSign_MainSign>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficSign_MainSign& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrafficSign_MainSign& from) { TrafficSign_MainSign::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrafficSign_MainSign* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.TrafficSign.MainSign"; }

 protected:
  explicit TrafficSign_MainSign(::google::protobuf::Arena* arena);
  TrafficSign_MainSign(::google::protobuf::Arena* arena, const TrafficSign_MainSign& from);
  TrafficSign_MainSign(::google::protobuf::Arena* arena, TrafficSign_MainSign&& from) noexcept
      : TrafficSign_MainSign(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Classification = TrafficSign_MainSign_Classification;

  // accessors -------------------------------------------------------
  enum : int {
    kModelReferenceFieldNumber = 3,
    kBaseFieldNumber = 1,
    kClassificationFieldNumber = 2,
  };
  // optional string model_reference = 3;
  bool has_model_reference() const;
  void clear_model_reference() ;
  const std::string& model_reference() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_reference(Arg_&& arg, Args_... args);
  std::string* mutable_model_reference();
  PROTOBUF_NODISCARD std::string* release_model_reference();
  void set_allocated_model_reference(std::string* value);

  private:
  const std::string& _internal_model_reference() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_reference(
      const std::string& value);
  std::string* _internal_mutable_model_reference();

  public:
  // optional .osi3.BaseStationary base = 1;
  bool has_base() const;
  void clear_base() ;
  const ::osi3::BaseStationary& base() const;
  PROTOBUF_NODISCARD ::osi3::BaseStationary* release_base();
  ::osi3::BaseStationary* mutable_base();
  void set_allocated_base(::osi3::BaseStationary* value);
  void unsafe_arena_set_allocated_base(::osi3::BaseStationary* value);
  ::osi3::BaseStationary* unsafe_arena_release_base();

  private:
  const ::osi3::BaseStationary& _internal_base() const;
  ::osi3::BaseStationary* _internal_mutable_base();

  public:
  // optional .osi3.TrafficSign.MainSign.Classification classification = 2;
  bool has_classification() const;
  void clear_classification() ;
  const ::osi3::TrafficSign_MainSign_Classification& classification() const;
  PROTOBUF_NODISCARD ::osi3::TrafficSign_MainSign_Classification* release_classification();
  ::osi3::TrafficSign_MainSign_Classification* mutable_classification();
  void set_allocated_classification(::osi3::TrafficSign_MainSign_Classification* value);
  void unsafe_arena_set_allocated_classification(::osi3::TrafficSign_MainSign_Classification* value);
  ::osi3::TrafficSign_MainSign_Classification* unsafe_arena_release_classification();

  private:
  const ::osi3::TrafficSign_MainSign_Classification& _internal_classification() const;
  ::osi3::TrafficSign_MainSign_Classification* _internal_mutable_classification();

  public:
  // @@protoc_insertion_point(class_scope:osi3.TrafficSign.MainSign)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      49, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TrafficSign_MainSign& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr model_reference_;
    ::osi3::BaseStationary* base_;
    ::osi3::TrafficSign_MainSign_Classification* classification_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ftrafficsign_2eproto;
};
// -------------------------------------------------------------------

class TrafficSign final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.TrafficSign) */ {
 public:
  inline TrafficSign() : TrafficSign(nullptr) {}
  ~TrafficSign() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrafficSign* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrafficSign));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficSign(
      ::google::protobuf::internal::ConstantInitialized);

  inline TrafficSign(const TrafficSign& from) : TrafficSign(nullptr, from) {}
  inline TrafficSign(TrafficSign&& from) noexcept
      : TrafficSign(nullptr, std::move(from)) {}
  inline TrafficSign& operator=(const TrafficSign& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign& operator=(TrafficSign&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSign& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSign* internal_default_instance() {
    return reinterpret_cast<const TrafficSign*>(
        &_TrafficSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(TrafficSign& a, TrafficSign& b) { a.Swap(&b); }
  inline void Swap(TrafficSign* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSign* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSign* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrafficSign>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficSign& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrafficSign& from) { TrafficSign::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrafficSign* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.TrafficSign"; }

 protected:
  explicit TrafficSign(::google::protobuf::Arena* arena);
  TrafficSign(::google::protobuf::Arena* arena, const TrafficSign& from);
  TrafficSign(::google::protobuf::Arena* arena, TrafficSign&& from) noexcept
      : TrafficSign(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using MainSign = TrafficSign_MainSign;
  using SupplementarySign = TrafficSign_SupplementarySign;
  using Variability = TrafficSign_Variability;
  static constexpr Variability VARIABILITY_UNKNOWN = TrafficSign_Variability_VARIABILITY_UNKNOWN;
  static constexpr Variability VARIABILITY_OTHER = TrafficSign_Variability_VARIABILITY_OTHER;
  static constexpr Variability VARIABILITY_FIXED = TrafficSign_Variability_VARIABILITY_FIXED;
  static constexpr Variability VARIABILITY_VARIABLE = TrafficSign_Variability_VARIABILITY_VARIABLE;
  static inline bool Variability_IsValid(int value) {
    return TrafficSign_Variability_IsValid(value);
  }
  static constexpr Variability Variability_MIN = TrafficSign_Variability_Variability_MIN;
  static constexpr Variability Variability_MAX = TrafficSign_Variability_Variability_MAX;
  static constexpr int Variability_ARRAYSIZE = TrafficSign_Variability_Variability_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Variability_descriptor() {
    return TrafficSign_Variability_descriptor();
  }
  template <typename T>
  static inline const std::string& Variability_Name(T value) {
    return TrafficSign_Variability_Name(value);
  }
  static inline bool Variability_Parse(absl::string_view name, Variability* value) {
    return TrafficSign_Variability_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kSupplementarySignFieldNumber = 3,
    kSourceReferenceFieldNumber = 4,
    kIdFieldNumber = 1,
    kMainSignFieldNumber = 2,
  };
  // repeated .osi3.TrafficSign.SupplementarySign supplementary_sign = 3;
  int supplementary_sign_size() const;
  private:
  int _internal_supplementary_sign_size() const;

  public:
  void clear_supplementary_sign() ;
  ::osi3::TrafficSign_SupplementarySign* mutable_supplementary_sign(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::TrafficSign_SupplementarySign>* mutable_supplementary_sign();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::TrafficSign_SupplementarySign>& _internal_supplementary_sign() const;
  ::google::protobuf::RepeatedPtrField<::osi3::TrafficSign_SupplementarySign>* _internal_mutable_supplementary_sign();
  public:
  const ::osi3::TrafficSign_SupplementarySign& supplementary_sign(int index) const;
  ::osi3::TrafficSign_SupplementarySign* add_supplementary_sign();
  const ::google::protobuf::RepeatedPtrField<::osi3::TrafficSign_SupplementarySign>& supplementary_sign() const;
  // repeated .osi3.ExternalReference source_reference = 4;
  int source_reference_size() const;
  private:
  int _internal_source_reference_size() const;

  public:
  void clear_source_reference() ;
  ::osi3::ExternalReference* mutable_source_reference(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::ExternalReference>* mutable_source_reference();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::ExternalReference>& _internal_source_reference() const;
  ::google::protobuf::RepeatedPtrField<::osi3::ExternalReference>* _internal_mutable_source_reference();
  public:
  const ::osi3::ExternalReference& source_reference(int index) const;
  ::osi3::ExternalReference* add_source_reference();
  const ::google::protobuf::RepeatedPtrField<::osi3::ExternalReference>& source_reference() const;
  // optional .osi3.Identifier id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::osi3::Identifier& id() const;
  PROTOBUF_NODISCARD ::osi3::Identifier* release_id();
  ::osi3::Identifier* mutable_id();
  void set_allocated_id(::osi3::Identifier* value);
  void unsafe_arena_set_allocated_id(::osi3::Identifier* value);
  ::osi3::Identifier* unsafe_arena_release_id();

  private:
  const ::osi3::Identifier& _internal_id() const;
  ::osi3::Identifier* _internal_mutable_id();

  public:
  // optional .osi3.TrafficSign.MainSign main_sign = 2;
  bool has_main_sign() const;
  void clear_main_sign() ;
  const ::osi3::TrafficSign_MainSign& main_sign() const;
  PROTOBUF_NODISCARD ::osi3::TrafficSign_MainSign* release_main_sign();
  ::osi3::TrafficSign_MainSign* mutable_main_sign();
  void set_allocated_main_sign(::osi3::TrafficSign_MainSign* value);
  void unsafe_arena_set_allocated_main_sign(::osi3::TrafficSign_MainSign* value);
  ::osi3::TrafficSign_MainSign* unsafe_arena_release_main_sign();

  private:
  const ::osi3::TrafficSign_MainSign& _internal_main_sign() const;
  ::osi3::TrafficSign_MainSign* _internal_mutable_main_sign();

  public:
  // @@protoc_insertion_point(class_scope:osi3.TrafficSign)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TrafficSign& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::osi3::TrafficSign_SupplementarySign > supplementary_sign_;
    ::google::protobuf::RepeatedPtrField< ::osi3::ExternalReference > source_reference_;
    ::osi3::Identifier* id_;
    ::osi3::TrafficSign_MainSign* main_sign_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5ftrafficsign_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// TrafficSignValue

// optional double value = 1;
inline bool TrafficSignValue::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TrafficSignValue::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double TrafficSignValue::value() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSignValue.value)
  return _internal_value();
}
inline void TrafficSignValue::set_value(double value) {
  _internal_set_value(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.TrafficSignValue.value)
}
inline double TrafficSignValue::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void TrafficSignValue::_internal_set_value(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// optional .osi3.TrafficSignValue.Unit value_unit = 2;
inline bool TrafficSignValue::has_value_unit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TrafficSignValue::clear_value_unit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_unit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::osi3::TrafficSignValue_Unit TrafficSignValue::value_unit() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSignValue.value_unit)
  return _internal_value_unit();
}
inline void TrafficSignValue::set_value_unit(::osi3::TrafficSignValue_Unit value) {
  _internal_set_value_unit(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.TrafficSignValue.value_unit)
}
inline ::osi3::TrafficSignValue_Unit TrafficSignValue::_internal_value_unit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::osi3::TrafficSignValue_Unit>(_impl_.value_unit_);
}
inline void TrafficSignValue::_internal_set_value_unit(::osi3::TrafficSignValue_Unit value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::osi3::TrafficSignValue_Unit_IsValid(value));
  _impl_.value_unit_ = value;
}

// optional string text = 3;
inline bool TrafficSignValue::has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TrafficSignValue::clear_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrafficSignValue::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSignValue.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrafficSignValue::set_text(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:osi3.TrafficSignValue.text)
}
inline std::string* TrafficSignValue::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSignValue.text)
  return _s;
}
inline const std::string& TrafficSignValue::_internal_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.text_.Get();
}
inline void TrafficSignValue::_internal_set_text(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(value, GetArena());
}
inline std::string* TrafficSignValue::_internal_mutable_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* TrafficSignValue::release_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSignValue.text)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.text_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.text_.Set("", GetArena());
  }
  return released;
}
inline void TrafficSignValue::set_allocated_text(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSignValue.text)
}

// -------------------------------------------------------------------

// TrafficSign_MainSign_Classification

// optional .osi3.TrafficSign.Variability variability = 1;
inline bool TrafficSign_MainSign_Classification::has_variability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void TrafficSign_MainSign_Classification::clear_variability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.variability_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::osi3::TrafficSign_Variability TrafficSign_MainSign_Classification::variability() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.variability)
  return _internal_variability();
}
inline void TrafficSign_MainSign_Classification::set_variability(::osi3::TrafficSign_Variability value) {
  _internal_set_variability(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.variability)
}
inline ::osi3::TrafficSign_Variability TrafficSign_MainSign_Classification::_internal_variability() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::osi3::TrafficSign_Variability>(_impl_.variability_);
}
inline void TrafficSign_MainSign_Classification::_internal_set_variability(::osi3::TrafficSign_Variability value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::osi3::TrafficSign_Variability_IsValid(value));
  _impl_.variability_ = value;
}

// optional .osi3.TrafficSign.MainSign.Classification.Type type = 2;
inline bool TrafficSign_MainSign_Classification::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void TrafficSign_MainSign_Classification::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::osi3::TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::type() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.type)
  return _internal_type();
}
inline void TrafficSign_MainSign_Classification::set_type(::osi3::TrafficSign_MainSign_Classification_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.type)
}
inline ::osi3::TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::osi3::TrafficSign_MainSign_Classification_Type>(_impl_.type_);
}
inline void TrafficSign_MainSign_Classification::_internal_set_type(::osi3::TrafficSign_MainSign_Classification_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::osi3::TrafficSign_MainSign_Classification_Type_IsValid(value));
  _impl_.type_ = value;
}

// optional .osi3.TrafficSignValue value = 3;
inline bool TrafficSign_MainSign_Classification::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline void TrafficSign_MainSign_Classification::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::osi3::TrafficSignValue& TrafficSign_MainSign_Classification::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::TrafficSignValue* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::TrafficSignValue&>(::osi3::_TrafficSignValue_default_instance_);
}
inline const ::osi3::TrafficSignValue& TrafficSign_MainSign_Classification::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.value)
  return _internal_value();
}
inline void TrafficSign_MainSign_Classification::unsafe_arena_set_allocated_value(::osi3::TrafficSignValue* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::osi3::TrafficSignValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.TrafficSign.MainSign.Classification.value)
}
inline ::osi3::TrafficSignValue* TrafficSign_MainSign_Classification::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::osi3::TrafficSignValue* released = _impl_.value_;
  _impl_.value_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::TrafficSignValue* TrafficSign_MainSign_Classification::unsafe_arena_release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.Classification.value)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::osi3::TrafficSignValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::osi3::TrafficSignValue* TrafficSign_MainSign_Classification::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::TrafficSignValue>(GetArena());
    _impl_.value_ = reinterpret_cast<::osi3::TrafficSignValue*>(p);
  }
  return _impl_.value_;
}
inline ::osi3::TrafficSignValue* TrafficSign_MainSign_Classification::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::osi3::TrafficSignValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.Classification.value)
  return _msg;
}
inline void TrafficSign_MainSign_Classification::set_allocated_value(::osi3::TrafficSignValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.value_ = reinterpret_cast<::osi3::TrafficSignValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.Classification.value)
}

// optional .osi3.TrafficSign.MainSign.Classification.DirectionScope direction_scope = 4;
inline bool TrafficSign_MainSign_Classification::has_direction_scope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void TrafficSign_MainSign_Classification::clear_direction_scope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_scope_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::osi3::TrafficSign_MainSign_Classification_DirectionScope TrafficSign_MainSign_Classification::direction_scope() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.direction_scope)
  return _internal_direction_scope();
}
inline void TrafficSign_MainSign_Classification::set_direction_scope(::osi3::TrafficSign_MainSign_Classification_DirectionScope value) {
  _internal_set_direction_scope(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.direction_scope)
}
inline ::osi3::TrafficSign_MainSign_Classification_DirectionScope TrafficSign_MainSign_Classification::_internal_direction_scope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::osi3::TrafficSign_MainSign_Classification_DirectionScope>(_impl_.direction_scope_);
}
inline void TrafficSign_MainSign_Classification::_internal_set_direction_scope(::osi3::TrafficSign_MainSign_Classification_DirectionScope value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::osi3::TrafficSign_MainSign_Classification_DirectionScope_IsValid(value));
  _impl_.direction_scope_ = value;
}

// repeated .osi3.Identifier assigned_lane_id = 5;
inline int TrafficSign_MainSign_Classification::_internal_assigned_lane_id_size() const {
  return _internal_assigned_lane_id().size();
}
inline int TrafficSign_MainSign_Classification::assigned_lane_id_size() const {
  return _internal_assigned_lane_id_size();
}
inline ::osi3::Identifier* TrafficSign_MainSign_Classification::mutable_assigned_lane_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.Classification.assigned_lane_id)
  return _internal_mutable_assigned_lane_id()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::Identifier>* TrafficSign_MainSign_Classification::mutable_assigned_lane_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.MainSign.Classification.assigned_lane_id)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_assigned_lane_id();
}
inline const ::osi3::Identifier& TrafficSign_MainSign_Classification::assigned_lane_id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.assigned_lane_id)
  return _internal_assigned_lane_id().Get(index);
}
inline ::osi3::Identifier* TrafficSign_MainSign_Classification::add_assigned_lane_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::Identifier* _add = _internal_mutable_assigned_lane_id()->Add();
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.MainSign.Classification.assigned_lane_id)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::Identifier>& TrafficSign_MainSign_Classification::assigned_lane_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.MainSign.Classification.assigned_lane_id)
  return _internal_assigned_lane_id();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::Identifier>&
TrafficSign_MainSign_Classification::_internal_assigned_lane_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.assigned_lane_id_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::Identifier>*
TrafficSign_MainSign_Classification::_internal_mutable_assigned_lane_id() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.assigned_lane_id_;
}

// optional bool vertically_mirrored = 6;
inline bool TrafficSign_MainSign_Classification::has_vertically_mirrored() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void TrafficSign_MainSign_Classification::clear_vertically_mirrored() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vertically_mirrored_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool TrafficSign_MainSign_Classification::vertically_mirrored() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.vertically_mirrored)
  return _internal_vertically_mirrored();
}
inline void TrafficSign_MainSign_Classification::set_vertically_mirrored(bool value) {
  _internal_set_vertically_mirrored(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.vertically_mirrored)
}
inline bool TrafficSign_MainSign_Classification::_internal_vertically_mirrored() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vertically_mirrored_;
}
inline void TrafficSign_MainSign_Classification::_internal_set_vertically_mirrored(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vertically_mirrored_ = value;
}

// optional bool is_out_of_service = 7;
inline bool TrafficSign_MainSign_Classification::has_is_out_of_service() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void TrafficSign_MainSign_Classification::clear_is_out_of_service() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_out_of_service_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool TrafficSign_MainSign_Classification::is_out_of_service() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.is_out_of_service)
  return _internal_is_out_of_service();
}
inline void TrafficSign_MainSign_Classification::set_is_out_of_service(bool value) {
  _internal_set_is_out_of_service(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.is_out_of_service)
}
inline bool TrafficSign_MainSign_Classification::_internal_is_out_of_service() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_out_of_service_;
}
inline void TrafficSign_MainSign_Classification::_internal_set_is_out_of_service(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_out_of_service_ = value;
}

// optional string country = 8;
inline bool TrafficSign_MainSign_Classification::has_country() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TrafficSign_MainSign_Classification::clear_country() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.country_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrafficSign_MainSign_Classification::country() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.country)
  return _internal_country();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrafficSign_MainSign_Classification::set_country(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.country_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.country)
}
inline std::string* TrafficSign_MainSign_Classification::mutable_country() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_country();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.Classification.country)
  return _s;
}
inline const std::string& TrafficSign_MainSign_Classification::_internal_country() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.country_.Get();
}
inline void TrafficSign_MainSign_Classification::_internal_set_country(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.country_.Set(value, GetArena());
}
inline std::string* TrafficSign_MainSign_Classification::_internal_mutable_country() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.country_.Mutable( GetArena());
}
inline std::string* TrafficSign_MainSign_Classification::release_country() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.Classification.country)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.country_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.country_.Set("", GetArena());
  }
  return released;
}
inline void TrafficSign_MainSign_Classification::set_allocated_country(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.country_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.country_.IsDefault()) {
    _impl_.country_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.Classification.country)
}

// optional string country_revision = 9;
inline bool TrafficSign_MainSign_Classification::has_country_revision() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TrafficSign_MainSign_Classification::clear_country_revision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.country_revision_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TrafficSign_MainSign_Classification::country_revision() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.country_revision)
  return _internal_country_revision();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrafficSign_MainSign_Classification::set_country_revision(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.country_revision_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.country_revision)
}
inline std::string* TrafficSign_MainSign_Classification::mutable_country_revision() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_country_revision();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.Classification.country_revision)
  return _s;
}
inline const std::string& TrafficSign_MainSign_Classification::_internal_country_revision() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.country_revision_.Get();
}
inline void TrafficSign_MainSign_Classification::_internal_set_country_revision(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.country_revision_.Set(value, GetArena());
}
inline std::string* TrafficSign_MainSign_Classification::_internal_mutable_country_revision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.country_revision_.Mutable( GetArena());
}
inline std::string* TrafficSign_MainSign_Classification::release_country_revision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.Classification.country_revision)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.country_revision_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.country_revision_.Set("", GetArena());
  }
  return released;
}
inline void TrafficSign_MainSign_Classification::set_allocated_country_revision(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.country_revision_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.country_revision_.IsDefault()) {
    _impl_.country_revision_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.Classification.country_revision)
}

// optional string code = 10;
inline bool TrafficSign_MainSign_Classification::has_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TrafficSign_MainSign_Classification::clear_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TrafficSign_MainSign_Classification::code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.code)
  return _internal_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrafficSign_MainSign_Classification::set_code(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.code)
}
inline std::string* TrafficSign_MainSign_Classification::mutable_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.Classification.code)
  return _s;
}
inline const std::string& TrafficSign_MainSign_Classification::_internal_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.code_.Get();
}
inline void TrafficSign_MainSign_Classification::_internal_set_code(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.code_.Set(value, GetArena());
}
inline std::string* TrafficSign_MainSign_Classification::_internal_mutable_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.code_.Mutable( GetArena());
}
inline std::string* TrafficSign_MainSign_Classification::release_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.Classification.code)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.code_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.code_.Set("", GetArena());
  }
  return released;
}
inline void TrafficSign_MainSign_Classification::set_allocated_code(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.code_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.Classification.code)
}

// optional string sub_code = 11;
inline bool TrafficSign_MainSign_Classification::has_sub_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TrafficSign_MainSign_Classification::clear_sub_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sub_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TrafficSign_MainSign_Classification::sub_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.sub_code)
  return _internal_sub_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrafficSign_MainSign_Classification::set_sub_code(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sub_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.sub_code)
}
inline std::string* TrafficSign_MainSign_Classification::mutable_sub_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sub_code();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.Classification.sub_code)
  return _s;
}
inline const std::string& TrafficSign_MainSign_Classification::_internal_sub_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sub_code_.Get();
}
inline void TrafficSign_MainSign_Classification::_internal_set_sub_code(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sub_code_.Set(value, GetArena());
}
inline std::string* TrafficSign_MainSign_Classification::_internal_mutable_sub_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.sub_code_.Mutable( GetArena());
}
inline std::string* TrafficSign_MainSign_Classification::release_sub_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.Classification.sub_code)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.sub_code_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.sub_code_.Set("", GetArena());
  }
  return released;
}
inline void TrafficSign_MainSign_Classification::set_allocated_sub_code(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.sub_code_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sub_code_.IsDefault()) {
    _impl_.sub_code_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.Classification.sub_code)
}

// repeated .osi3.LogicalLaneAssignment logical_lane_assignment = 12;
inline int TrafficSign_MainSign_Classification::_internal_logical_lane_assignment_size() const {
  return _internal_logical_lane_assignment().size();
}
inline int TrafficSign_MainSign_Classification::logical_lane_assignment_size() const {
  return _internal_logical_lane_assignment_size();
}
inline ::osi3::LogicalLaneAssignment* TrafficSign_MainSign_Classification::mutable_logical_lane_assignment(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.Classification.logical_lane_assignment)
  return _internal_mutable_logical_lane_assignment()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::LogicalLaneAssignment>* TrafficSign_MainSign_Classification::mutable_logical_lane_assignment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.MainSign.Classification.logical_lane_assignment)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_logical_lane_assignment();
}
inline const ::osi3::LogicalLaneAssignment& TrafficSign_MainSign_Classification::logical_lane_assignment(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.logical_lane_assignment)
  return _internal_logical_lane_assignment().Get(index);
}
inline ::osi3::LogicalLaneAssignment* TrafficSign_MainSign_Classification::add_logical_lane_assignment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::LogicalLaneAssignment* _add = _internal_mutable_logical_lane_assignment()->Add();
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.MainSign.Classification.logical_lane_assignment)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::LogicalLaneAssignment>& TrafficSign_MainSign_Classification::logical_lane_assignment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.MainSign.Classification.logical_lane_assignment)
  return _internal_logical_lane_assignment();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::LogicalLaneAssignment>&
TrafficSign_MainSign_Classification::_internal_logical_lane_assignment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.logical_lane_assignment_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::LogicalLaneAssignment>*
TrafficSign_MainSign_Classification::_internal_mutable_logical_lane_assignment() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.logical_lane_assignment_;
}

// -------------------------------------------------------------------

// TrafficSign_MainSign

// optional .osi3.BaseStationary base = 1;
inline bool TrafficSign_MainSign::has_base() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_ != nullptr);
  return value;
}
inline const ::osi3::BaseStationary& TrafficSign_MainSign::_internal_base() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::BaseStationary* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::BaseStationary&>(::osi3::_BaseStationary_default_instance_);
}
inline const ::osi3::BaseStationary& TrafficSign_MainSign::base() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.base)
  return _internal_base();
}
inline void TrafficSign_MainSign::unsafe_arena_set_allocated_base(::osi3::BaseStationary* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = reinterpret_cast<::osi3::BaseStationary*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.TrafficSign.MainSign.base)
}
inline ::osi3::BaseStationary* TrafficSign_MainSign::release_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::BaseStationary* released = _impl_.base_;
  _impl_.base_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::BaseStationary* TrafficSign_MainSign::unsafe_arena_release_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.base)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::BaseStationary* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::osi3::BaseStationary* TrafficSign_MainSign::_internal_mutable_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.base_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::BaseStationary>(GetArena());
    _impl_.base_ = reinterpret_cast<::osi3::BaseStationary*>(p);
  }
  return _impl_.base_;
}
inline ::osi3::BaseStationary* TrafficSign_MainSign::mutable_base() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::osi3::BaseStationary* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.base)
  return _msg;
}
inline void TrafficSign_MainSign::set_allocated_base(::osi3::BaseStationary* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.base_ = reinterpret_cast<::osi3::BaseStationary*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.base)
}

// optional .osi3.TrafficSign.MainSign.Classification classification = 2;
inline bool TrafficSign_MainSign::has_classification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.classification_ != nullptr);
  return value;
}
inline void TrafficSign_MainSign::clear_classification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.classification_ != nullptr) _impl_.classification_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::osi3::TrafficSign_MainSign_Classification& TrafficSign_MainSign::_internal_classification() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::TrafficSign_MainSign_Classification* p = _impl_.classification_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::TrafficSign_MainSign_Classification&>(::osi3::_TrafficSign_MainSign_Classification_default_instance_);
}
inline const ::osi3::TrafficSign_MainSign_Classification& TrafficSign_MainSign::classification() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.classification)
  return _internal_classification();
}
inline void TrafficSign_MainSign::unsafe_arena_set_allocated_classification(::osi3::TrafficSign_MainSign_Classification* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.classification_);
  }
  _impl_.classification_ = reinterpret_cast<::osi3::TrafficSign_MainSign_Classification*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.TrafficSign.MainSign.classification)
}
inline ::osi3::TrafficSign_MainSign_Classification* TrafficSign_MainSign::release_classification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::TrafficSign_MainSign_Classification* released = _impl_.classification_;
  _impl_.classification_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::TrafficSign_MainSign_Classification* TrafficSign_MainSign::unsafe_arena_release_classification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.classification)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::TrafficSign_MainSign_Classification* temp = _impl_.classification_;
  _impl_.classification_ = nullptr;
  return temp;
}
inline ::osi3::TrafficSign_MainSign_Classification* TrafficSign_MainSign::_internal_mutable_classification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.classification_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::TrafficSign_MainSign_Classification>(GetArena());
    _impl_.classification_ = reinterpret_cast<::osi3::TrafficSign_MainSign_Classification*>(p);
  }
  return _impl_.classification_;
}
inline ::osi3::TrafficSign_MainSign_Classification* TrafficSign_MainSign::mutable_classification() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::osi3::TrafficSign_MainSign_Classification* _msg = _internal_mutable_classification();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.classification)
  return _msg;
}
inline void TrafficSign_MainSign::set_allocated_classification(::osi3::TrafficSign_MainSign_Classification* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.classification_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.classification_ = reinterpret_cast<::osi3::TrafficSign_MainSign_Classification*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.classification)
}

// optional string model_reference = 3;
inline bool TrafficSign_MainSign::has_model_reference() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TrafficSign_MainSign::clear_model_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_reference_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrafficSign_MainSign::model_reference() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.model_reference)
  return _internal_model_reference();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrafficSign_MainSign::set_model_reference(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.model_reference_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.model_reference)
}
inline std::string* TrafficSign_MainSign::mutable_model_reference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_reference();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.model_reference)
  return _s;
}
inline const std::string& TrafficSign_MainSign::_internal_model_reference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_reference_.Get();
}
inline void TrafficSign_MainSign::_internal_set_model_reference(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.model_reference_.Set(value, GetArena());
}
inline std::string* TrafficSign_MainSign::_internal_mutable_model_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.model_reference_.Mutable( GetArena());
}
inline std::string* TrafficSign_MainSign::release_model_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.model_reference)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.model_reference_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.model_reference_.Set("", GetArena());
  }
  return released;
}
inline void TrafficSign_MainSign::set_allocated_model_reference(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.model_reference_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.model_reference_.IsDefault()) {
    _impl_.model_reference_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.model_reference)
}

// -------------------------------------------------------------------

// TrafficSign_SupplementarySign_Classification_Arrow

// repeated .osi3.Identifier lane_id = 1;
inline int TrafficSign_SupplementarySign_Classification_Arrow::_internal_lane_id_size() const {
  return _internal_lane_id().size();
}
inline int TrafficSign_SupplementarySign_Classification_Arrow::lane_id_size() const {
  return _internal_lane_id_size();
}
inline ::osi3::Identifier* TrafficSign_SupplementarySign_Classification_Arrow::mutable_lane_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.Arrow.lane_id)
  return _internal_mutable_lane_id()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::Identifier>* TrafficSign_SupplementarySign_Classification_Arrow::mutable_lane_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.SupplementarySign.Classification.Arrow.lane_id)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_lane_id();
}
inline const ::osi3::Identifier& TrafficSign_SupplementarySign_Classification_Arrow::lane_id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.Arrow.lane_id)
  return _internal_lane_id().Get(index);
}
inline ::osi3::Identifier* TrafficSign_SupplementarySign_Classification_Arrow::add_lane_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::Identifier* _add = _internal_mutable_lane_id()->Add();
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.SupplementarySign.Classification.Arrow.lane_id)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::Identifier>& TrafficSign_SupplementarySign_Classification_Arrow::lane_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.SupplementarySign.Classification.Arrow.lane_id)
  return _internal_lane_id();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::Identifier>&
TrafficSign_SupplementarySign_Classification_Arrow::_internal_lane_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lane_id_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::Identifier>*
TrafficSign_SupplementarySign_Classification_Arrow::_internal_mutable_lane_id() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.lane_id_;
}

// repeated .osi3.TrafficSign.SupplementarySign.Classification.Arrow.Direction direction = 2;
inline int TrafficSign_SupplementarySign_Classification_Arrow::_internal_direction_size() const {
  return _internal_direction().size();
}
inline int TrafficSign_SupplementarySign_Classification_Arrow::direction_size() const {
  return _internal_direction_size();
}
inline void TrafficSign_SupplementarySign_Classification_Arrow::clear_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_.Clear();
}
inline ::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction TrafficSign_SupplementarySign_Classification_Arrow::direction(int index) const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.Arrow.direction)
  return static_cast<::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction>(_internal_direction().Get(index));
}
inline void TrafficSign_SupplementarySign_Classification_Arrow::set_direction(int index, ::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction value) {
  assert(::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction_IsValid(value));
  _internal_mutable_direction()->Set(index, value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.Arrow.direction)
}
inline void TrafficSign_SupplementarySign_Classification_Arrow::add_direction(::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction value) {
  assert(::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction_IsValid(value));
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_direction()->Add(value);
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.SupplementarySign.Classification.Arrow.direction)
}
inline const ::google::protobuf::RepeatedField<int>& TrafficSign_SupplementarySign_Classification_Arrow::direction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.SupplementarySign.Classification.Arrow.direction)
  return _internal_direction();
}
inline ::google::protobuf::RepeatedField<int>* TrafficSign_SupplementarySign_Classification_Arrow::mutable_direction()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.SupplementarySign.Classification.Arrow.direction)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_direction();
}
inline const ::google::protobuf::RepeatedField<int>& TrafficSign_SupplementarySign_Classification_Arrow::_internal_direction()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.direction_;
}
inline ::google::protobuf::RepeatedField<int>* TrafficSign_SupplementarySign_Classification_Arrow::_internal_mutable_direction() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.direction_;
}

// -------------------------------------------------------------------

// TrafficSign_SupplementarySign_Classification

// optional .osi3.TrafficSign.Variability variability = 1;
inline bool TrafficSign_SupplementarySign_Classification::has_variability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void TrafficSign_SupplementarySign_Classification::clear_variability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.variability_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::osi3::TrafficSign_Variability TrafficSign_SupplementarySign_Classification::variability() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.variability)
  return _internal_variability();
}
inline void TrafficSign_SupplementarySign_Classification::set_variability(::osi3::TrafficSign_Variability value) {
  _internal_set_variability(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.variability)
}
inline ::osi3::TrafficSign_Variability TrafficSign_SupplementarySign_Classification::_internal_variability() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::osi3::TrafficSign_Variability>(_impl_.variability_);
}
inline void TrafficSign_SupplementarySign_Classification::_internal_set_variability(::osi3::TrafficSign_Variability value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::osi3::TrafficSign_Variability_IsValid(value));
  _impl_.variability_ = value;
}

// optional .osi3.TrafficSign.SupplementarySign.Classification.Type type = 2;
inline bool TrafficSign_SupplementarySign_Classification::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void TrafficSign_SupplementarySign_Classification::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::osi3::TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::type() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.type)
  return _internal_type();
}
inline void TrafficSign_SupplementarySign_Classification::set_type(::osi3::TrafficSign_SupplementarySign_Classification_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.type)
}
inline ::osi3::TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::osi3::TrafficSign_SupplementarySign_Classification_Type>(_impl_.type_);
}
inline void TrafficSign_SupplementarySign_Classification::_internal_set_type(::osi3::TrafficSign_SupplementarySign_Classification_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::osi3::TrafficSign_SupplementarySign_Classification_Type_IsValid(value));
  _impl_.type_ = value;
}

// repeated .osi3.TrafficSignValue value = 3;
inline int TrafficSign_SupplementarySign_Classification::_internal_value_size() const {
  return _internal_value().size();
}
inline int TrafficSign_SupplementarySign_Classification::value_size() const {
  return _internal_value_size();
}
inline void TrafficSign_SupplementarySign_Classification::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Clear();
}
inline ::osi3::TrafficSignValue* TrafficSign_SupplementarySign_Classification::mutable_value(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.value)
  return _internal_mutable_value()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::TrafficSignValue>* TrafficSign_SupplementarySign_Classification::mutable_value()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.SupplementarySign.Classification.value)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_value();
}
inline const ::osi3::TrafficSignValue& TrafficSign_SupplementarySign_Classification::value(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.value)
  return _internal_value().Get(index);
}
inline ::osi3::TrafficSignValue* TrafficSign_SupplementarySign_Classification::add_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::TrafficSignValue* _add = _internal_mutable_value()->Add();
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.SupplementarySign.Classification.value)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::TrafficSignValue>& TrafficSign_SupplementarySign_Classification::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.SupplementarySign.Classification.value)
  return _internal_value();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::TrafficSignValue>&
TrafficSign_SupplementarySign_Classification::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::TrafficSignValue>*
TrafficSign_SupplementarySign_Classification::_internal_mutable_value() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.value_;
}

// repeated .osi3.Identifier assigned_lane_id = 4;
inline int TrafficSign_SupplementarySign_Classification::_internal_assigned_lane_id_size() const {
  return _internal_assigned_lane_id().size();
}
inline int TrafficSign_SupplementarySign_Classification::assigned_lane_id_size() const {
  return _internal_assigned_lane_id_size();
}
inline ::osi3::Identifier* TrafficSign_SupplementarySign_Classification::mutable_assigned_lane_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.assigned_lane_id)
  return _internal_mutable_assigned_lane_id()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::Identifier>* TrafficSign_SupplementarySign_Classification::mutable_assigned_lane_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.SupplementarySign.Classification.assigned_lane_id)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_assigned_lane_id();
}
inline const ::osi3::Identifier& TrafficSign_SupplementarySign_Classification::assigned_lane_id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.assigned_lane_id)
  return _internal_assigned_lane_id().Get(index);
}
inline ::osi3::Identifier* TrafficSign_SupplementarySign_Classification::add_assigned_lane_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::Identifier* _add = _internal_mutable_assigned_lane_id()->Add();
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.SupplementarySign.Classification.assigned_lane_id)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::Identifier>& TrafficSign_SupplementarySign_Classification::assigned_lane_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.SupplementarySign.Classification.assigned_lane_id)
  return _internal_assigned_lane_id();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::Identifier>&
TrafficSign_SupplementarySign_Classification::_internal_assigned_lane_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.assigned_lane_id_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::Identifier>*
TrafficSign_SupplementarySign_Classification::_internal_mutable_assigned_lane_id() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.assigned_lane_id_;
}

// repeated .osi3.TrafficSign.SupplementarySign.Classification.Actor actor = 5;
inline int TrafficSign_SupplementarySign_Classification::_internal_actor_size() const {
  return _internal_actor().size();
}
inline int TrafficSign_SupplementarySign_Classification::actor_size() const {
  return _internal_actor_size();
}
inline void TrafficSign_SupplementarySign_Classification::clear_actor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actor_.Clear();
}
inline ::osi3::TrafficSign_SupplementarySign_Classification_Actor TrafficSign_SupplementarySign_Classification::actor(int index) const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.actor)
  return static_cast<::osi3::TrafficSign_SupplementarySign_Classification_Actor>(_internal_actor().Get(index));
}
inline void TrafficSign_SupplementarySign_Classification::set_actor(int index, ::osi3::TrafficSign_SupplementarySign_Classification_Actor value) {
  assert(::osi3::TrafficSign_SupplementarySign_Classification_Actor_IsValid(value));
  _internal_mutable_actor()->Set(index, value);
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.actor)
}
inline void TrafficSign_SupplementarySign_Classification::add_actor(::osi3::TrafficSign_SupplementarySign_Classification_Actor value) {
  assert(::osi3::TrafficSign_SupplementarySign_Classification_Actor_IsValid(value));
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_actor()->Add(value);
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.SupplementarySign.Classification.actor)
}
inline const ::google::protobuf::RepeatedField<int>& TrafficSign_SupplementarySign_Classification::actor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.SupplementarySign.Classification.actor)
  return _internal_actor();
}
inline ::google::protobuf::RepeatedField<int>* TrafficSign_SupplementarySign_Classification::mutable_actor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.SupplementarySign.Classification.actor)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_actor();
}
inline const ::google::protobuf::RepeatedField<int>& TrafficSign_SupplementarySign_Classification::_internal_actor()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.actor_;
}
inline ::google::protobuf::RepeatedField<int>* TrafficSign_SupplementarySign_Classification::_internal_mutable_actor() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.actor_;
}

// repeated .osi3.TrafficSign.SupplementarySign.Classification.Arrow arrow = 6;
inline int TrafficSign_SupplementarySign_Classification::_internal_arrow_size() const {
  return _internal_arrow().size();
}
inline int TrafficSign_SupplementarySign_Classification::arrow_size() const {
  return _internal_arrow_size();
}
inline void TrafficSign_SupplementarySign_Classification::clear_arrow() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.arrow_.Clear();
}
inline ::osi3::TrafficSign_SupplementarySign_Classification_Arrow* TrafficSign_SupplementarySign_Classification::mutable_arrow(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.arrow)
  return _internal_mutable_arrow()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::TrafficSign_SupplementarySign_Classification_Arrow>* TrafficSign_SupplementarySign_Classification::mutable_arrow()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.SupplementarySign.Classification.arrow)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_arrow();
}
inline const ::osi3::TrafficSign_SupplementarySign_Classification_Arrow& TrafficSign_SupplementarySign_Classification::arrow(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.arrow)
  return _internal_arrow().Get(index);
}
inline ::osi3::TrafficSign_SupplementarySign_Classification_Arrow* TrafficSign_SupplementarySign_Classification::add_arrow() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::TrafficSign_SupplementarySign_Classification_Arrow* _add = _internal_mutable_arrow()->Add();
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.SupplementarySign.Classification.arrow)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::TrafficSign_SupplementarySign_Classification_Arrow>& TrafficSign_SupplementarySign_Classification::arrow() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.SupplementarySign.Classification.arrow)
  return _internal_arrow();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::TrafficSign_SupplementarySign_Classification_Arrow>&
TrafficSign_SupplementarySign_Classification::_internal_arrow() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.arrow_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::TrafficSign_SupplementarySign_Classification_Arrow>*
TrafficSign_SupplementarySign_Classification::_internal_mutable_arrow() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.arrow_;
}

// optional bool is_out_of_service = 7;
inline bool TrafficSign_SupplementarySign_Classification::has_is_out_of_service() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void TrafficSign_SupplementarySign_Classification::clear_is_out_of_service() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_out_of_service_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool TrafficSign_SupplementarySign_Classification::is_out_of_service() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.is_out_of_service)
  return _internal_is_out_of_service();
}
inline void TrafficSign_SupplementarySign_Classification::set_is_out_of_service(bool value) {
  _internal_set_is_out_of_service(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.is_out_of_service)
}
inline bool TrafficSign_SupplementarySign_Classification::_internal_is_out_of_service() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_out_of_service_;
}
inline void TrafficSign_SupplementarySign_Classification::_internal_set_is_out_of_service(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_out_of_service_ = value;
}

// optional string country = 8;
inline bool TrafficSign_SupplementarySign_Classification::has_country() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TrafficSign_SupplementarySign_Classification::clear_country() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.country_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrafficSign_SupplementarySign_Classification::country() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.country)
  return _internal_country();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrafficSign_SupplementarySign_Classification::set_country(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.country_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.country)
}
inline std::string* TrafficSign_SupplementarySign_Classification::mutable_country() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_country();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.country)
  return _s;
}
inline const std::string& TrafficSign_SupplementarySign_Classification::_internal_country() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.country_.Get();
}
inline void TrafficSign_SupplementarySign_Classification::_internal_set_country(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.country_.Set(value, GetArena());
}
inline std::string* TrafficSign_SupplementarySign_Classification::_internal_mutable_country() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.country_.Mutable( GetArena());
}
inline std::string* TrafficSign_SupplementarySign_Classification::release_country() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.SupplementarySign.Classification.country)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.country_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.country_.Set("", GetArena());
  }
  return released;
}
inline void TrafficSign_SupplementarySign_Classification::set_allocated_country(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.country_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.country_.IsDefault()) {
    _impl_.country_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.SupplementarySign.Classification.country)
}

// optional string country_revision = 9;
inline bool TrafficSign_SupplementarySign_Classification::has_country_revision() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TrafficSign_SupplementarySign_Classification::clear_country_revision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.country_revision_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TrafficSign_SupplementarySign_Classification::country_revision() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.country_revision)
  return _internal_country_revision();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrafficSign_SupplementarySign_Classification::set_country_revision(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.country_revision_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.country_revision)
}
inline std::string* TrafficSign_SupplementarySign_Classification::mutable_country_revision() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_country_revision();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.country_revision)
  return _s;
}
inline const std::string& TrafficSign_SupplementarySign_Classification::_internal_country_revision() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.country_revision_.Get();
}
inline void TrafficSign_SupplementarySign_Classification::_internal_set_country_revision(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.country_revision_.Set(value, GetArena());
}
inline std::string* TrafficSign_SupplementarySign_Classification::_internal_mutable_country_revision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.country_revision_.Mutable( GetArena());
}
inline std::string* TrafficSign_SupplementarySign_Classification::release_country_revision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.SupplementarySign.Classification.country_revision)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.country_revision_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.country_revision_.Set("", GetArena());
  }
  return released;
}
inline void TrafficSign_SupplementarySign_Classification::set_allocated_country_revision(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.country_revision_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.country_revision_.IsDefault()) {
    _impl_.country_revision_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.SupplementarySign.Classification.country_revision)
}

// optional string code = 10;
inline bool TrafficSign_SupplementarySign_Classification::has_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TrafficSign_SupplementarySign_Classification::clear_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TrafficSign_SupplementarySign_Classification::code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.code)
  return _internal_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrafficSign_SupplementarySign_Classification::set_code(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.code)
}
inline std::string* TrafficSign_SupplementarySign_Classification::mutable_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.code)
  return _s;
}
inline const std::string& TrafficSign_SupplementarySign_Classification::_internal_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.code_.Get();
}
inline void TrafficSign_SupplementarySign_Classification::_internal_set_code(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.code_.Set(value, GetArena());
}
inline std::string* TrafficSign_SupplementarySign_Classification::_internal_mutable_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.code_.Mutable( GetArena());
}
inline std::string* TrafficSign_SupplementarySign_Classification::release_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.SupplementarySign.Classification.code)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.code_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.code_.Set("", GetArena());
  }
  return released;
}
inline void TrafficSign_SupplementarySign_Classification::set_allocated_code(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.code_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.SupplementarySign.Classification.code)
}

// optional string sub_code = 11;
inline bool TrafficSign_SupplementarySign_Classification::has_sub_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TrafficSign_SupplementarySign_Classification::clear_sub_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sub_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TrafficSign_SupplementarySign_Classification::sub_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.sub_code)
  return _internal_sub_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrafficSign_SupplementarySign_Classification::set_sub_code(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sub_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.sub_code)
}
inline std::string* TrafficSign_SupplementarySign_Classification::mutable_sub_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sub_code();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.sub_code)
  return _s;
}
inline const std::string& TrafficSign_SupplementarySign_Classification::_internal_sub_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sub_code_.Get();
}
inline void TrafficSign_SupplementarySign_Classification::_internal_set_sub_code(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sub_code_.Set(value, GetArena());
}
inline std::string* TrafficSign_SupplementarySign_Classification::_internal_mutable_sub_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.sub_code_.Mutable( GetArena());
}
inline std::string* TrafficSign_SupplementarySign_Classification::release_sub_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.SupplementarySign.Classification.sub_code)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.sub_code_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.sub_code_.Set("", GetArena());
  }
  return released;
}
inline void TrafficSign_SupplementarySign_Classification::set_allocated_sub_code(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.sub_code_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sub_code_.IsDefault()) {
    _impl_.sub_code_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.SupplementarySign.Classification.sub_code)
}

// repeated .osi3.LogicalLaneAssignment logical_lane_assignment = 12;
inline int TrafficSign_SupplementarySign_Classification::_internal_logical_lane_assignment_size() const {
  return _internal_logical_lane_assignment().size();
}
inline int TrafficSign_SupplementarySign_Classification::logical_lane_assignment_size() const {
  return _internal_logical_lane_assignment_size();
}
inline ::osi3::LogicalLaneAssignment* TrafficSign_SupplementarySign_Classification::mutable_logical_lane_assignment(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.logical_lane_assignment)
  return _internal_mutable_logical_lane_assignment()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::LogicalLaneAssignment>* TrafficSign_SupplementarySign_Classification::mutable_logical_lane_assignment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.SupplementarySign.Classification.logical_lane_assignment)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_logical_lane_assignment();
}
inline const ::osi3::LogicalLaneAssignment& TrafficSign_SupplementarySign_Classification::logical_lane_assignment(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.logical_lane_assignment)
  return _internal_logical_lane_assignment().Get(index);
}
inline ::osi3::LogicalLaneAssignment* TrafficSign_SupplementarySign_Classification::add_logical_lane_assignment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::LogicalLaneAssignment* _add = _internal_mutable_logical_lane_assignment()->Add();
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.SupplementarySign.Classification.logical_lane_assignment)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::LogicalLaneAssignment>& TrafficSign_SupplementarySign_Classification::logical_lane_assignment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.SupplementarySign.Classification.logical_lane_assignment)
  return _internal_logical_lane_assignment();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::LogicalLaneAssignment>&
TrafficSign_SupplementarySign_Classification::_internal_logical_lane_assignment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.logical_lane_assignment_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::LogicalLaneAssignment>*
TrafficSign_SupplementarySign_Classification::_internal_mutable_logical_lane_assignment() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.logical_lane_assignment_;
}

// -------------------------------------------------------------------

// TrafficSign_SupplementarySign

// optional .osi3.BaseStationary base = 1;
inline bool TrafficSign_SupplementarySign::has_base() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_ != nullptr);
  return value;
}
inline const ::osi3::BaseStationary& TrafficSign_SupplementarySign::_internal_base() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::BaseStationary* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::BaseStationary&>(::osi3::_BaseStationary_default_instance_);
}
inline const ::osi3::BaseStationary& TrafficSign_SupplementarySign::base() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.base)
  return _internal_base();
}
inline void TrafficSign_SupplementarySign::unsafe_arena_set_allocated_base(::osi3::BaseStationary* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = reinterpret_cast<::osi3::BaseStationary*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.TrafficSign.SupplementarySign.base)
}
inline ::osi3::BaseStationary* TrafficSign_SupplementarySign::release_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::BaseStationary* released = _impl_.base_;
  _impl_.base_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::BaseStationary* TrafficSign_SupplementarySign::unsafe_arena_release_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.SupplementarySign.base)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::BaseStationary* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::osi3::BaseStationary* TrafficSign_SupplementarySign::_internal_mutable_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.base_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::BaseStationary>(GetArena());
    _impl_.base_ = reinterpret_cast<::osi3::BaseStationary*>(p);
  }
  return _impl_.base_;
}
inline ::osi3::BaseStationary* TrafficSign_SupplementarySign::mutable_base() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::osi3::BaseStationary* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.base)
  return _msg;
}
inline void TrafficSign_SupplementarySign::set_allocated_base(::osi3::BaseStationary* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.base_ = reinterpret_cast<::osi3::BaseStationary*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.SupplementarySign.base)
}

// optional .osi3.TrafficSign.SupplementarySign.Classification classification = 2;
inline bool TrafficSign_SupplementarySign::has_classification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.classification_ != nullptr);
  return value;
}
inline void TrafficSign_SupplementarySign::clear_classification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.classification_ != nullptr) _impl_.classification_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::osi3::TrafficSign_SupplementarySign_Classification& TrafficSign_SupplementarySign::_internal_classification() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::TrafficSign_SupplementarySign_Classification* p = _impl_.classification_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::TrafficSign_SupplementarySign_Classification&>(::osi3::_TrafficSign_SupplementarySign_Classification_default_instance_);
}
inline const ::osi3::TrafficSign_SupplementarySign_Classification& TrafficSign_SupplementarySign::classification() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.classification)
  return _internal_classification();
}
inline void TrafficSign_SupplementarySign::unsafe_arena_set_allocated_classification(::osi3::TrafficSign_SupplementarySign_Classification* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.classification_);
  }
  _impl_.classification_ = reinterpret_cast<::osi3::TrafficSign_SupplementarySign_Classification*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.TrafficSign.SupplementarySign.classification)
}
inline ::osi3::TrafficSign_SupplementarySign_Classification* TrafficSign_SupplementarySign::release_classification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::TrafficSign_SupplementarySign_Classification* released = _impl_.classification_;
  _impl_.classification_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::TrafficSign_SupplementarySign_Classification* TrafficSign_SupplementarySign::unsafe_arena_release_classification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.SupplementarySign.classification)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::TrafficSign_SupplementarySign_Classification* temp = _impl_.classification_;
  _impl_.classification_ = nullptr;
  return temp;
}
inline ::osi3::TrafficSign_SupplementarySign_Classification* TrafficSign_SupplementarySign::_internal_mutable_classification() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.classification_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::TrafficSign_SupplementarySign_Classification>(GetArena());
    _impl_.classification_ = reinterpret_cast<::osi3::TrafficSign_SupplementarySign_Classification*>(p);
  }
  return _impl_.classification_;
}
inline ::osi3::TrafficSign_SupplementarySign_Classification* TrafficSign_SupplementarySign::mutable_classification() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::osi3::TrafficSign_SupplementarySign_Classification* _msg = _internal_mutable_classification();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.classification)
  return _msg;
}
inline void TrafficSign_SupplementarySign::set_allocated_classification(::osi3::TrafficSign_SupplementarySign_Classification* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.classification_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.classification_ = reinterpret_cast<::osi3::TrafficSign_SupplementarySign_Classification*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.SupplementarySign.classification)
}

// optional string model_reference = 3;
inline bool TrafficSign_SupplementarySign::has_model_reference() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TrafficSign_SupplementarySign::clear_model_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_reference_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrafficSign_SupplementarySign::model_reference() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.model_reference)
  return _internal_model_reference();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrafficSign_SupplementarySign::set_model_reference(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.model_reference_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.model_reference)
}
inline std::string* TrafficSign_SupplementarySign::mutable_model_reference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_reference();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.model_reference)
  return _s;
}
inline const std::string& TrafficSign_SupplementarySign::_internal_model_reference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_reference_.Get();
}
inline void TrafficSign_SupplementarySign::_internal_set_model_reference(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.model_reference_.Set(value, GetArena());
}
inline std::string* TrafficSign_SupplementarySign::_internal_mutable_model_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.model_reference_.Mutable( GetArena());
}
inline std::string* TrafficSign_SupplementarySign::release_model_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.SupplementarySign.model_reference)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.model_reference_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.model_reference_.Set("", GetArena());
  }
  return released;
}
inline void TrafficSign_SupplementarySign::set_allocated_model_reference(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.model_reference_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.model_reference_.IsDefault()) {
    _impl_.model_reference_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.SupplementarySign.model_reference)
}

// -------------------------------------------------------------------

// TrafficSign

// optional .osi3.Identifier id = 1;
inline bool TrafficSign::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::osi3::Identifier& TrafficSign::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Identifier* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Identifier&>(::osi3::_Identifier_default_instance_);
}
inline const ::osi3::Identifier& TrafficSign::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.id)
  return _internal_id();
}
inline void TrafficSign::unsafe_arena_set_allocated_id(::osi3::Identifier* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::osi3::Identifier*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.TrafficSign.id)
}
inline ::osi3::Identifier* TrafficSign::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Identifier* released = _impl_.id_;
  _impl_.id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Identifier* TrafficSign::unsafe_arena_release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Identifier* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* TrafficSign::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Identifier>(GetArena());
    _impl_.id_ = reinterpret_cast<::osi3::Identifier*>(p);
  }
  return _impl_.id_;
}
inline ::osi3::Identifier* TrafficSign::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::Identifier* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.id)
  return _msg;
}
inline void TrafficSign::set_allocated_id(::osi3::Identifier* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::osi3::Identifier*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.id)
}

// optional .osi3.TrafficSign.MainSign main_sign = 2;
inline bool TrafficSign::has_main_sign() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.main_sign_ != nullptr);
  return value;
}
inline void TrafficSign::clear_main_sign() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.main_sign_ != nullptr) _impl_.main_sign_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::osi3::TrafficSign_MainSign& TrafficSign::_internal_main_sign() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::TrafficSign_MainSign* p = _impl_.main_sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::TrafficSign_MainSign&>(::osi3::_TrafficSign_MainSign_default_instance_);
}
inline const ::osi3::TrafficSign_MainSign& TrafficSign::main_sign() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.main_sign)
  return _internal_main_sign();
}
inline void TrafficSign::unsafe_arena_set_allocated_main_sign(::osi3::TrafficSign_MainSign* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.main_sign_);
  }
  _impl_.main_sign_ = reinterpret_cast<::osi3::TrafficSign_MainSign*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.TrafficSign.main_sign)
}
inline ::osi3::TrafficSign_MainSign* TrafficSign::release_main_sign() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::TrafficSign_MainSign* released = _impl_.main_sign_;
  _impl_.main_sign_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::TrafficSign_MainSign* TrafficSign::unsafe_arena_release_main_sign() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.main_sign)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::TrafficSign_MainSign* temp = _impl_.main_sign_;
  _impl_.main_sign_ = nullptr;
  return temp;
}
inline ::osi3::TrafficSign_MainSign* TrafficSign::_internal_mutable_main_sign() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.main_sign_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::TrafficSign_MainSign>(GetArena());
    _impl_.main_sign_ = reinterpret_cast<::osi3::TrafficSign_MainSign*>(p);
  }
  return _impl_.main_sign_;
}
inline ::osi3::TrafficSign_MainSign* TrafficSign::mutable_main_sign() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::osi3::TrafficSign_MainSign* _msg = _internal_mutable_main_sign();
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.main_sign)
  return _msg;
}
inline void TrafficSign::set_allocated_main_sign(::osi3::TrafficSign_MainSign* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.main_sign_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.main_sign_ = reinterpret_cast<::osi3::TrafficSign_MainSign*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.main_sign)
}

// repeated .osi3.TrafficSign.SupplementarySign supplementary_sign = 3;
inline int TrafficSign::_internal_supplementary_sign_size() const {
  return _internal_supplementary_sign().size();
}
inline int TrafficSign::supplementary_sign_size() const {
  return _internal_supplementary_sign_size();
}
inline void TrafficSign::clear_supplementary_sign() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.supplementary_sign_.Clear();
}
inline ::osi3::TrafficSign_SupplementarySign* TrafficSign::mutable_supplementary_sign(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.supplementary_sign)
  return _internal_mutable_supplementary_sign()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::TrafficSign_SupplementarySign>* TrafficSign::mutable_supplementary_sign()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.supplementary_sign)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_supplementary_sign();
}
inline const ::osi3::TrafficSign_SupplementarySign& TrafficSign::supplementary_sign(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.supplementary_sign)
  return _internal_supplementary_sign().Get(index);
}
inline ::osi3::TrafficSign_SupplementarySign* TrafficSign::add_supplementary_sign() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::TrafficSign_SupplementarySign* _add = _internal_mutable_supplementary_sign()->Add();
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.supplementary_sign)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::TrafficSign_SupplementarySign>& TrafficSign::supplementary_sign() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.supplementary_sign)
  return _internal_supplementary_sign();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::TrafficSign_SupplementarySign>&
TrafficSign::_internal_supplementary_sign() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.supplementary_sign_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::TrafficSign_SupplementarySign>*
TrafficSign::_internal_mutable_supplementary_sign() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.supplementary_sign_;
}

// repeated .osi3.ExternalReference source_reference = 4;
inline int TrafficSign::_internal_source_reference_size() const {
  return _internal_source_reference().size();
}
inline int TrafficSign::source_reference_size() const {
  return _internal_source_reference_size();
}
inline ::osi3::ExternalReference* TrafficSign::mutable_source_reference(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.source_reference)
  return _internal_mutable_source_reference()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::ExternalReference>* TrafficSign::mutable_source_reference()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.source_reference)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_source_reference();
}
inline const ::osi3::ExternalReference& TrafficSign::source_reference(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.source_reference)
  return _internal_source_reference().Get(index);
}
inline ::osi3::ExternalReference* TrafficSign::add_source_reference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::ExternalReference* _add = _internal_mutable_source_reference()->Add();
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.source_reference)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::ExternalReference>& TrafficSign::source_reference() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.source_reference)
  return _internal_source_reference();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::ExternalReference>&
TrafficSign::_internal_source_reference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.source_reference_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::ExternalReference>*
TrafficSign::_internal_mutable_source_reference() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.source_reference_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace osi3


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::osi3::TrafficSignValue_Unit> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::osi3::TrafficSignValue_Unit>() {
  return ::osi3::TrafficSignValue_Unit_descriptor();
}
template <>
struct is_proto_enum<::osi3::TrafficSign_MainSign_Classification_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::osi3::TrafficSign_MainSign_Classification_Type>() {
  return ::osi3::TrafficSign_MainSign_Classification_Type_descriptor();
}
template <>
struct is_proto_enum<::osi3::TrafficSign_MainSign_Classification_DirectionScope> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::osi3::TrafficSign_MainSign_Classification_DirectionScope>() {
  return ::osi3::TrafficSign_MainSign_Classification_DirectionScope_descriptor();
}
template <>
struct is_proto_enum<::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction>() {
  return ::osi3::TrafficSign_SupplementarySign_Classification_Arrow_Direction_descriptor();
}
template <>
struct is_proto_enum<::osi3::TrafficSign_SupplementarySign_Classification_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::osi3::TrafficSign_SupplementarySign_Classification_Type>() {
  return ::osi3::TrafficSign_SupplementarySign_Classification_Type_descriptor();
}
template <>
struct is_proto_enum<::osi3::TrafficSign_SupplementarySign_Classification_Actor> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::osi3::TrafficSign_SupplementarySign_Classification_Actor>() {
  return ::osi3::TrafficSign_SupplementarySign_Classification_Actor_descriptor();
}
template <>
struct is_proto_enum<::osi3::TrafficSign_Variability> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::osi3::TrafficSign_Variability>() {
  return ::osi3::TrafficSign_Variability_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // osi_5ftrafficsign_2eproto_2epb_2eh
