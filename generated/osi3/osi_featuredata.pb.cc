// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: osi_featuredata.proto
// Protobuf C++ Version: 5.29.5

#include "osi_featuredata.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace osi3 {

inline constexpr UltrasonicDetectionSpecificHeader::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        max_range_{0},
        number_of_valid_indirect_detections_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR UltrasonicDetectionSpecificHeader::UltrasonicDetectionSpecificHeader(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UltrasonicDetectionSpecificHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UltrasonicDetectionSpecificHeaderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UltrasonicDetectionSpecificHeaderDefaultTypeInternal() {}
  union {
    UltrasonicDetectionSpecificHeader _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UltrasonicDetectionSpecificHeaderDefaultTypeInternal _UltrasonicDetectionSpecificHeader_default_instance_;

inline constexpr CameraDetectionSpecificHeader::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        number_of_valid_points_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR CameraDetectionSpecificHeader::CameraDetectionSpecificHeader(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CameraDetectionSpecificHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CameraDetectionSpecificHeaderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CameraDetectionSpecificHeaderDefaultTypeInternal() {}
  union {
    CameraDetectionSpecificHeader _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CameraDetectionSpecificHeaderDefaultTypeInternal _CameraDetectionSpecificHeader_default_instance_;

inline constexpr UltrasonicIndirectDetection::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        object_id_{nullptr},
        receiver_id_{nullptr},
        receiver_origin_{nullptr},
        existence_probability_{0},
        ellipsoid_radial_{0},
        ellipsoid_axial_{0} {}

template <typename>
PROTOBUF_CONSTEXPR UltrasonicIndirectDetection::UltrasonicIndirectDetection(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UltrasonicIndirectDetectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UltrasonicIndirectDetectionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UltrasonicIndirectDetectionDefaultTypeInternal() {}
  union {
    UltrasonicIndirectDetection _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UltrasonicIndirectDetectionDefaultTypeInternal _UltrasonicIndirectDetection_default_instance_;

inline constexpr UltrasonicDetection::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        object_id_{nullptr},
        existence_probability_{0},
        distance_{0} {}

template <typename>
PROTOBUF_CONSTEXPR UltrasonicDetection::UltrasonicDetection(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UltrasonicDetectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UltrasonicDetectionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UltrasonicDetectionDefaultTypeInternal() {}
  union {
    UltrasonicDetection _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UltrasonicDetectionDefaultTypeInternal _UltrasonicDetection_default_instance_;

inline constexpr RadarDetection::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        object_id_{nullptr},
        position_{nullptr},
        position_rmse_{nullptr},
        ambiguity_id_{nullptr},
        existence_probability_{0},
        radial_velocity_{0},
        radial_velocity_rmse_{0},
        rcs_{0},
        snr_{0},
        point_target_probability_{0},
        classification_{static_cast< ::osi3::DetectionClassification >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR RadarDetection::RadarDetection(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RadarDetectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RadarDetectionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RadarDetectionDefaultTypeInternal() {}
  union {
    RadarDetection _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RadarDetectionDefaultTypeInternal _RadarDetection_default_instance_;

inline constexpr LidarDetection::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        object_id_{nullptr},
        position_{nullptr},
        position_rmse_{nullptr},
        existence_probability_{0},
        height_{0},
        height_rmse_{0},
        intensity_{0},
        free_space_probability_{0},
        reflectivity_{0},
        echo_pulse_width_{0},
        classification_{static_cast< ::osi3::DetectionClassification >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR LidarDetection::LidarDetection(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LidarDetectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LidarDetectionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LidarDetectionDefaultTypeInternal() {}
  union {
    LidarDetection _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LidarDetectionDefaultTypeInternal _LidarDetection_default_instance_;

inline constexpr CameraPoint::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        point_{nullptr},
        point_rmse_{nullptr},
        existence_probability_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CameraPoint::CameraPoint(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CameraPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CameraPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CameraPointDefaultTypeInternal() {}
  union {
    CameraPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CameraPointDefaultTypeInternal _CameraPoint_default_instance_;

inline constexpr SensorDetectionHeader::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        measurement_time_{nullptr},
        mounting_position_{nullptr},
        mounting_position_rmse_{nullptr},
        sensor_id_{nullptr},
        cycle_counter_{::uint64_t{0u}},
        data_qualifier_{static_cast< ::osi3::SensorDetectionHeader_DataQualifier >(0)},
        number_of_valid_detections_{0u},
        extended_qualifier_{static_cast< ::osi3::SensorDetectionHeader_ExtendedQualifier >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR SensorDetectionHeader::SensorDetectionHeader(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SensorDetectionHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SensorDetectionHeaderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SensorDetectionHeaderDefaultTypeInternal() {}
  union {
    SensorDetectionHeader _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SensorDetectionHeaderDefaultTypeInternal _SensorDetectionHeader_default_instance_;

inline constexpr CameraDetection::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        object_id_{nullptr},
        time_difference_{nullptr},
        ambiguity_id_{nullptr},
        color_description_{nullptr},
        existence_probability_{0},
        image_shape_type_{static_cast< ::osi3::CameraDetection_ImageShapeType >(0)},
        shape_classification_background_{false},
        shape_classification_foreground_{false},
        shape_classification_flat_{false},
        shape_classification_upright_{false},
        shape_classification_ground_{false},
        shape_classification_sky_{false},
        shape_classification_vegetation_{false},
        shape_classification_road_{false},
        shape_classification_non_driving_lane_{false},
        shape_classification_non_road_{false},
        shape_classification_stationary_object_{false},
        shape_classification_moving_object_{false},
        shape_classification_landmark_{false},
        shape_classification_traffic_sign_{false},
        shape_classification_traffic_light_{false},
        shape_classification_road_marking_{false},
        shape_classification_vehicle_{false},
        shape_classification_pedestrian_{false},
        shape_classification_animal_{false},
        shape_classification_pedestrian_front_{false},
        shape_classification_pedestrian_side_{false},
        shape_classification_pedestrian_rear_{false},
        color_{static_cast< ::osi3::CameraDetection_Color >(0)},
        shape_classification_probability_{0},
        color_probability_{0},
        first_point_index_{0u},
        number_of_points_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR CameraDetection::CameraDetection(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CameraDetectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CameraDetectionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CameraDetectionDefaultTypeInternal() {}
  union {
    CameraDetection _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CameraDetectionDefaultTypeInternal _CameraDetection_default_instance_;

inline constexpr UltrasonicDetectionData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        detection_{},
        indirect_detection_{},
        header_{nullptr},
        specific_header_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR UltrasonicDetectionData::UltrasonicDetectionData(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UltrasonicDetectionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UltrasonicDetectionDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UltrasonicDetectionDataDefaultTypeInternal() {}
  union {
    UltrasonicDetectionData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UltrasonicDetectionDataDefaultTypeInternal _UltrasonicDetectionData_default_instance_;

inline constexpr RadarDetectionData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        detection_{},
        header_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR RadarDetectionData::RadarDetectionData(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RadarDetectionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RadarDetectionDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RadarDetectionDataDefaultTypeInternal() {}
  union {
    RadarDetectionData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RadarDetectionDataDefaultTypeInternal _RadarDetectionData_default_instance_;

inline constexpr LidarDetectionData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        detection_{},
        header_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR LidarDetectionData::LidarDetectionData(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LidarDetectionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LidarDetectionDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LidarDetectionDataDefaultTypeInternal() {}
  union {
    LidarDetectionData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LidarDetectionDataDefaultTypeInternal _LidarDetectionData_default_instance_;

inline constexpr CameraDetectionData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        detection_{},
        point_{},
        header_{nullptr},
        specific_header_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR CameraDetectionData::CameraDetectionData(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CameraDetectionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CameraDetectionDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CameraDetectionDataDefaultTypeInternal() {}
  union {
    CameraDetectionData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CameraDetectionDataDefaultTypeInternal _CameraDetectionData_default_instance_;

inline constexpr FeatureData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        radar_sensor_{},
        lidar_sensor_{},
        ultrasonic_sensor_{},
        camera_sensor_{},
        version_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR FeatureData::FeatureData(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct FeatureDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeatureDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeatureDataDefaultTypeInternal() {}
  union {
    FeatureData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeatureDataDefaultTypeInternal _FeatureData_default_instance_;
}  // namespace osi3
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_osi_5ffeaturedata_2eproto[5];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_osi_5ffeaturedata_2eproto = nullptr;
const ::uint32_t
    TableStruct_osi_5ffeaturedata_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, _impl_.version_),
        PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, _impl_.radar_sensor_),
        PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, _impl_.lidar_sensor_),
        PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, _impl_.ultrasonic_sensor_),
        PROTOBUF_FIELD_OFFSET(::osi3::FeatureData, _impl_.camera_sensor_),
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_.measurement_time_),
        PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_.cycle_counter_),
        PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_.mounting_position_),
        PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_.mounting_position_rmse_),
        PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_.data_qualifier_),
        PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_.number_of_valid_detections_),
        PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_.sensor_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::SensorDetectionHeader, _impl_.extended_qualifier_),
        0,
        4,
        1,
        2,
        5,
        6,
        3,
        7,
        PROTOBUF_FIELD_OFFSET(::osi3::RadarDetectionData, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::RadarDetectionData, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::RadarDetectionData, _impl_.header_),
        PROTOBUF_FIELD_OFFSET(::osi3::RadarDetectionData, _impl_.detection_),
        0,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.existence_probability_),
        PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.object_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.position_),
        PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.position_rmse_),
        PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.radial_velocity_),
        PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.radial_velocity_rmse_),
        PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.rcs_),
        PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.snr_),
        PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.point_target_probability_),
        PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.ambiguity_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::RadarDetection, _impl_.classification_),
        4,
        0,
        1,
        2,
        5,
        6,
        7,
        8,
        9,
        3,
        10,
        PROTOBUF_FIELD_OFFSET(::osi3::LidarDetectionData, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::LidarDetectionData, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::LidarDetectionData, _impl_.header_),
        PROTOBUF_FIELD_OFFSET(::osi3::LidarDetectionData, _impl_.detection_),
        0,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.existence_probability_),
        PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.object_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.position_),
        PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.position_rmse_),
        PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.height_),
        PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.height_rmse_),
        PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.intensity_),
        PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.free_space_probability_),
        PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.classification_),
        PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.reflectivity_),
        PROTOBUF_FIELD_OFFSET(::osi3::LidarDetection, _impl_.echo_pulse_width_),
        3,
        0,
        1,
        2,
        4,
        5,
        6,
        7,
        10,
        8,
        9,
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionSpecificHeader, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionSpecificHeader, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionSpecificHeader, _impl_.max_range_),
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionSpecificHeader, _impl_.number_of_valid_indirect_detections_),
        0,
        1,
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, _impl_.header_),
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, _impl_.specific_header_),
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, _impl_.detection_),
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetectionData, _impl_.indirect_detection_),
        0,
        1,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetection, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetection, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetection, _impl_.existence_probability_),
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetection, _impl_.object_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicDetection, _impl_.distance_),
        1,
        0,
        2,
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _impl_.existence_probability_),
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _impl_.object_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _impl_.ellipsoid_radial_),
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _impl_.ellipsoid_axial_),
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _impl_.receiver_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::UltrasonicIndirectDetection, _impl_.receiver_origin_),
        3,
        0,
        4,
        5,
        1,
        2,
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionSpecificHeader, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionSpecificHeader, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionSpecificHeader, _impl_.number_of_valid_points_),
        0,
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, _impl_.header_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, _impl_.specific_header_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, _impl_.detection_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetectionData, _impl_.point_),
        0,
        1,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.existence_probability_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.object_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.time_difference_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.image_shape_type_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_background_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_foreground_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_flat_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_upright_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_ground_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_sky_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_vegetation_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_road_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_non_driving_lane_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_non_road_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_stationary_object_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_moving_object_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_landmark_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_traffic_sign_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_traffic_light_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_road_marking_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_vehicle_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_pedestrian_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_animal_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_pedestrian_front_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_pedestrian_side_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_pedestrian_rear_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.shape_classification_probability_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.color_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.color_probability_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.ambiguity_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.first_point_index_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.number_of_points_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraDetection, _impl_.color_description_),
        4,
        0,
        1,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        29,
        28,
        30,
        2,
        31,
        32,
        3,
        PROTOBUF_FIELD_OFFSET(::osi3::CameraPoint, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraPoint, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::CameraPoint, _impl_.existence_probability_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraPoint, _impl_.point_),
        PROTOBUF_FIELD_OFFSET(::osi3::CameraPoint, _impl_.point_rmse_),
        2,
        0,
        1,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, 13, -1, sizeof(::osi3::FeatureData)},
        {18, 34, -1, sizeof(::osi3::SensorDetectionHeader)},
        {42, 52, -1, sizeof(::osi3::RadarDetectionData)},
        {54, 73, -1, sizeof(::osi3::RadarDetection)},
        {84, 94, -1, sizeof(::osi3::LidarDetectionData)},
        {96, 115, -1, sizeof(::osi3::LidarDetection)},
        {126, 136, -1, sizeof(::osi3::UltrasonicDetectionSpecificHeader)},
        {138, 150, -1, sizeof(::osi3::UltrasonicDetectionData)},
        {154, 165, -1, sizeof(::osi3::UltrasonicDetection)},
        {168, 182, -1, sizeof(::osi3::UltrasonicIndirectDetection)},
        {188, 197, -1, sizeof(::osi3::CameraDetectionSpecificHeader)},
        {198, 210, -1, sizeof(::osi3::CameraDetectionData)},
        {214, 255, -1, sizeof(::osi3::CameraDetection)},
        {288, 299, -1, sizeof(::osi3::CameraPoint)},
};
static const ::_pb::Message* const file_default_instances[] = {
    &::osi3::_FeatureData_default_instance_._instance,
    &::osi3::_SensorDetectionHeader_default_instance_._instance,
    &::osi3::_RadarDetectionData_default_instance_._instance,
    &::osi3::_RadarDetection_default_instance_._instance,
    &::osi3::_LidarDetectionData_default_instance_._instance,
    &::osi3::_LidarDetection_default_instance_._instance,
    &::osi3::_UltrasonicDetectionSpecificHeader_default_instance_._instance,
    &::osi3::_UltrasonicDetectionData_default_instance_._instance,
    &::osi3::_UltrasonicDetection_default_instance_._instance,
    &::osi3::_UltrasonicIndirectDetection_default_instance_._instance,
    &::osi3::_CameraDetectionSpecificHeader_default_instance_._instance,
    &::osi3::_CameraDetectionData_default_instance_._instance,
    &::osi3::_CameraDetection_default_instance_._instance,
    &::osi3::_CameraPoint_default_instance_._instance,
};
const char descriptor_table_protodef_osi_5ffeaturedata_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\025osi_featuredata.proto\022\004osi3\032\021osi_versi"
    "on.proto\032\020osi_common.proto\"\202\002\n\013FeatureDa"
    "ta\022\'\n\007version\030\001 \001(\0132\026.osi3.InterfaceVers"
    "ion\022.\n\014radar_sensor\030\002 \003(\0132\030.osi3.RadarDe"
    "tectionData\022.\n\014lidar_sensor\030\003 \003(\0132\030.osi3"
    ".LidarDetectionData\0228\n\021ultrasonic_sensor"
    "\030\004 \003(\0132\035.osi3.UltrasonicDetectionData\0220\n"
    "\rcamera_sensor\030\005 \003(\0132\031.osi3.CameraDetect"
    "ionData\"\352\t\n\025SensorDetectionHeader\022)\n\020mea"
    "surement_time\030\001 \001(\0132\017.osi3.Timestamp\022\025\n\r"
    "cycle_counter\030\002 \001(\004\0221\n\021mounting_position"
    "\030\003 \001(\0132\026.osi3.MountingPosition\0226\n\026mounti"
    "ng_position_rmse\030\004 \001(\0132\026.osi3.MountingPo"
    "sition\022A\n\016data_qualifier\030\005 \001(\0162).osi3.Se"
    "nsorDetectionHeader.DataQualifier\022\"\n\032num"
    "ber_of_valid_detections\030\006 \001(\r\022#\n\tsensor_"
    "id\030\007 \001(\0132\020.osi3.Identifier\022I\n\022extended_q"
    "ualifier\030\010 \001(\0162-.osi3.SensorDetectionHea"
    "der.ExtendedQualifier\"\215\002\n\rDataQualifier\022"
    "\032\n\026DATA_QUALIFIER_UNKNOWN\020\000\022\030\n\024DATA_QUAL"
    "IFIER_OTHER\020\001\022\034\n\030DATA_QUALIFIER_AVAILABL"
    "E\020\002\022$\n DATA_QUALIFIER_AVAILABLE_REDUCED\020"
    "\003\022 \n\034DATA_QUALIFIER_NOT_AVAILABLE\020\004\022\034\n\030D"
    "ATA_QUALIFIER_BLINDNESS\020\005\022&\n\"DATA_QUALIF"
    "IER_TEMPORARY_AVAILABLE\020\006\022\032\n\026DATA_QUALIF"
    "IER_INVALID\020\007\"\274\004\n\021ExtendedQualifier\022\036\n\032E"
    "XTENDED_QUALIFIER_UNKNOWN\020\000\022\034\n\030EXTENDED_"
    "QUALIFIER_OTHER\020\001\022,\n(EXTENDED_QUALIFIER_"
    "NORMAL_OPERATION_MODE\020\002\022\'\n#EXTENDED_QUAL"
    "IFIER_POWER_UP_OR_DOWN\020\003\022,\n(EXTENDED_QUA"
    "LIFIER_SENSOR_NOT_CALIBRATED\020\004\022%\n!EXTEND"
    "ED_QUALIFIER_SENSOR_BLOCKED\020\005\022(\n$EXTENDE"
    "D_QUALIFIER_SENSOR_MISALIGNED\020\006\0229\n5EXTEN"
    "DED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_C"
    "ONDITION\020\007\022,\n(EXTENDED_QUALIFIER_REDUCED"
    "_FIELD_OF_VIEW\020\010\022*\n&EXTENDED_QUALIFIER_I"
    "NPUT_NOT_AVAILABLE\020\t\022&\n\"EXTENDED_QUALIFI"
    "ER_INTERNAL_REASON\020\n\022+\n\'EXTENDED_QUALIFI"
    "ER_EXTERNAL_DISTURBANCE\020\013\022)\n%EXTENDED_QU"
    "ALIFIER_BEGINNING_BLOCKAGE\020\014\"j\n\022RadarDet"
    "ectionData\022+\n\006header\030\001 \001(\0132\033.osi3.Sensor"
    "DetectionHeader\022\'\n\tdetection\030\002 \003(\0132\024.osi"
    "3.RadarDetection\"\365\002\n\016RadarDetection\022\035\n\025e"
    "xistence_probability\030\001 \001(\001\022#\n\tobject_id\030"
    "\002 \001(\0132\020.osi3.Identifier\022#\n\010position\030\003 \001("
    "\0132\021.osi3.Spherical3d\022(\n\rposition_rmse\030\004 "
    "\001(\0132\021.osi3.Spherical3d\022\027\n\017radial_velocit"
    "y\030\005 \001(\001\022\034\n\024radial_velocity_rmse\030\006 \001(\001\022\013\n"
    "\003rcs\030\007 \001(\001\022\013\n\003snr\030\010 \001(\001\022 \n\030point_target_"
    "probability\030\t \001(\001\022&\n\014ambiguity_id\030\n \001(\0132"
    "\020.osi3.Identifier\0225\n\016classification\030\013 \001("
    "\0162\035.osi3.DetectionClassification\"j\n\022Lida"
    "rDetectionData\022+\n\006header\030\001 \001(\0132\033.osi3.Se"
    "nsorDetectionHeader\022\'\n\tdetection\030\002 \003(\0132\024"
    ".osi3.LidarDetection\"\342\002\n\016LidarDetection\022"
    "\035\n\025existence_probability\030\001 \001(\001\022#\n\tobject"
    "_id\030\002 \001(\0132\020.osi3.Identifier\022#\n\010position\030"
    "\003 \001(\0132\021.osi3.Spherical3d\022(\n\rposition_rms"
    "e\030\004 \001(\0132\021.osi3.Spherical3d\022\016\n\006height\030\005 \001"
    "(\001\022\023\n\013height_rmse\030\006 \001(\001\022\021\n\tintensity\030\007 \001"
    "(\001\022\036\n\026free_space_probability\030\010 \001(\001\0225\n\016cl"
    "assification\030\t \001(\0162\035.osi3.DetectionClass"
    "ification\022\024\n\014reflectivity\030\n \001(\001\022\030\n\020echo_"
    "pulse_width\030\013 \001(\001\"c\n!UltrasonicDetection"
    "SpecificHeader\022\021\n\tmax_range\030\001 \001(\001\022+\n#num"
    "ber_of_valid_indirect_detections\030\002 \001(\r\"\365"
    "\001\n\027UltrasonicDetectionData\022+\n\006header\030\001 \001"
    "(\0132\033.osi3.SensorDetectionHeader\022@\n\017speci"
    "fic_header\030\003 \001(\0132\'.osi3.UltrasonicDetect"
    "ionSpecificHeader\022,\n\tdetection\030\002 \003(\0132\031.o"
    "si3.UltrasonicDetection\022=\n\022indirect_dete"
    "ction\030\004 \003(\0132!.osi3.UltrasonicIndirectDet"
    "ection\"k\n\023UltrasonicDetection\022\035\n\025existen"
    "ce_probability\030\001 \001(\001\022#\n\tobject_id\030\002 \001(\0132"
    "\020.osi3.Identifier\022\020\n\010distance\030\003 \001(\001\"\344\001\n\033"
    "UltrasonicIndirectDetection\022\035\n\025existence"
    "_probability\030\001 \001(\001\022#\n\tobject_id\030\002 \001(\0132\020."
    "osi3.Identifier\022\030\n\020ellipsoid_radial\030\003 \001("
    "\001\022\027\n\017ellipsoid_axial\030\004 \001(\001\022%\n\013receiver_i"
    "d\030\005 \001(\0132\020.osi3.Identifier\022\'\n\017receiver_or"
    "igin\030\006 \001(\0132\016.osi3.Vector3d\"\?\n\035CameraDete"
    "ctionSpecificHeader\022\036\n\026number_of_valid_p"
    "oints\030\001 \001(\r\"\314\001\n\023CameraDetectionData\022+\n\006h"
    "eader\030\001 \001(\0132\033.osi3.SensorDetectionHeader"
    "\022<\n\017specific_header\030\003 \001(\0132#.osi3.CameraD"
    "etectionSpecificHeader\022(\n\tdetection\030\002 \003("
    "\0132\025.osi3.CameraDetection\022 \n\005point\030\004 \003(\0132"
    "\021.osi3.CameraPoint\"\244\016\n\017CameraDetection\022\035"
    "\n\025existence_probability\030\001 \001(\001\022#\n\tobject_"
    "id\030\002 \001(\0132\020.osi3.Identifier\022(\n\017time_diffe"
    "rence\030\003 \001(\0132\017.osi3.Timestamp\022>\n\020image_sh"
    "ape_type\030\004 \001(\0162$.osi3.CameraDetection.Im"
    "ageShapeType\022\'\n\037shape_classification_bac"
    "kground\030\005 \001(\010\022\'\n\037shape_classification_fo"
    "reground\030\006 \001(\010\022!\n\031shape_classification_f"
    "lat\030\007 \001(\010\022$\n\034shape_classification_uprigh"
    "t\030\010 \001(\010\022#\n\033shape_classification_ground\030\t"
    " \001(\010\022 \n\030shape_classification_sky\030\n \001(\010\022\'"
    "\n\037shape_classification_vegetation\030\013 \001(\010\022"
    "!\n\031shape_classification_road\030\014 \001(\010\022-\n%sh"
    "ape_classification_non_driving_lane\030\r \001("
    "\010\022%\n\035shape_classification_non_road\030\016 \001(\010"
    "\022.\n&shape_classification_stationary_obje"
    "ct\030\017 \001(\010\022*\n\"shape_classification_moving_"
    "object\030\020 \001(\010\022%\n\035shape_classification_lan"
    "dmark\030\021 \001(\010\022)\n!shape_classification_traf"
    "fic_sign\030\022 \001(\010\022*\n\"shape_classification_t"
    "raffic_light\030\023 \001(\010\022)\n!shape_classificati"
    "on_road_marking\030\024 \001(\010\022$\n\034shape_classific"
    "ation_vehicle\030\025 \001(\010\022\'\n\037shape_classificat"
    "ion_pedestrian\030\026 \001(\010\022#\n\033shape_classifica"
    "tion_animal\030\027 \001(\010\022-\n%shape_classificatio"
    "n_pedestrian_front\030\030 \001(\010\022,\n$shape_classi"
    "fication_pedestrian_side\030\031 \001(\010\022,\n$shape_"
    "classification_pedestrian_rear\030\032 \001(\010\022(\n "
    "shape_classification_probability\030\033 \001(\001\022*"
    "\n\005color\030\034 \001(\0162\033.osi3.CameraDetection.Col"
    "or\022\031\n\021color_probability\030\035 \001(\001\022&\n\014ambigui"
    "ty_id\030\036 \001(\0132\020.osi3.Identifier\022\031\n\021first_p"
    "oint_index\030\037 \001(\r\022\030\n\020number_of_points\030  \001"
    "(\r\0221\n\021color_description\030! \001(\0132\026.osi3.Col"
    "orDescription\"\331\001\n\005Color\022\021\n\rCOLOR_UNKNOWN"
    "\020\000\022\017\n\013COLOR_OTHER\020\001\022\017\n\013COLOR_BLACK\020\002\022\016\n\n"
    "COLOR_GREY\020\003\022\017\n\013COLOR_WHITE\020\004\022\020\n\014COLOR_Y"
    "ELLOW\020\005\022\020\n\014COLOR_ORANGE\020\006\022\r\n\tCOLOR_RED\020\007"
    "\022\020\n\014COLOR_VIOLET\020\010\022\016\n\nCOLOR_BLUE\020\t\022\017\n\013CO"
    "LOR_GREEN\020\n\022\024\n\020COLOR_REFLECTIVE\020\013\"\375\001\n\016Im"
    "ageShapeType\022\034\n\030IMAGE_SHAPE_TYPE_UNKNOWN"
    "\020\000\022\032\n\026IMAGE_SHAPE_TYPE_OTHER\020\001\022\032\n\026IMAGE_"
    "SHAPE_TYPE_POINT\020\002\022\030\n\024IMAGE_SHAPE_TYPE_B"
    "OX\020\003\022\034\n\030IMAGE_SHAPE_TYPE_ELLIPSE\020\004\022\034\n\030IM"
    "AGE_SHAPE_TYPE_POLYGON\020\005\022\035\n\031IMAGE_SHAPE_"
    "TYPE_POLYLINE\020\006\022 \n\034IMAGE_SHAPE_TYPE_POIN"
    "T_CLOUD\020\007\"u\n\013CameraPoint\022\035\n\025existence_pr"
    "obability\030\001 \001(\001\022 \n\005point\030\002 \001(\0132\021.osi3.Sp"
    "herical3d\022%\n\npoint_rmse\030\003 \001(\0132\021.osi3.Sph"
    "erical3d*\206\002\n\027DetectionClassification\022$\n "
    "DETECTION_CLASSIFICATION_UNKNOWN\020\000\022\"\n\036DE"
    "TECTION_CLASSIFICATION_OTHER\020\001\022$\n DETECT"
    "ION_CLASSIFICATION_INVALID\020\002\022$\n DETECTIO"
    "N_CLASSIFICATION_CLUTTER\020\003\022)\n%DETECTION_"
    "CLASSIFICATION_OVERDRIVABLE\020\004\022*\n&DETECTI"
    "ON_CLASSIFICATION_UNDERDRIVABLE\020\005B\002H\001"
};
static const ::_pbi::DescriptorTable* const descriptor_table_osi_5ffeaturedata_2eproto_deps[2] =
    {
        &::descriptor_table_osi_5fcommon_2eproto,
        &::descriptor_table_osi_5fversion_2eproto,
};
static ::absl::once_flag descriptor_table_osi_5ffeaturedata_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_osi_5ffeaturedata_2eproto = {
    false,
    false,
    5717,
    descriptor_table_protodef_osi_5ffeaturedata_2eproto,
    "osi_featuredata.proto",
    &descriptor_table_osi_5ffeaturedata_2eproto_once,
    descriptor_table_osi_5ffeaturedata_2eproto_deps,
    2,
    14,
    schemas,
    file_default_instances,
    TableStruct_osi_5ffeaturedata_2eproto::offsets,
    file_level_enum_descriptors_osi_5ffeaturedata_2eproto,
    file_level_service_descriptors_osi_5ffeaturedata_2eproto,
};
namespace osi3 {
const ::google::protobuf::EnumDescriptor* SensorDetectionHeader_DataQualifier_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_osi_5ffeaturedata_2eproto);
  return file_level_enum_descriptors_osi_5ffeaturedata_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t SensorDetectionHeader_DataQualifier_internal_data_[] = {
    524288u, 0u, };
bool SensorDetectionHeader_DataQualifier_IsValid(int value) {
  return 0 <= value && value <= 7;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_UNKNOWN;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_OTHER;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_AVAILABLE;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_AVAILABLE_REDUCED;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_NOT_AVAILABLE;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_BLINDNESS;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_TEMPORARY_AVAILABLE;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_INVALID;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DataQualifier_MIN;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader::DataQualifier_MAX;
constexpr int SensorDetectionHeader::DataQualifier_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* SensorDetectionHeader_ExtendedQualifier_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_osi_5ffeaturedata_2eproto);
  return file_level_enum_descriptors_osi_5ffeaturedata_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t SensorDetectionHeader_ExtendedQualifier_internal_data_[] = {
    851968u, 0u, };
bool SensorDetectionHeader_ExtendedQualifier_IsValid(int value) {
  return 0 <= value && value <= 12;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_UNKNOWN;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_OTHER;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_NORMAL_OPERATION_MODE;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_POWER_UP_OR_DOWN;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_SENSOR_NOT_CALIBRATED;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_SENSOR_BLOCKED;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_SENSOR_MISALIGNED;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_CONDITION;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_REDUCED_FIELD_OF_VIEW;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_INPUT_NOT_AVAILABLE;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_INTERNAL_REASON;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_EXTERNAL_DISTURBANCE;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::EXTENDED_QUALIFIER_BEGINNING_BLOCKAGE;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::ExtendedQualifier_MIN;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::ExtendedQualifier_MAX;
constexpr int SensorDetectionHeader::ExtendedQualifier_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* CameraDetection_Color_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_osi_5ffeaturedata_2eproto);
  return file_level_enum_descriptors_osi_5ffeaturedata_2eproto[2];
}
PROTOBUF_CONSTINIT const uint32_t CameraDetection_Color_internal_data_[] = {
    786432u, 0u, };
bool CameraDetection_Color_IsValid(int value) {
  return 0 <= value && value <= 11;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr CameraDetection_Color CameraDetection::COLOR_UNKNOWN;
constexpr CameraDetection_Color CameraDetection::COLOR_OTHER;
constexpr CameraDetection_Color CameraDetection::COLOR_BLACK;
constexpr CameraDetection_Color CameraDetection::COLOR_GREY;
constexpr CameraDetection_Color CameraDetection::COLOR_WHITE;
constexpr CameraDetection_Color CameraDetection::COLOR_YELLOW;
constexpr CameraDetection_Color CameraDetection::COLOR_ORANGE;
constexpr CameraDetection_Color CameraDetection::COLOR_RED;
constexpr CameraDetection_Color CameraDetection::COLOR_VIOLET;
constexpr CameraDetection_Color CameraDetection::COLOR_BLUE;
constexpr CameraDetection_Color CameraDetection::COLOR_GREEN;
constexpr CameraDetection_Color CameraDetection::COLOR_REFLECTIVE;
constexpr CameraDetection_Color CameraDetection::Color_MIN;
constexpr CameraDetection_Color CameraDetection::Color_MAX;
constexpr int CameraDetection::Color_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* CameraDetection_ImageShapeType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_osi_5ffeaturedata_2eproto);
  return file_level_enum_descriptors_osi_5ffeaturedata_2eproto[3];
}
PROTOBUF_CONSTINIT const uint32_t CameraDetection_ImageShapeType_internal_data_[] = {
    524288u, 0u, };
bool CameraDetection_ImageShapeType_IsValid(int value) {
  return 0 <= value && value <= 7;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_UNKNOWN;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_OTHER;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_POINT;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_BOX;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_ELLIPSE;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_POLYGON;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_POLYLINE;
constexpr CameraDetection_ImageShapeType CameraDetection::IMAGE_SHAPE_TYPE_POINT_CLOUD;
constexpr CameraDetection_ImageShapeType CameraDetection::ImageShapeType_MIN;
constexpr CameraDetection_ImageShapeType CameraDetection::ImageShapeType_MAX;
constexpr int CameraDetection::ImageShapeType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* DetectionClassification_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_osi_5ffeaturedata_2eproto);
  return file_level_enum_descriptors_osi_5ffeaturedata_2eproto[4];
}
PROTOBUF_CONSTINIT const uint32_t DetectionClassification_internal_data_[] = {
    393216u, 0u, };
bool DetectionClassification_IsValid(int value) {
  return 0 <= value && value <= 5;
}
// ===================================================================

class FeatureData::_Internal {
 public:
  using HasBits =
      decltype(std::declval<FeatureData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(FeatureData, _impl_._has_bits_);
};

void FeatureData::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.version_ != nullptr) _impl_.version_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
FeatureData::FeatureData(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.FeatureData)
}
inline PROTOBUF_NDEBUG_INLINE FeatureData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::FeatureData& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        radar_sensor_{visibility, arena, from.radar_sensor_},
        lidar_sensor_{visibility, arena, from.lidar_sensor_},
        ultrasonic_sensor_{visibility, arena, from.ultrasonic_sensor_},
        camera_sensor_{visibility, arena, from.camera_sensor_} {}

FeatureData::FeatureData(
    ::google::protobuf::Arena* arena,
    const FeatureData& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  FeatureData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.version_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::InterfaceVersion>(
                              arena, *from._impl_.version_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:osi3.FeatureData)
}
inline PROTOBUF_NDEBUG_INLINE FeatureData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        radar_sensor_{visibility, arena},
        lidar_sensor_{visibility, arena},
        ultrasonic_sensor_{visibility, arena},
        camera_sensor_{visibility, arena} {}

inline void FeatureData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.version_ = {};
}
FeatureData::~FeatureData() {
  // @@protoc_insertion_point(destructor:osi3.FeatureData)
  SharedDtor(*this);
}
inline void FeatureData::SharedDtor(MessageLite& self) {
  FeatureData& this_ = static_cast<FeatureData&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.version_;
  this_._impl_.~Impl_();
}

inline void* FeatureData::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) FeatureData(arena);
}
constexpr auto FeatureData::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(FeatureData, _impl_.radar_sensor_) +
          decltype(FeatureData::_impl_.radar_sensor_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(FeatureData, _impl_.lidar_sensor_) +
          decltype(FeatureData::_impl_.lidar_sensor_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(FeatureData, _impl_.ultrasonic_sensor_) +
          decltype(FeatureData::_impl_.ultrasonic_sensor_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(FeatureData, _impl_.camera_sensor_) +
          decltype(FeatureData::_impl_.camera_sensor_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(FeatureData), alignof(FeatureData), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&FeatureData::PlacementNew_,
                                 sizeof(FeatureData),
                                 alignof(FeatureData));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull FeatureData::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_FeatureData_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &FeatureData::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<FeatureData>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &FeatureData::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<FeatureData>(), &FeatureData::ByteSizeLong,
            &FeatureData::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(FeatureData, _impl_._cached_size_),
        false,
    },
    &FeatureData::kDescriptorMethods,
    &descriptor_table_osi_5ffeaturedata_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* FeatureData::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 5, 0, 2> FeatureData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(FeatureData, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    5,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::FeatureData>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .osi3.InterfaceVersion version = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(FeatureData, _impl_.version_)}},
    // repeated .osi3.RadarDetectionData radar_sensor = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 1, PROTOBUF_FIELD_OFFSET(FeatureData, _impl_.radar_sensor_)}},
    // repeated .osi3.LidarDetectionData lidar_sensor = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 2, PROTOBUF_FIELD_OFFSET(FeatureData, _impl_.lidar_sensor_)}},
    // repeated .osi3.UltrasonicDetectionData ultrasonic_sensor = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 3, PROTOBUF_FIELD_OFFSET(FeatureData, _impl_.ultrasonic_sensor_)}},
    // repeated .osi3.CameraDetectionData camera_sensor = 5;
    {::_pbi::TcParser::FastMtR1,
     {42, 63, 4, PROTOBUF_FIELD_OFFSET(FeatureData, _impl_.camera_sensor_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.InterfaceVersion version = 1;
    {PROTOBUF_FIELD_OFFSET(FeatureData, _impl_.version_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.RadarDetectionData radar_sensor = 2;
    {PROTOBUF_FIELD_OFFSET(FeatureData, _impl_.radar_sensor_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.LidarDetectionData lidar_sensor = 3;
    {PROTOBUF_FIELD_OFFSET(FeatureData, _impl_.lidar_sensor_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.UltrasonicDetectionData ultrasonic_sensor = 4;
    {PROTOBUF_FIELD_OFFSET(FeatureData, _impl_.ultrasonic_sensor_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.CameraDetectionData camera_sensor = 5;
    {PROTOBUF_FIELD_OFFSET(FeatureData, _impl_.camera_sensor_), -1, 4,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::InterfaceVersion>()},
    {::_pbi::TcParser::GetTable<::osi3::RadarDetectionData>()},
    {::_pbi::TcParser::GetTable<::osi3::LidarDetectionData>()},
    {::_pbi::TcParser::GetTable<::osi3::UltrasonicDetectionData>()},
    {::_pbi::TcParser::GetTable<::osi3::CameraDetectionData>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void FeatureData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.FeatureData)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.radar_sensor_.Clear();
  _impl_.lidar_sensor_.Clear();
  _impl_.ultrasonic_sensor_.Clear();
  _impl_.camera_sensor_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.version_ != nullptr);
    _impl_.version_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* FeatureData::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const FeatureData& this_ = static_cast<const FeatureData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* FeatureData::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const FeatureData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.FeatureData)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.InterfaceVersion version = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.version_, this_._impl_.version_->GetCachedSize(), target,
                stream);
          }

          // repeated .osi3.RadarDetectionData radar_sensor = 2;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_radar_sensor_size());
               i < n; i++) {
            const auto& repfield = this_._internal_radar_sensor().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    2, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .osi3.LidarDetectionData lidar_sensor = 3;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_lidar_sensor_size());
               i < n; i++) {
            const auto& repfield = this_._internal_lidar_sensor().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    3, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .osi3.UltrasonicDetectionData ultrasonic_sensor = 4;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_ultrasonic_sensor_size());
               i < n; i++) {
            const auto& repfield = this_._internal_ultrasonic_sensor().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    4, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .osi3.CameraDetectionData camera_sensor = 5;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_camera_sensor_size());
               i < n; i++) {
            const auto& repfield = this_._internal_camera_sensor().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    5, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.FeatureData)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t FeatureData::ByteSizeLong(const MessageLite& base) {
          const FeatureData& this_ = static_cast<const FeatureData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t FeatureData::ByteSizeLong() const {
          const FeatureData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.FeatureData)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .osi3.RadarDetectionData radar_sensor = 2;
            {
              total_size += 1UL * this_._internal_radar_sensor_size();
              for (const auto& msg : this_._internal_radar_sensor()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.LidarDetectionData lidar_sensor = 3;
            {
              total_size += 1UL * this_._internal_lidar_sensor_size();
              for (const auto& msg : this_._internal_lidar_sensor()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.UltrasonicDetectionData ultrasonic_sensor = 4;
            {
              total_size += 1UL * this_._internal_ultrasonic_sensor_size();
              for (const auto& msg : this_._internal_ultrasonic_sensor()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.CameraDetectionData camera_sensor = 5;
            {
              total_size += 1UL * this_._internal_camera_sensor_size();
              for (const auto& msg : this_._internal_camera_sensor()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
           {
            // optional .osi3.InterfaceVersion version = 1;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.version_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void FeatureData::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<FeatureData*>(&to_msg);
  auto& from = static_cast<const FeatureData&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.FeatureData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_radar_sensor()->MergeFrom(
      from._internal_radar_sensor());
  _this->_internal_mutable_lidar_sensor()->MergeFrom(
      from._internal_lidar_sensor());
  _this->_internal_mutable_ultrasonic_sensor()->MergeFrom(
      from._internal_ultrasonic_sensor());
  _this->_internal_mutable_camera_sensor()->MergeFrom(
      from._internal_camera_sensor());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.version_ != nullptr);
    if (_this->_impl_.version_ == nullptr) {
      _this->_impl_.version_ =
          ::google::protobuf::Message::CopyConstruct<::osi3::InterfaceVersion>(arena, *from._impl_.version_);
    } else {
      _this->_impl_.version_->MergeFrom(*from._impl_.version_);
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void FeatureData::CopyFrom(const FeatureData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.FeatureData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void FeatureData::InternalSwap(FeatureData* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.radar_sensor_.InternalSwap(&other->_impl_.radar_sensor_);
  _impl_.lidar_sensor_.InternalSwap(&other->_impl_.lidar_sensor_);
  _impl_.ultrasonic_sensor_.InternalSwap(&other->_impl_.ultrasonic_sensor_);
  _impl_.camera_sensor_.InternalSwap(&other->_impl_.camera_sensor_);
  swap(_impl_.version_, other->_impl_.version_);
}

::google::protobuf::Metadata FeatureData::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SensorDetectionHeader::_Internal {
 public:
  using HasBits =
      decltype(std::declval<SensorDetectionHeader>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_._has_bits_);
};

void SensorDetectionHeader::clear_measurement_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.measurement_time_ != nullptr) _impl_.measurement_time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void SensorDetectionHeader::clear_mounting_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mounting_position_ != nullptr) _impl_.mounting_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void SensorDetectionHeader::clear_mounting_position_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.mounting_position_rmse_ != nullptr) _impl_.mounting_position_rmse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void SensorDetectionHeader::clear_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sensor_id_ != nullptr) _impl_.sensor_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
SensorDetectionHeader::SensorDetectionHeader(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.SensorDetectionHeader)
}
inline PROTOBUF_NDEBUG_INLINE SensorDetectionHeader::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::SensorDetectionHeader& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

SensorDetectionHeader::SensorDetectionHeader(
    ::google::protobuf::Arena* arena,
    const SensorDetectionHeader& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SensorDetectionHeader* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.measurement_time_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Timestamp>(
                              arena, *from._impl_.measurement_time_)
                        : nullptr;
  _impl_.mounting_position_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::osi3::MountingPosition>(
                              arena, *from._impl_.mounting_position_)
                        : nullptr;
  _impl_.mounting_position_rmse_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::Message::CopyConstruct<::osi3::MountingPosition>(
                              arena, *from._impl_.mounting_position_rmse_)
                        : nullptr;
  _impl_.sensor_id_ = (cached_has_bits & 0x00000008u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.sensor_id_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, cycle_counter_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, cycle_counter_),
           offsetof(Impl_, extended_qualifier_) -
               offsetof(Impl_, cycle_counter_) +
               sizeof(Impl_::extended_qualifier_));

  // @@protoc_insertion_point(copy_constructor:osi3.SensorDetectionHeader)
}
inline PROTOBUF_NDEBUG_INLINE SensorDetectionHeader::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void SensorDetectionHeader::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, measurement_time_),
           0,
           offsetof(Impl_, extended_qualifier_) -
               offsetof(Impl_, measurement_time_) +
               sizeof(Impl_::extended_qualifier_));
}
SensorDetectionHeader::~SensorDetectionHeader() {
  // @@protoc_insertion_point(destructor:osi3.SensorDetectionHeader)
  SharedDtor(*this);
}
inline void SensorDetectionHeader::SharedDtor(MessageLite& self) {
  SensorDetectionHeader& this_ = static_cast<SensorDetectionHeader&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.measurement_time_;
  delete this_._impl_.mounting_position_;
  delete this_._impl_.mounting_position_rmse_;
  delete this_._impl_.sensor_id_;
  this_._impl_.~Impl_();
}

inline void* SensorDetectionHeader::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) SensorDetectionHeader(arena);
}
constexpr auto SensorDetectionHeader::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(SensorDetectionHeader),
                                            alignof(SensorDetectionHeader));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull SensorDetectionHeader::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_SensorDetectionHeader_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &SensorDetectionHeader::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<SensorDetectionHeader>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &SensorDetectionHeader::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<SensorDetectionHeader>(), &SensorDetectionHeader::ByteSizeLong,
            &SensorDetectionHeader::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_._cached_size_),
        false,
    },
    &SensorDetectionHeader::kDescriptorMethods,
    &descriptor_table_osi_5ffeaturedata_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* SensorDetectionHeader::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 6, 0, 2> SensorDetectionHeader::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    6,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::SensorDetectionHeader>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional .osi3.SensorDetectionHeader.ExtendedQualifier extended_qualifier = 8;
    {::_pbi::TcParser::FastEr0S1,
     {64, 7, 12, PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.extended_qualifier_)}},
    // optional .osi3.Timestamp measurement_time = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.measurement_time_)}},
    // optional uint64 cycle_counter = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(SensorDetectionHeader, _impl_.cycle_counter_), 4>(),
     {16, 4, 0, PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.cycle_counter_)}},
    // optional .osi3.MountingPosition mounting_position = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1, PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.mounting_position_)}},
    // optional .osi3.MountingPosition mounting_position_rmse = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 2, 2, PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.mounting_position_rmse_)}},
    // optional .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
    {::_pbi::TcParser::FastEr0S1,
     {40, 5, 7, PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.data_qualifier_)}},
    // optional uint32 number_of_valid_detections = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(SensorDetectionHeader, _impl_.number_of_valid_detections_), 6>(),
     {48, 6, 0, PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.number_of_valid_detections_)}},
    // optional .osi3.Identifier sensor_id = 7;
    {::_pbi::TcParser::FastMtS1,
     {58, 3, 3, PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.sensor_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.Timestamp measurement_time = 1;
    {PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.measurement_time_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint64 cycle_counter = 2;
    {PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.cycle_counter_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .osi3.MountingPosition mounting_position = 3;
    {PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.mounting_position_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.MountingPosition mounting_position_rmse = 4;
    {PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.mounting_position_rmse_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
    {PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.data_qualifier_), _Internal::kHasBitsOffset + 5, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional uint32 number_of_valid_detections = 6;
    {PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.number_of_valid_detections_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional .osi3.Identifier sensor_id = 7;
    {PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.sensor_id_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.SensorDetectionHeader.ExtendedQualifier extended_qualifier = 8;
    {PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.extended_qualifier_), _Internal::kHasBitsOffset + 7, 5,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Timestamp>()},
    {::_pbi::TcParser::GetTable<::osi3::MountingPosition>()},
    {::_pbi::TcParser::GetTable<::osi3::MountingPosition>()},
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {0, 8},
    {0, 13},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void SensorDetectionHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.SensorDetectionHeader)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.measurement_time_ != nullptr);
      _impl_.measurement_time_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.mounting_position_ != nullptr);
      _impl_.mounting_position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.mounting_position_rmse_ != nullptr);
      _impl_.mounting_position_rmse_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.sensor_id_ != nullptr);
      _impl_.sensor_id_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.cycle_counter_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.extended_qualifier_) -
        reinterpret_cast<char*>(&_impl_.cycle_counter_)) + sizeof(_impl_.extended_qualifier_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* SensorDetectionHeader::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const SensorDetectionHeader& this_ = static_cast<const SensorDetectionHeader&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* SensorDetectionHeader::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const SensorDetectionHeader& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.SensorDetectionHeader)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.Timestamp measurement_time = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.measurement_time_, this_._impl_.measurement_time_->GetCachedSize(), target,
                stream);
          }

          // optional uint64 cycle_counter = 2;
          if (cached_has_bits & 0x00000010u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
                2, this_._internal_cycle_counter(), target);
          }

          // optional .osi3.MountingPosition mounting_position = 3;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.mounting_position_, this_._impl_.mounting_position_->GetCachedSize(), target,
                stream);
          }

          // optional .osi3.MountingPosition mounting_position_rmse = 4;
          if (cached_has_bits & 0x00000004u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                4, *this_._impl_.mounting_position_rmse_, this_._impl_.mounting_position_rmse_->GetCachedSize(), target,
                stream);
          }

          // optional .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
          if (cached_has_bits & 0x00000020u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                5, this_._internal_data_qualifier(), target);
          }

          // optional uint32 number_of_valid_detections = 6;
          if (cached_has_bits & 0x00000040u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                6, this_._internal_number_of_valid_detections(), target);
          }

          // optional .osi3.Identifier sensor_id = 7;
          if (cached_has_bits & 0x00000008u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                7, *this_._impl_.sensor_id_, this_._impl_.sensor_id_->GetCachedSize(), target,
                stream);
          }

          // optional .osi3.SensorDetectionHeader.ExtendedQualifier extended_qualifier = 8;
          if (cached_has_bits & 0x00000080u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                8, this_._internal_extended_qualifier(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.SensorDetectionHeader)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t SensorDetectionHeader::ByteSizeLong(const MessageLite& base) {
          const SensorDetectionHeader& this_ = static_cast<const SensorDetectionHeader&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t SensorDetectionHeader::ByteSizeLong() const {
          const SensorDetectionHeader& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.SensorDetectionHeader)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x000000ffu) {
            // optional .osi3.Timestamp measurement_time = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.measurement_time_);
            }
            // optional .osi3.MountingPosition mounting_position = 3;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.mounting_position_);
            }
            // optional .osi3.MountingPosition mounting_position_rmse = 4;
            if (cached_has_bits & 0x00000004u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.mounting_position_rmse_);
            }
            // optional .osi3.Identifier sensor_id = 7;
            if (cached_has_bits & 0x00000008u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.sensor_id_);
            }
            // optional uint64 cycle_counter = 2;
            if (cached_has_bits & 0x00000010u) {
              total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
                  this_._internal_cycle_counter());
            }
            // optional .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
            if (cached_has_bits & 0x00000020u) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_data_qualifier());
            }
            // optional uint32 number_of_valid_detections = 6;
            if (cached_has_bits & 0x00000040u) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_number_of_valid_detections());
            }
            // optional .osi3.SensorDetectionHeader.ExtendedQualifier extended_qualifier = 8;
            if (cached_has_bits & 0x00000080u) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_extended_qualifier());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void SensorDetectionHeader::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SensorDetectionHeader*>(&to_msg);
  auto& from = static_cast<const SensorDetectionHeader&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.SensorDetectionHeader)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.measurement_time_ != nullptr);
      if (_this->_impl_.measurement_time_ == nullptr) {
        _this->_impl_.measurement_time_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Timestamp>(arena, *from._impl_.measurement_time_);
      } else {
        _this->_impl_.measurement_time_->MergeFrom(*from._impl_.measurement_time_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.mounting_position_ != nullptr);
      if (_this->_impl_.mounting_position_ == nullptr) {
        _this->_impl_.mounting_position_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::MountingPosition>(arena, *from._impl_.mounting_position_);
      } else {
        _this->_impl_.mounting_position_->MergeFrom(*from._impl_.mounting_position_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.mounting_position_rmse_ != nullptr);
      if (_this->_impl_.mounting_position_rmse_ == nullptr) {
        _this->_impl_.mounting_position_rmse_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::MountingPosition>(arena, *from._impl_.mounting_position_rmse_);
      } else {
        _this->_impl_.mounting_position_rmse_->MergeFrom(*from._impl_.mounting_position_rmse_);
      }
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(from._impl_.sensor_id_ != nullptr);
      if (_this->_impl_.sensor_id_ == nullptr) {
        _this->_impl_.sensor_id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.sensor_id_);
      } else {
        _this->_impl_.sensor_id_->MergeFrom(*from._impl_.sensor_id_);
      }
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.cycle_counter_ = from._impl_.cycle_counter_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.data_qualifier_ = from._impl_.data_qualifier_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.number_of_valid_detections_ = from._impl_.number_of_valid_detections_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.extended_qualifier_ = from._impl_.extended_qualifier_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SensorDetectionHeader::CopyFrom(const SensorDetectionHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.SensorDetectionHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SensorDetectionHeader::InternalSwap(SensorDetectionHeader* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.extended_qualifier_)
      + sizeof(SensorDetectionHeader::_impl_.extended_qualifier_)
      - PROTOBUF_FIELD_OFFSET(SensorDetectionHeader, _impl_.measurement_time_)>(
          reinterpret_cast<char*>(&_impl_.measurement_time_),
          reinterpret_cast<char*>(&other->_impl_.measurement_time_));
}

::google::protobuf::Metadata SensorDetectionHeader::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RadarDetectionData::_Internal {
 public:
  using HasBits =
      decltype(std::declval<RadarDetectionData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RadarDetectionData, _impl_._has_bits_);
};

RadarDetectionData::RadarDetectionData(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.RadarDetectionData)
}
inline PROTOBUF_NDEBUG_INLINE RadarDetectionData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::RadarDetectionData& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        detection_{visibility, arena, from.detection_} {}

RadarDetectionData::RadarDetectionData(
    ::google::protobuf::Arena* arena,
    const RadarDetectionData& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RadarDetectionData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.header_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::SensorDetectionHeader>(
                              arena, *from._impl_.header_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:osi3.RadarDetectionData)
}
inline PROTOBUF_NDEBUG_INLINE RadarDetectionData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        detection_{visibility, arena} {}

inline void RadarDetectionData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.header_ = {};
}
RadarDetectionData::~RadarDetectionData() {
  // @@protoc_insertion_point(destructor:osi3.RadarDetectionData)
  SharedDtor(*this);
}
inline void RadarDetectionData::SharedDtor(MessageLite& self) {
  RadarDetectionData& this_ = static_cast<RadarDetectionData&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.header_;
  this_._impl_.~Impl_();
}

inline void* RadarDetectionData::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) RadarDetectionData(arena);
}
constexpr auto RadarDetectionData::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(RadarDetectionData, _impl_.detection_) +
          decltype(RadarDetectionData::_impl_.detection_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(RadarDetectionData), alignof(RadarDetectionData), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&RadarDetectionData::PlacementNew_,
                                 sizeof(RadarDetectionData),
                                 alignof(RadarDetectionData));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull RadarDetectionData::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_RadarDetectionData_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &RadarDetectionData::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<RadarDetectionData>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &RadarDetectionData::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<RadarDetectionData>(), &RadarDetectionData::ByteSizeLong,
            &RadarDetectionData::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(RadarDetectionData, _impl_._cached_size_),
        false,
    },
    &RadarDetectionData::kDescriptorMethods,
    &descriptor_table_osi_5ffeaturedata_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* RadarDetectionData::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2> RadarDetectionData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RadarDetectionData, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::RadarDetectionData>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .osi3.RadarDetection detection = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 1, PROTOBUF_FIELD_OFFSET(RadarDetectionData, _impl_.detection_)}},
    // optional .osi3.SensorDetectionHeader header = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RadarDetectionData, _impl_.header_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.SensorDetectionHeader header = 1;
    {PROTOBUF_FIELD_OFFSET(RadarDetectionData, _impl_.header_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.RadarDetection detection = 2;
    {PROTOBUF_FIELD_OFFSET(RadarDetectionData, _impl_.detection_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::SensorDetectionHeader>()},
    {::_pbi::TcParser::GetTable<::osi3::RadarDetection>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void RadarDetectionData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.RadarDetectionData)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.detection_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* RadarDetectionData::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const RadarDetectionData& this_ = static_cast<const RadarDetectionData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* RadarDetectionData::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const RadarDetectionData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.RadarDetectionData)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.SensorDetectionHeader header = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.header_, this_._impl_.header_->GetCachedSize(), target,
                stream);
          }

          // repeated .osi3.RadarDetection detection = 2;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_detection_size());
               i < n; i++) {
            const auto& repfield = this_._internal_detection().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    2, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.RadarDetectionData)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t RadarDetectionData::ByteSizeLong(const MessageLite& base) {
          const RadarDetectionData& this_ = static_cast<const RadarDetectionData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t RadarDetectionData::ByteSizeLong() const {
          const RadarDetectionData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.RadarDetectionData)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .osi3.RadarDetection detection = 2;
            {
              total_size += 1UL * this_._internal_detection_size();
              for (const auto& msg : this_._internal_detection()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
           {
            // optional .osi3.SensorDetectionHeader header = 1;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.header_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void RadarDetectionData::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RadarDetectionData*>(&to_msg);
  auto& from = static_cast<const RadarDetectionData&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.RadarDetectionData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_detection()->MergeFrom(
      from._internal_detection());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.header_ != nullptr);
    if (_this->_impl_.header_ == nullptr) {
      _this->_impl_.header_ =
          ::google::protobuf::Message::CopyConstruct<::osi3::SensorDetectionHeader>(arena, *from._impl_.header_);
    } else {
      _this->_impl_.header_->MergeFrom(*from._impl_.header_);
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RadarDetectionData::CopyFrom(const RadarDetectionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.RadarDetectionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RadarDetectionData::InternalSwap(RadarDetectionData* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.detection_.InternalSwap(&other->_impl_.detection_);
  swap(_impl_.header_, other->_impl_.header_);
}

::google::protobuf::Metadata RadarDetectionData::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RadarDetection::_Internal {
 public:
  using HasBits =
      decltype(std::declval<RadarDetection>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_._has_bits_);
};

void RadarDetection::clear_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.object_id_ != nullptr) _impl_.object_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RadarDetection::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RadarDetection::clear_position_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_rmse_ != nullptr) _impl_.position_rmse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void RadarDetection::clear_ambiguity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ambiguity_id_ != nullptr) _impl_.ambiguity_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
RadarDetection::RadarDetection(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.RadarDetection)
}
inline PROTOBUF_NDEBUG_INLINE RadarDetection::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::RadarDetection& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

RadarDetection::RadarDetection(
    ::google::protobuf::Arena* arena,
    const RadarDetection& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RadarDetection* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.object_id_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.object_id_)
                        : nullptr;
  _impl_.position_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Spherical3d>(
                              arena, *from._impl_.position_)
                        : nullptr;
  _impl_.position_rmse_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Spherical3d>(
                              arena, *from._impl_.position_rmse_)
                        : nullptr;
  _impl_.ambiguity_id_ = (cached_has_bits & 0x00000008u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.ambiguity_id_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, existence_probability_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, existence_probability_),
           offsetof(Impl_, classification_) -
               offsetof(Impl_, existence_probability_) +
               sizeof(Impl_::classification_));

  // @@protoc_insertion_point(copy_constructor:osi3.RadarDetection)
}
inline PROTOBUF_NDEBUG_INLINE RadarDetection::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void RadarDetection::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, object_id_),
           0,
           offsetof(Impl_, classification_) -
               offsetof(Impl_, object_id_) +
               sizeof(Impl_::classification_));
}
RadarDetection::~RadarDetection() {
  // @@protoc_insertion_point(destructor:osi3.RadarDetection)
  SharedDtor(*this);
}
inline void RadarDetection::SharedDtor(MessageLite& self) {
  RadarDetection& this_ = static_cast<RadarDetection&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.object_id_;
  delete this_._impl_.position_;
  delete this_._impl_.position_rmse_;
  delete this_._impl_.ambiguity_id_;
  this_._impl_.~Impl_();
}

inline void* RadarDetection::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) RadarDetection(arena);
}
constexpr auto RadarDetection::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(RadarDetection),
                                            alignof(RadarDetection));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull RadarDetection::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_RadarDetection_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &RadarDetection::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<RadarDetection>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &RadarDetection::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<RadarDetection>(), &RadarDetection::ByteSizeLong,
            &RadarDetection::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_._cached_size_),
        false,
    },
    &RadarDetection::kDescriptorMethods,
    &descriptor_table_osi_5ffeaturedata_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* RadarDetection::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 11, 5, 0, 2> RadarDetection::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_._has_bits_),
    0, // no _extensions_
    11, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294965248,  // skipmap
    offsetof(decltype(_table_), field_entries),
    11,  // num_field_entries
    5,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::RadarDetection>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional double existence_probability = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 4, 0, PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.existence_probability_)}},
    // optional .osi3.Identifier object_id = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.object_id_)}},
    // optional .osi3.Spherical3d position = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1, PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.position_)}},
    // optional .osi3.Spherical3d position_rmse = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 2, 2, PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.position_rmse_)}},
    // optional double radial_velocity = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 5, 0, PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.radial_velocity_)}},
    // optional double radial_velocity_rmse = 6;
    {::_pbi::TcParser::FastF64S1,
     {49, 6, 0, PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.radial_velocity_rmse_)}},
    // optional double rcs = 7;
    {::_pbi::TcParser::FastF64S1,
     {57, 7, 0, PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.rcs_)}},
    // optional double snr = 8;
    {::_pbi::TcParser::FastF64S1,
     {65, 8, 0, PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.snr_)}},
    // optional double point_target_probability = 9;
    {::_pbi::TcParser::FastF64S1,
     {73, 9, 0, PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.point_target_probability_)}},
    // optional .osi3.Identifier ambiguity_id = 10;
    {::_pbi::TcParser::FastMtS1,
     {82, 3, 3, PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.ambiguity_id_)}},
    // optional .osi3.DetectionClassification classification = 11;
    {::_pbi::TcParser::FastEr0S1,
     {88, 10, 5, PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.classification_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional double existence_probability = 1;
    {PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.existence_probability_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .osi3.Identifier object_id = 2;
    {PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.object_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.Spherical3d position = 3;
    {PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.position_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.Spherical3d position_rmse = 4;
    {PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.position_rmse_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional double radial_velocity = 5;
    {PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.radial_velocity_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double radial_velocity_rmse = 6;
    {PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.radial_velocity_rmse_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double rcs = 7;
    {PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.rcs_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double snr = 8;
    {PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.snr_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double point_target_probability = 9;
    {PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.point_target_probability_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .osi3.Identifier ambiguity_id = 10;
    {PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.ambiguity_id_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.DetectionClassification classification = 11;
    {PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.classification_), _Internal::kHasBitsOffset + 10, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::Spherical3d>()},
    {::_pbi::TcParser::GetTable<::osi3::Spherical3d>()},
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {0, 6},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void RadarDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.RadarDetection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.object_id_ != nullptr);
      _impl_.object_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.position_rmse_ != nullptr);
      _impl_.position_rmse_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.ambiguity_id_ != nullptr);
      _impl_.ambiguity_id_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.existence_probability_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.rcs_) -
        reinterpret_cast<char*>(&_impl_.existence_probability_)) + sizeof(_impl_.rcs_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.snr_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.classification_) -
        reinterpret_cast<char*>(&_impl_.snr_)) + sizeof(_impl_.classification_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* RadarDetection::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const RadarDetection& this_ = static_cast<const RadarDetection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* RadarDetection::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const RadarDetection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.RadarDetection)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional double existence_probability = 1;
          if (cached_has_bits & 0x00000010u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                1, this_._internal_existence_probability(), target);
          }

          // optional .osi3.Identifier object_id = 2;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.object_id_, this_._impl_.object_id_->GetCachedSize(), target,
                stream);
          }

          // optional .osi3.Spherical3d position = 3;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.position_, this_._impl_.position_->GetCachedSize(), target,
                stream);
          }

          // optional .osi3.Spherical3d position_rmse = 4;
          if (cached_has_bits & 0x00000004u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                4, *this_._impl_.position_rmse_, this_._impl_.position_rmse_->GetCachedSize(), target,
                stream);
          }

          // optional double radial_velocity = 5;
          if (cached_has_bits & 0x00000020u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                5, this_._internal_radial_velocity(), target);
          }

          // optional double radial_velocity_rmse = 6;
          if (cached_has_bits & 0x00000040u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                6, this_._internal_radial_velocity_rmse(), target);
          }

          // optional double rcs = 7;
          if (cached_has_bits & 0x00000080u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                7, this_._internal_rcs(), target);
          }

          // optional double snr = 8;
          if (cached_has_bits & 0x00000100u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                8, this_._internal_snr(), target);
          }

          // optional double point_target_probability = 9;
          if (cached_has_bits & 0x00000200u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                9, this_._internal_point_target_probability(), target);
          }

          // optional .osi3.Identifier ambiguity_id = 10;
          if (cached_has_bits & 0x00000008u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                10, *this_._impl_.ambiguity_id_, this_._impl_.ambiguity_id_->GetCachedSize(), target,
                stream);
          }

          // optional .osi3.DetectionClassification classification = 11;
          if (cached_has_bits & 0x00000400u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                11, this_._internal_classification(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.RadarDetection)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t RadarDetection::ByteSizeLong(const MessageLite& base) {
          const RadarDetection& this_ = static_cast<const RadarDetection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t RadarDetection::ByteSizeLong() const {
          const RadarDetection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.RadarDetection)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x000000ffu) {
            // optional .osi3.Identifier object_id = 2;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.object_id_);
            }
            // optional .osi3.Spherical3d position = 3;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.position_);
            }
            // optional .osi3.Spherical3d position_rmse = 4;
            if (cached_has_bits & 0x00000004u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.position_rmse_);
            }
            // optional .osi3.Identifier ambiguity_id = 10;
            if (cached_has_bits & 0x00000008u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.ambiguity_id_);
            }
            // optional double existence_probability = 1;
            if (cached_has_bits & 0x00000010u) {
              total_size += 9;
            }
            // optional double radial_velocity = 5;
            if (cached_has_bits & 0x00000020u) {
              total_size += 9;
            }
            // optional double radial_velocity_rmse = 6;
            if (cached_has_bits & 0x00000040u) {
              total_size += 9;
            }
            // optional double rcs = 7;
            if (cached_has_bits & 0x00000080u) {
              total_size += 9;
            }
          }
          if (cached_has_bits & 0x00000700u) {
            // optional double snr = 8;
            if (cached_has_bits & 0x00000100u) {
              total_size += 9;
            }
            // optional double point_target_probability = 9;
            if (cached_has_bits & 0x00000200u) {
              total_size += 9;
            }
            // optional .osi3.DetectionClassification classification = 11;
            if (cached_has_bits & 0x00000400u) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_classification());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void RadarDetection::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RadarDetection*>(&to_msg);
  auto& from = static_cast<const RadarDetection&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.RadarDetection)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.object_id_ != nullptr);
      if (_this->_impl_.object_id_ == nullptr) {
        _this->_impl_.object_id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.object_id_);
      } else {
        _this->_impl_.object_id_->MergeFrom(*from._impl_.object_id_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.position_ != nullptr);
      if (_this->_impl_.position_ == nullptr) {
        _this->_impl_.position_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Spherical3d>(arena, *from._impl_.position_);
      } else {
        _this->_impl_.position_->MergeFrom(*from._impl_.position_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.position_rmse_ != nullptr);
      if (_this->_impl_.position_rmse_ == nullptr) {
        _this->_impl_.position_rmse_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Spherical3d>(arena, *from._impl_.position_rmse_);
      } else {
        _this->_impl_.position_rmse_->MergeFrom(*from._impl_.position_rmse_);
      }
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(from._impl_.ambiguity_id_ != nullptr);
      if (_this->_impl_.ambiguity_id_ == nullptr) {
        _this->_impl_.ambiguity_id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.ambiguity_id_);
      } else {
        _this->_impl_.ambiguity_id_->MergeFrom(*from._impl_.ambiguity_id_);
      }
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.existence_probability_ = from._impl_.existence_probability_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.radial_velocity_ = from._impl_.radial_velocity_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.radial_velocity_rmse_ = from._impl_.radial_velocity_rmse_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.rcs_ = from._impl_.rcs_;
    }
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.snr_ = from._impl_.snr_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.point_target_probability_ = from._impl_.point_target_probability_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.classification_ = from._impl_.classification_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RadarDetection::CopyFrom(const RadarDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.RadarDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RadarDetection::InternalSwap(RadarDetection* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.classification_)
      + sizeof(RadarDetection::_impl_.classification_)
      - PROTOBUF_FIELD_OFFSET(RadarDetection, _impl_.object_id_)>(
          reinterpret_cast<char*>(&_impl_.object_id_),
          reinterpret_cast<char*>(&other->_impl_.object_id_));
}

::google::protobuf::Metadata RadarDetection::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LidarDetectionData::_Internal {
 public:
  using HasBits =
      decltype(std::declval<LidarDetectionData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LidarDetectionData, _impl_._has_bits_);
};

LidarDetectionData::LidarDetectionData(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.LidarDetectionData)
}
inline PROTOBUF_NDEBUG_INLINE LidarDetectionData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::LidarDetectionData& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        detection_{visibility, arena, from.detection_} {}

LidarDetectionData::LidarDetectionData(
    ::google::protobuf::Arena* arena,
    const LidarDetectionData& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LidarDetectionData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.header_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::SensorDetectionHeader>(
                              arena, *from._impl_.header_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:osi3.LidarDetectionData)
}
inline PROTOBUF_NDEBUG_INLINE LidarDetectionData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        detection_{visibility, arena} {}

inline void LidarDetectionData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.header_ = {};
}
LidarDetectionData::~LidarDetectionData() {
  // @@protoc_insertion_point(destructor:osi3.LidarDetectionData)
  SharedDtor(*this);
}
inline void LidarDetectionData::SharedDtor(MessageLite& self) {
  LidarDetectionData& this_ = static_cast<LidarDetectionData&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.header_;
  this_._impl_.~Impl_();
}

inline void* LidarDetectionData::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) LidarDetectionData(arena);
}
constexpr auto LidarDetectionData::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(LidarDetectionData, _impl_.detection_) +
          decltype(LidarDetectionData::_impl_.detection_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(LidarDetectionData), alignof(LidarDetectionData), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&LidarDetectionData::PlacementNew_,
                                 sizeof(LidarDetectionData),
                                 alignof(LidarDetectionData));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull LidarDetectionData::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_LidarDetectionData_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &LidarDetectionData::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<LidarDetectionData>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &LidarDetectionData::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<LidarDetectionData>(), &LidarDetectionData::ByteSizeLong,
            &LidarDetectionData::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(LidarDetectionData, _impl_._cached_size_),
        false,
    },
    &LidarDetectionData::kDescriptorMethods,
    &descriptor_table_osi_5ffeaturedata_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* LidarDetectionData::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2> LidarDetectionData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LidarDetectionData, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::LidarDetectionData>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .osi3.LidarDetection detection = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 1, PROTOBUF_FIELD_OFFSET(LidarDetectionData, _impl_.detection_)}},
    // optional .osi3.SensorDetectionHeader header = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(LidarDetectionData, _impl_.header_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.SensorDetectionHeader header = 1;
    {PROTOBUF_FIELD_OFFSET(LidarDetectionData, _impl_.header_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.LidarDetection detection = 2;
    {PROTOBUF_FIELD_OFFSET(LidarDetectionData, _impl_.detection_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::SensorDetectionHeader>()},
    {::_pbi::TcParser::GetTable<::osi3::LidarDetection>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void LidarDetectionData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LidarDetectionData)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.detection_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* LidarDetectionData::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const LidarDetectionData& this_ = static_cast<const LidarDetectionData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* LidarDetectionData::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const LidarDetectionData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.LidarDetectionData)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.SensorDetectionHeader header = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.header_, this_._impl_.header_->GetCachedSize(), target,
                stream);
          }

          // repeated .osi3.LidarDetection detection = 2;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_detection_size());
               i < n; i++) {
            const auto& repfield = this_._internal_detection().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    2, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.LidarDetectionData)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t LidarDetectionData::ByteSizeLong(const MessageLite& base) {
          const LidarDetectionData& this_ = static_cast<const LidarDetectionData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t LidarDetectionData::ByteSizeLong() const {
          const LidarDetectionData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.LidarDetectionData)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .osi3.LidarDetection detection = 2;
            {
              total_size += 1UL * this_._internal_detection_size();
              for (const auto& msg : this_._internal_detection()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
           {
            // optional .osi3.SensorDetectionHeader header = 1;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.header_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void LidarDetectionData::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LidarDetectionData*>(&to_msg);
  auto& from = static_cast<const LidarDetectionData&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.LidarDetectionData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_detection()->MergeFrom(
      from._internal_detection());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.header_ != nullptr);
    if (_this->_impl_.header_ == nullptr) {
      _this->_impl_.header_ =
          ::google::protobuf::Message::CopyConstruct<::osi3::SensorDetectionHeader>(arena, *from._impl_.header_);
    } else {
      _this->_impl_.header_->MergeFrom(*from._impl_.header_);
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LidarDetectionData::CopyFrom(const LidarDetectionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LidarDetectionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LidarDetectionData::InternalSwap(LidarDetectionData* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.detection_.InternalSwap(&other->_impl_.detection_);
  swap(_impl_.header_, other->_impl_.header_);
}

::google::protobuf::Metadata LidarDetectionData::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LidarDetection::_Internal {
 public:
  using HasBits =
      decltype(std::declval<LidarDetection>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_._has_bits_);
};

void LidarDetection::clear_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.object_id_ != nullptr) _impl_.object_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void LidarDetection::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void LidarDetection::clear_position_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_rmse_ != nullptr) _impl_.position_rmse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
LidarDetection::LidarDetection(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.LidarDetection)
}
inline PROTOBUF_NDEBUG_INLINE LidarDetection::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::LidarDetection& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

LidarDetection::LidarDetection(
    ::google::protobuf::Arena* arena,
    const LidarDetection& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LidarDetection* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.object_id_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.object_id_)
                        : nullptr;
  _impl_.position_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Spherical3d>(
                              arena, *from._impl_.position_)
                        : nullptr;
  _impl_.position_rmse_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Spherical3d>(
                              arena, *from._impl_.position_rmse_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, existence_probability_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, existence_probability_),
           offsetof(Impl_, classification_) -
               offsetof(Impl_, existence_probability_) +
               sizeof(Impl_::classification_));

  // @@protoc_insertion_point(copy_constructor:osi3.LidarDetection)
}
inline PROTOBUF_NDEBUG_INLINE LidarDetection::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void LidarDetection::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, object_id_),
           0,
           offsetof(Impl_, classification_) -
               offsetof(Impl_, object_id_) +
               sizeof(Impl_::classification_));
}
LidarDetection::~LidarDetection() {
  // @@protoc_insertion_point(destructor:osi3.LidarDetection)
  SharedDtor(*this);
}
inline void LidarDetection::SharedDtor(MessageLite& self) {
  LidarDetection& this_ = static_cast<LidarDetection&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.object_id_;
  delete this_._impl_.position_;
  delete this_._impl_.position_rmse_;
  this_._impl_.~Impl_();
}

inline void* LidarDetection::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) LidarDetection(arena);
}
constexpr auto LidarDetection::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(LidarDetection),
                                            alignof(LidarDetection));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull LidarDetection::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_LidarDetection_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &LidarDetection::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<LidarDetection>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &LidarDetection::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<LidarDetection>(), &LidarDetection::ByteSizeLong,
            &LidarDetection::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_._cached_size_),
        false,
    },
    &LidarDetection::kDescriptorMethods,
    &descriptor_table_osi_5ffeaturedata_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* LidarDetection::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 11, 4, 0, 2> LidarDetection::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_._has_bits_),
    0, // no _extensions_
    11, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294965248,  // skipmap
    offsetof(decltype(_table_), field_entries),
    11,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::LidarDetection>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional double existence_probability = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 3, 0, PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.existence_probability_)}},
    // optional .osi3.Identifier object_id = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.object_id_)}},
    // optional .osi3.Spherical3d position = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1, PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.position_)}},
    // optional .osi3.Spherical3d position_rmse = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 2, 2, PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.position_rmse_)}},
    // optional double height = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 4, 0, PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.height_)}},
    // optional double height_rmse = 6;
    {::_pbi::TcParser::FastF64S1,
     {49, 5, 0, PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.height_rmse_)}},
    // optional double intensity = 7;
    {::_pbi::TcParser::FastF64S1,
     {57, 6, 0, PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.intensity_)}},
    // optional double free_space_probability = 8;
    {::_pbi::TcParser::FastF64S1,
     {65, 7, 0, PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.free_space_probability_)}},
    // optional .osi3.DetectionClassification classification = 9;
    {::_pbi::TcParser::FastEr0S1,
     {72, 10, 5, PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.classification_)}},
    // optional double reflectivity = 10;
    {::_pbi::TcParser::FastF64S1,
     {81, 8, 0, PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.reflectivity_)}},
    // optional double echo_pulse_width = 11;
    {::_pbi::TcParser::FastF64S1,
     {89, 9, 0, PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.echo_pulse_width_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional double existence_probability = 1;
    {PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.existence_probability_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .osi3.Identifier object_id = 2;
    {PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.object_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.Spherical3d position = 3;
    {PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.position_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.Spherical3d position_rmse = 4;
    {PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.position_rmse_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional double height = 5;
    {PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.height_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double height_rmse = 6;
    {PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.height_rmse_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double intensity = 7;
    {PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.intensity_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double free_space_probability = 8;
    {PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.free_space_probability_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .osi3.DetectionClassification classification = 9;
    {PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.classification_), _Internal::kHasBitsOffset + 10, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional double reflectivity = 10;
    {PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.reflectivity_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double echo_pulse_width = 11;
    {PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.echo_pulse_width_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::Spherical3d>()},
    {::_pbi::TcParser::GetTable<::osi3::Spherical3d>()},
    {0, 6},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void LidarDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LidarDetection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.object_id_ != nullptr);
      _impl_.object_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.position_rmse_ != nullptr);
      _impl_.position_rmse_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.existence_probability_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.free_space_probability_) -
        reinterpret_cast<char*>(&_impl_.existence_probability_)) + sizeof(_impl_.free_space_probability_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.reflectivity_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.classification_) -
        reinterpret_cast<char*>(&_impl_.reflectivity_)) + sizeof(_impl_.classification_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* LidarDetection::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const LidarDetection& this_ = static_cast<const LidarDetection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* LidarDetection::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const LidarDetection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.LidarDetection)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional double existence_probability = 1;
          if (cached_has_bits & 0x00000008u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                1, this_._internal_existence_probability(), target);
          }

          // optional .osi3.Identifier object_id = 2;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.object_id_, this_._impl_.object_id_->GetCachedSize(), target,
                stream);
          }

          // optional .osi3.Spherical3d position = 3;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.position_, this_._impl_.position_->GetCachedSize(), target,
                stream);
          }

          // optional .osi3.Spherical3d position_rmse = 4;
          if (cached_has_bits & 0x00000004u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                4, *this_._impl_.position_rmse_, this_._impl_.position_rmse_->GetCachedSize(), target,
                stream);
          }

          // optional double height = 5;
          if (cached_has_bits & 0x00000010u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                5, this_._internal_height(), target);
          }

          // optional double height_rmse = 6;
          if (cached_has_bits & 0x00000020u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                6, this_._internal_height_rmse(), target);
          }

          // optional double intensity = 7;
          if (cached_has_bits & 0x00000040u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                7, this_._internal_intensity(), target);
          }

          // optional double free_space_probability = 8;
          if (cached_has_bits & 0x00000080u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                8, this_._internal_free_space_probability(), target);
          }

          // optional .osi3.DetectionClassification classification = 9;
          if (cached_has_bits & 0x00000400u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                9, this_._internal_classification(), target);
          }

          // optional double reflectivity = 10;
          if (cached_has_bits & 0x00000100u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                10, this_._internal_reflectivity(), target);
          }

          // optional double echo_pulse_width = 11;
          if (cached_has_bits & 0x00000200u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                11, this_._internal_echo_pulse_width(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.LidarDetection)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t LidarDetection::ByteSizeLong(const MessageLite& base) {
          const LidarDetection& this_ = static_cast<const LidarDetection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t LidarDetection::ByteSizeLong() const {
          const LidarDetection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.LidarDetection)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x000000ffu) {
            // optional .osi3.Identifier object_id = 2;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.object_id_);
            }
            // optional .osi3.Spherical3d position = 3;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.position_);
            }
            // optional .osi3.Spherical3d position_rmse = 4;
            if (cached_has_bits & 0x00000004u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.position_rmse_);
            }
            // optional double existence_probability = 1;
            if (cached_has_bits & 0x00000008u) {
              total_size += 9;
            }
            // optional double height = 5;
            if (cached_has_bits & 0x00000010u) {
              total_size += 9;
            }
            // optional double height_rmse = 6;
            if (cached_has_bits & 0x00000020u) {
              total_size += 9;
            }
            // optional double intensity = 7;
            if (cached_has_bits & 0x00000040u) {
              total_size += 9;
            }
            // optional double free_space_probability = 8;
            if (cached_has_bits & 0x00000080u) {
              total_size += 9;
            }
          }
          if (cached_has_bits & 0x00000700u) {
            // optional double reflectivity = 10;
            if (cached_has_bits & 0x00000100u) {
              total_size += 9;
            }
            // optional double echo_pulse_width = 11;
            if (cached_has_bits & 0x00000200u) {
              total_size += 9;
            }
            // optional .osi3.DetectionClassification classification = 9;
            if (cached_has_bits & 0x00000400u) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_classification());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void LidarDetection::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LidarDetection*>(&to_msg);
  auto& from = static_cast<const LidarDetection&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.LidarDetection)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.object_id_ != nullptr);
      if (_this->_impl_.object_id_ == nullptr) {
        _this->_impl_.object_id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.object_id_);
      } else {
        _this->_impl_.object_id_->MergeFrom(*from._impl_.object_id_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.position_ != nullptr);
      if (_this->_impl_.position_ == nullptr) {
        _this->_impl_.position_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Spherical3d>(arena, *from._impl_.position_);
      } else {
        _this->_impl_.position_->MergeFrom(*from._impl_.position_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.position_rmse_ != nullptr);
      if (_this->_impl_.position_rmse_ == nullptr) {
        _this->_impl_.position_rmse_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Spherical3d>(arena, *from._impl_.position_rmse_);
      } else {
        _this->_impl_.position_rmse_->MergeFrom(*from._impl_.position_rmse_);
      }
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.existence_probability_ = from._impl_.existence_probability_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.height_rmse_ = from._impl_.height_rmse_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.intensity_ = from._impl_.intensity_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.free_space_probability_ = from._impl_.free_space_probability_;
    }
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.reflectivity_ = from._impl_.reflectivity_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.echo_pulse_width_ = from._impl_.echo_pulse_width_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.classification_ = from._impl_.classification_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LidarDetection::CopyFrom(const LidarDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LidarDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LidarDetection::InternalSwap(LidarDetection* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.classification_)
      + sizeof(LidarDetection::_impl_.classification_)
      - PROTOBUF_FIELD_OFFSET(LidarDetection, _impl_.object_id_)>(
          reinterpret_cast<char*>(&_impl_.object_id_),
          reinterpret_cast<char*>(&other->_impl_.object_id_));
}

::google::protobuf::Metadata LidarDetection::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UltrasonicDetectionSpecificHeader::_Internal {
 public:
  using HasBits =
      decltype(std::declval<UltrasonicDetectionSpecificHeader>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UltrasonicDetectionSpecificHeader, _impl_._has_bits_);
};

UltrasonicDetectionSpecificHeader::UltrasonicDetectionSpecificHeader(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.UltrasonicDetectionSpecificHeader)
}
UltrasonicDetectionSpecificHeader::UltrasonicDetectionSpecificHeader(
    ::google::protobuf::Arena* arena, const UltrasonicDetectionSpecificHeader& from)
    : UltrasonicDetectionSpecificHeader(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE UltrasonicDetectionSpecificHeader::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void UltrasonicDetectionSpecificHeader::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, max_range_),
           0,
           offsetof(Impl_, number_of_valid_indirect_detections_) -
               offsetof(Impl_, max_range_) +
               sizeof(Impl_::number_of_valid_indirect_detections_));
}
UltrasonicDetectionSpecificHeader::~UltrasonicDetectionSpecificHeader() {
  // @@protoc_insertion_point(destructor:osi3.UltrasonicDetectionSpecificHeader)
  SharedDtor(*this);
}
inline void UltrasonicDetectionSpecificHeader::SharedDtor(MessageLite& self) {
  UltrasonicDetectionSpecificHeader& this_ = static_cast<UltrasonicDetectionSpecificHeader&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* UltrasonicDetectionSpecificHeader::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) UltrasonicDetectionSpecificHeader(arena);
}
constexpr auto UltrasonicDetectionSpecificHeader::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(UltrasonicDetectionSpecificHeader),
                                            alignof(UltrasonicDetectionSpecificHeader));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull UltrasonicDetectionSpecificHeader::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_UltrasonicDetectionSpecificHeader_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &UltrasonicDetectionSpecificHeader::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<UltrasonicDetectionSpecificHeader>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &UltrasonicDetectionSpecificHeader::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<UltrasonicDetectionSpecificHeader>(), &UltrasonicDetectionSpecificHeader::ByteSizeLong,
            &UltrasonicDetectionSpecificHeader::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(UltrasonicDetectionSpecificHeader, _impl_._cached_size_),
        false,
    },
    &UltrasonicDetectionSpecificHeader::kDescriptorMethods,
    &descriptor_table_osi_5ffeaturedata_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* UltrasonicDetectionSpecificHeader::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> UltrasonicDetectionSpecificHeader::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UltrasonicDetectionSpecificHeader, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::UltrasonicDetectionSpecificHeader>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional uint32 number_of_valid_indirect_detections = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UltrasonicDetectionSpecificHeader, _impl_.number_of_valid_indirect_detections_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(UltrasonicDetectionSpecificHeader, _impl_.number_of_valid_indirect_detections_)}},
    // optional double max_range = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 0, 0, PROTOBUF_FIELD_OFFSET(UltrasonicDetectionSpecificHeader, _impl_.max_range_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional double max_range = 1;
    {PROTOBUF_FIELD_OFFSET(UltrasonicDetectionSpecificHeader, _impl_.max_range_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional uint32 number_of_valid_indirect_detections = 2;
    {PROTOBUF_FIELD_OFFSET(UltrasonicDetectionSpecificHeader, _impl_.number_of_valid_indirect_detections_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void UltrasonicDetectionSpecificHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.UltrasonicDetectionSpecificHeader)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.max_range_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_valid_indirect_detections_) -
        reinterpret_cast<char*>(&_impl_.max_range_)) + sizeof(_impl_.number_of_valid_indirect_detections_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* UltrasonicDetectionSpecificHeader::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const UltrasonicDetectionSpecificHeader& this_ = static_cast<const UltrasonicDetectionSpecificHeader&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* UltrasonicDetectionSpecificHeader::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const UltrasonicDetectionSpecificHeader& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.UltrasonicDetectionSpecificHeader)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional double max_range = 1;
          if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                1, this_._internal_max_range(), target);
          }

          // optional uint32 number_of_valid_indirect_detections = 2;
          if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                2, this_._internal_number_of_valid_indirect_detections(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.UltrasonicDetectionSpecificHeader)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t UltrasonicDetectionSpecificHeader::ByteSizeLong(const MessageLite& base) {
          const UltrasonicDetectionSpecificHeader& this_ = static_cast<const UltrasonicDetectionSpecificHeader&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t UltrasonicDetectionSpecificHeader::ByteSizeLong() const {
          const UltrasonicDetectionSpecificHeader& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.UltrasonicDetectionSpecificHeader)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // optional double max_range = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 9;
            }
            // optional uint32 number_of_valid_indirect_detections = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_number_of_valid_indirect_detections());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void UltrasonicDetectionSpecificHeader::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<UltrasonicDetectionSpecificHeader*>(&to_msg);
  auto& from = static_cast<const UltrasonicDetectionSpecificHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.UltrasonicDetectionSpecificHeader)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.max_range_ = from._impl_.max_range_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.number_of_valid_indirect_detections_ = from._impl_.number_of_valid_indirect_detections_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UltrasonicDetectionSpecificHeader::CopyFrom(const UltrasonicDetectionSpecificHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.UltrasonicDetectionSpecificHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void UltrasonicDetectionSpecificHeader::InternalSwap(UltrasonicDetectionSpecificHeader* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UltrasonicDetectionSpecificHeader, _impl_.number_of_valid_indirect_detections_)
      + sizeof(UltrasonicDetectionSpecificHeader::_impl_.number_of_valid_indirect_detections_)
      - PROTOBUF_FIELD_OFFSET(UltrasonicDetectionSpecificHeader, _impl_.max_range_)>(
          reinterpret_cast<char*>(&_impl_.max_range_),
          reinterpret_cast<char*>(&other->_impl_.max_range_));
}

::google::protobuf::Metadata UltrasonicDetectionSpecificHeader::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UltrasonicDetectionData::_Internal {
 public:
  using HasBits =
      decltype(std::declval<UltrasonicDetectionData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, _impl_._has_bits_);
};

UltrasonicDetectionData::UltrasonicDetectionData(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.UltrasonicDetectionData)
}
inline PROTOBUF_NDEBUG_INLINE UltrasonicDetectionData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::UltrasonicDetectionData& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        detection_{visibility, arena, from.detection_},
        indirect_detection_{visibility, arena, from.indirect_detection_} {}

UltrasonicDetectionData::UltrasonicDetectionData(
    ::google::protobuf::Arena* arena,
    const UltrasonicDetectionData& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UltrasonicDetectionData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.header_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::SensorDetectionHeader>(
                              arena, *from._impl_.header_)
                        : nullptr;
  _impl_.specific_header_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::osi3::UltrasonicDetectionSpecificHeader>(
                              arena, *from._impl_.specific_header_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:osi3.UltrasonicDetectionData)
}
inline PROTOBUF_NDEBUG_INLINE UltrasonicDetectionData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        detection_{visibility, arena},
        indirect_detection_{visibility, arena} {}

inline void UltrasonicDetectionData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, header_),
           0,
           offsetof(Impl_, specific_header_) -
               offsetof(Impl_, header_) +
               sizeof(Impl_::specific_header_));
}
UltrasonicDetectionData::~UltrasonicDetectionData() {
  // @@protoc_insertion_point(destructor:osi3.UltrasonicDetectionData)
  SharedDtor(*this);
}
inline void UltrasonicDetectionData::SharedDtor(MessageLite& self) {
  UltrasonicDetectionData& this_ = static_cast<UltrasonicDetectionData&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.header_;
  delete this_._impl_.specific_header_;
  this_._impl_.~Impl_();
}

inline void* UltrasonicDetectionData::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) UltrasonicDetectionData(arena);
}
constexpr auto UltrasonicDetectionData::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, _impl_.detection_) +
          decltype(UltrasonicDetectionData::_impl_.detection_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, _impl_.indirect_detection_) +
          decltype(UltrasonicDetectionData::_impl_.indirect_detection_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(UltrasonicDetectionData), alignof(UltrasonicDetectionData), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&UltrasonicDetectionData::PlacementNew_,
                                 sizeof(UltrasonicDetectionData),
                                 alignof(UltrasonicDetectionData));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull UltrasonicDetectionData::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_UltrasonicDetectionData_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &UltrasonicDetectionData::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<UltrasonicDetectionData>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &UltrasonicDetectionData::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<UltrasonicDetectionData>(), &UltrasonicDetectionData::ByteSizeLong,
            &UltrasonicDetectionData::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, _impl_._cached_size_),
        false,
    },
    &UltrasonicDetectionData::kDescriptorMethods,
    &descriptor_table_osi_5ffeaturedata_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* UltrasonicDetectionData::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 4, 0, 2> UltrasonicDetectionData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::UltrasonicDetectionData>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .osi3.UltrasonicIndirectDetection indirect_detection = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 3, PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, _impl_.indirect_detection_)}},
    // optional .osi3.SensorDetectionHeader header = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, _impl_.header_)}},
    // repeated .osi3.UltrasonicDetection detection = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 1, PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, _impl_.detection_)}},
    // optional .osi3.UltrasonicDetectionSpecificHeader specific_header = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 2, PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, _impl_.specific_header_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.SensorDetectionHeader header = 1;
    {PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, _impl_.header_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.UltrasonicDetection detection = 2;
    {PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, _impl_.detection_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.UltrasonicDetectionSpecificHeader specific_header = 3;
    {PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, _impl_.specific_header_), _Internal::kHasBitsOffset + 1, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.UltrasonicIndirectDetection indirect_detection = 4;
    {PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, _impl_.indirect_detection_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::SensorDetectionHeader>()},
    {::_pbi::TcParser::GetTable<::osi3::UltrasonicDetection>()},
    {::_pbi::TcParser::GetTable<::osi3::UltrasonicDetectionSpecificHeader>()},
    {::_pbi::TcParser::GetTable<::osi3::UltrasonicIndirectDetection>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void UltrasonicDetectionData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.UltrasonicDetectionData)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.detection_.Clear();
  _impl_.indirect_detection_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.specific_header_ != nullptr);
      _impl_.specific_header_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* UltrasonicDetectionData::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const UltrasonicDetectionData& this_ = static_cast<const UltrasonicDetectionData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* UltrasonicDetectionData::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const UltrasonicDetectionData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.UltrasonicDetectionData)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.SensorDetectionHeader header = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.header_, this_._impl_.header_->GetCachedSize(), target,
                stream);
          }

          // repeated .osi3.UltrasonicDetection detection = 2;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_detection_size());
               i < n; i++) {
            const auto& repfield = this_._internal_detection().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    2, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // optional .osi3.UltrasonicDetectionSpecificHeader specific_header = 3;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.specific_header_, this_._impl_.specific_header_->GetCachedSize(), target,
                stream);
          }

          // repeated .osi3.UltrasonicIndirectDetection indirect_detection = 4;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_indirect_detection_size());
               i < n; i++) {
            const auto& repfield = this_._internal_indirect_detection().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    4, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.UltrasonicDetectionData)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t UltrasonicDetectionData::ByteSizeLong(const MessageLite& base) {
          const UltrasonicDetectionData& this_ = static_cast<const UltrasonicDetectionData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t UltrasonicDetectionData::ByteSizeLong() const {
          const UltrasonicDetectionData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.UltrasonicDetectionData)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .osi3.UltrasonicDetection detection = 2;
            {
              total_size += 1UL * this_._internal_detection_size();
              for (const auto& msg : this_._internal_detection()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.UltrasonicIndirectDetection indirect_detection = 4;
            {
              total_size += 1UL * this_._internal_indirect_detection_size();
              for (const auto& msg : this_._internal_indirect_detection()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // optional .osi3.SensorDetectionHeader header = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.header_);
            }
            // optional .osi3.UltrasonicDetectionSpecificHeader specific_header = 3;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.specific_header_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void UltrasonicDetectionData::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<UltrasonicDetectionData*>(&to_msg);
  auto& from = static_cast<const UltrasonicDetectionData&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.UltrasonicDetectionData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_detection()->MergeFrom(
      from._internal_detection());
  _this->_internal_mutable_indirect_detection()->MergeFrom(
      from._internal_indirect_detection());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.header_ != nullptr);
      if (_this->_impl_.header_ == nullptr) {
        _this->_impl_.header_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::SensorDetectionHeader>(arena, *from._impl_.header_);
      } else {
        _this->_impl_.header_->MergeFrom(*from._impl_.header_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.specific_header_ != nullptr);
      if (_this->_impl_.specific_header_ == nullptr) {
        _this->_impl_.specific_header_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::UltrasonicDetectionSpecificHeader>(arena, *from._impl_.specific_header_);
      } else {
        _this->_impl_.specific_header_->MergeFrom(*from._impl_.specific_header_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UltrasonicDetectionData::CopyFrom(const UltrasonicDetectionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.UltrasonicDetectionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void UltrasonicDetectionData::InternalSwap(UltrasonicDetectionData* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.detection_.InternalSwap(&other->_impl_.detection_);
  _impl_.indirect_detection_.InternalSwap(&other->_impl_.indirect_detection_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, _impl_.specific_header_)
      + sizeof(UltrasonicDetectionData::_impl_.specific_header_)
      - PROTOBUF_FIELD_OFFSET(UltrasonicDetectionData, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::google::protobuf::Metadata UltrasonicDetectionData::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UltrasonicDetection::_Internal {
 public:
  using HasBits =
      decltype(std::declval<UltrasonicDetection>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UltrasonicDetection, _impl_._has_bits_);
};

void UltrasonicDetection::clear_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.object_id_ != nullptr) _impl_.object_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
UltrasonicDetection::UltrasonicDetection(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.UltrasonicDetection)
}
inline PROTOBUF_NDEBUG_INLINE UltrasonicDetection::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::UltrasonicDetection& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

UltrasonicDetection::UltrasonicDetection(
    ::google::protobuf::Arena* arena,
    const UltrasonicDetection& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UltrasonicDetection* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.object_id_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.object_id_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, existence_probability_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, existence_probability_),
           offsetof(Impl_, distance_) -
               offsetof(Impl_, existence_probability_) +
               sizeof(Impl_::distance_));

  // @@protoc_insertion_point(copy_constructor:osi3.UltrasonicDetection)
}
inline PROTOBUF_NDEBUG_INLINE UltrasonicDetection::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void UltrasonicDetection::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, object_id_),
           0,
           offsetof(Impl_, distance_) -
               offsetof(Impl_, object_id_) +
               sizeof(Impl_::distance_));
}
UltrasonicDetection::~UltrasonicDetection() {
  // @@protoc_insertion_point(destructor:osi3.UltrasonicDetection)
  SharedDtor(*this);
}
inline void UltrasonicDetection::SharedDtor(MessageLite& self) {
  UltrasonicDetection& this_ = static_cast<UltrasonicDetection&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.object_id_;
  this_._impl_.~Impl_();
}

inline void* UltrasonicDetection::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) UltrasonicDetection(arena);
}
constexpr auto UltrasonicDetection::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(UltrasonicDetection),
                                            alignof(UltrasonicDetection));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull UltrasonicDetection::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_UltrasonicDetection_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &UltrasonicDetection::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<UltrasonicDetection>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &UltrasonicDetection::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<UltrasonicDetection>(), &UltrasonicDetection::ByteSizeLong,
            &UltrasonicDetection::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(UltrasonicDetection, _impl_._cached_size_),
        false,
    },
    &UltrasonicDetection::kDescriptorMethods,
    &descriptor_table_osi_5ffeaturedata_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* UltrasonicDetection::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> UltrasonicDetection::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UltrasonicDetection, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::UltrasonicDetection>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional double existence_probability = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 1, 0, PROTOBUF_FIELD_OFFSET(UltrasonicDetection, _impl_.existence_probability_)}},
    // optional .osi3.Identifier object_id = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(UltrasonicDetection, _impl_.object_id_)}},
    // optional double distance = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 2, 0, PROTOBUF_FIELD_OFFSET(UltrasonicDetection, _impl_.distance_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional double existence_probability = 1;
    {PROTOBUF_FIELD_OFFSET(UltrasonicDetection, _impl_.existence_probability_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .osi3.Identifier object_id = 2;
    {PROTOBUF_FIELD_OFFSET(UltrasonicDetection, _impl_.object_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional double distance = 3;
    {PROTOBUF_FIELD_OFFSET(UltrasonicDetection, _impl_.distance_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void UltrasonicDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.UltrasonicDetection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.object_id_ != nullptr);
    _impl_.object_id_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.existence_probability_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.distance_) -
        reinterpret_cast<char*>(&_impl_.existence_probability_)) + sizeof(_impl_.distance_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* UltrasonicDetection::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const UltrasonicDetection& this_ = static_cast<const UltrasonicDetection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* UltrasonicDetection::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const UltrasonicDetection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.UltrasonicDetection)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional double existence_probability = 1;
          if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                1, this_._internal_existence_probability(), target);
          }

          // optional .osi3.Identifier object_id = 2;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.object_id_, this_._impl_.object_id_->GetCachedSize(), target,
                stream);
          }

          // optional double distance = 3;
          if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                3, this_._internal_distance(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.UltrasonicDetection)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t UltrasonicDetection::ByteSizeLong(const MessageLite& base) {
          const UltrasonicDetection& this_ = static_cast<const UltrasonicDetection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t UltrasonicDetection::ByteSizeLong() const {
          const UltrasonicDetection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.UltrasonicDetection)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000007u) {
            // optional .osi3.Identifier object_id = 2;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.object_id_);
            }
            // optional double existence_probability = 1;
            if (cached_has_bits & 0x00000002u) {
              total_size += 9;
            }
            // optional double distance = 3;
            if (cached_has_bits & 0x00000004u) {
              total_size += 9;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void UltrasonicDetection::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<UltrasonicDetection*>(&to_msg);
  auto& from = static_cast<const UltrasonicDetection&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.UltrasonicDetection)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.object_id_ != nullptr);
      if (_this->_impl_.object_id_ == nullptr) {
        _this->_impl_.object_id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.object_id_);
      } else {
        _this->_impl_.object_id_->MergeFrom(*from._impl_.object_id_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.existence_probability_ = from._impl_.existence_probability_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.distance_ = from._impl_.distance_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UltrasonicDetection::CopyFrom(const UltrasonicDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.UltrasonicDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void UltrasonicDetection::InternalSwap(UltrasonicDetection* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UltrasonicDetection, _impl_.distance_)
      + sizeof(UltrasonicDetection::_impl_.distance_)
      - PROTOBUF_FIELD_OFFSET(UltrasonicDetection, _impl_.object_id_)>(
          reinterpret_cast<char*>(&_impl_.object_id_),
          reinterpret_cast<char*>(&other->_impl_.object_id_));
}

::google::protobuf::Metadata UltrasonicDetection::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UltrasonicIndirectDetection::_Internal {
 public:
  using HasBits =
      decltype(std::declval<UltrasonicIndirectDetection>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_._has_bits_);
};

void UltrasonicIndirectDetection::clear_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.object_id_ != nullptr) _impl_.object_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void UltrasonicIndirectDetection::clear_receiver_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.receiver_id_ != nullptr) _impl_.receiver_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void UltrasonicIndirectDetection::clear_receiver_origin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.receiver_origin_ != nullptr) _impl_.receiver_origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
UltrasonicIndirectDetection::UltrasonicIndirectDetection(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.UltrasonicIndirectDetection)
}
inline PROTOBUF_NDEBUG_INLINE UltrasonicIndirectDetection::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::UltrasonicIndirectDetection& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

UltrasonicIndirectDetection::UltrasonicIndirectDetection(
    ::google::protobuf::Arena* arena,
    const UltrasonicIndirectDetection& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UltrasonicIndirectDetection* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.object_id_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.object_id_)
                        : nullptr;
  _impl_.receiver_id_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.receiver_id_)
                        : nullptr;
  _impl_.receiver_origin_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Vector3d>(
                              arena, *from._impl_.receiver_origin_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, existence_probability_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, existence_probability_),
           offsetof(Impl_, ellipsoid_axial_) -
               offsetof(Impl_, existence_probability_) +
               sizeof(Impl_::ellipsoid_axial_));

  // @@protoc_insertion_point(copy_constructor:osi3.UltrasonicIndirectDetection)
}
inline PROTOBUF_NDEBUG_INLINE UltrasonicIndirectDetection::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void UltrasonicIndirectDetection::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, object_id_),
           0,
           offsetof(Impl_, ellipsoid_axial_) -
               offsetof(Impl_, object_id_) +
               sizeof(Impl_::ellipsoid_axial_));
}
UltrasonicIndirectDetection::~UltrasonicIndirectDetection() {
  // @@protoc_insertion_point(destructor:osi3.UltrasonicIndirectDetection)
  SharedDtor(*this);
}
inline void UltrasonicIndirectDetection::SharedDtor(MessageLite& self) {
  UltrasonicIndirectDetection& this_ = static_cast<UltrasonicIndirectDetection&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.object_id_;
  delete this_._impl_.receiver_id_;
  delete this_._impl_.receiver_origin_;
  this_._impl_.~Impl_();
}

inline void* UltrasonicIndirectDetection::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) UltrasonicIndirectDetection(arena);
}
constexpr auto UltrasonicIndirectDetection::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(UltrasonicIndirectDetection),
                                            alignof(UltrasonicIndirectDetection));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull UltrasonicIndirectDetection::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_UltrasonicIndirectDetection_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &UltrasonicIndirectDetection::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<UltrasonicIndirectDetection>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &UltrasonicIndirectDetection::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<UltrasonicIndirectDetection>(), &UltrasonicIndirectDetection::ByteSizeLong,
            &UltrasonicIndirectDetection::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_._cached_size_),
        false,
    },
    &UltrasonicIndirectDetection::kDescriptorMethods,
    &descriptor_table_osi_5ffeaturedata_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* UltrasonicIndirectDetection::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 3, 0, 2> UltrasonicIndirectDetection::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::UltrasonicIndirectDetection>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional double existence_probability = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 3, 0, PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_.existence_probability_)}},
    // optional .osi3.Identifier object_id = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_.object_id_)}},
    // optional double ellipsoid_radial = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 4, 0, PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_.ellipsoid_radial_)}},
    // optional double ellipsoid_axial = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 5, 0, PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_.ellipsoid_axial_)}},
    // optional .osi3.Identifier receiver_id = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 1, 1, PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_.receiver_id_)}},
    // optional .osi3.Vector3d receiver_origin = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 2, 2, PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_.receiver_origin_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional double existence_probability = 1;
    {PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_.existence_probability_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .osi3.Identifier object_id = 2;
    {PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_.object_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional double ellipsoid_radial = 3;
    {PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_.ellipsoid_radial_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double ellipsoid_axial = 4;
    {PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_.ellipsoid_axial_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .osi3.Identifier receiver_id = 5;
    {PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_.receiver_id_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.Vector3d receiver_origin = 6;
    {PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_.receiver_origin_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::Vector3d>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void UltrasonicIndirectDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.UltrasonicIndirectDetection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.object_id_ != nullptr);
      _impl_.object_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.receiver_id_ != nullptr);
      _impl_.receiver_id_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.receiver_origin_ != nullptr);
      _impl_.receiver_origin_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.existence_probability_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ellipsoid_axial_) -
        reinterpret_cast<char*>(&_impl_.existence_probability_)) + sizeof(_impl_.ellipsoid_axial_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* UltrasonicIndirectDetection::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const UltrasonicIndirectDetection& this_ = static_cast<const UltrasonicIndirectDetection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* UltrasonicIndirectDetection::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const UltrasonicIndirectDetection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.UltrasonicIndirectDetection)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional double existence_probability = 1;
          if (cached_has_bits & 0x00000008u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                1, this_._internal_existence_probability(), target);
          }

          // optional .osi3.Identifier object_id = 2;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.object_id_, this_._impl_.object_id_->GetCachedSize(), target,
                stream);
          }

          // optional double ellipsoid_radial = 3;
          if (cached_has_bits & 0x00000010u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                3, this_._internal_ellipsoid_radial(), target);
          }

          // optional double ellipsoid_axial = 4;
          if (cached_has_bits & 0x00000020u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                4, this_._internal_ellipsoid_axial(), target);
          }

          // optional .osi3.Identifier receiver_id = 5;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                5, *this_._impl_.receiver_id_, this_._impl_.receiver_id_->GetCachedSize(), target,
                stream);
          }

          // optional .osi3.Vector3d receiver_origin = 6;
          if (cached_has_bits & 0x00000004u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                6, *this_._impl_.receiver_origin_, this_._impl_.receiver_origin_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.UltrasonicIndirectDetection)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t UltrasonicIndirectDetection::ByteSizeLong(const MessageLite& base) {
          const UltrasonicIndirectDetection& this_ = static_cast<const UltrasonicIndirectDetection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t UltrasonicIndirectDetection::ByteSizeLong() const {
          const UltrasonicIndirectDetection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.UltrasonicIndirectDetection)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x0000003fu) {
            // optional .osi3.Identifier object_id = 2;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.object_id_);
            }
            // optional .osi3.Identifier receiver_id = 5;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.receiver_id_);
            }
            // optional .osi3.Vector3d receiver_origin = 6;
            if (cached_has_bits & 0x00000004u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.receiver_origin_);
            }
            // optional double existence_probability = 1;
            if (cached_has_bits & 0x00000008u) {
              total_size += 9;
            }
            // optional double ellipsoid_radial = 3;
            if (cached_has_bits & 0x00000010u) {
              total_size += 9;
            }
            // optional double ellipsoid_axial = 4;
            if (cached_has_bits & 0x00000020u) {
              total_size += 9;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void UltrasonicIndirectDetection::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<UltrasonicIndirectDetection*>(&to_msg);
  auto& from = static_cast<const UltrasonicIndirectDetection&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.UltrasonicIndirectDetection)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.object_id_ != nullptr);
      if (_this->_impl_.object_id_ == nullptr) {
        _this->_impl_.object_id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.object_id_);
      } else {
        _this->_impl_.object_id_->MergeFrom(*from._impl_.object_id_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.receiver_id_ != nullptr);
      if (_this->_impl_.receiver_id_ == nullptr) {
        _this->_impl_.receiver_id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.receiver_id_);
      } else {
        _this->_impl_.receiver_id_->MergeFrom(*from._impl_.receiver_id_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.receiver_origin_ != nullptr);
      if (_this->_impl_.receiver_origin_ == nullptr) {
        _this->_impl_.receiver_origin_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Vector3d>(arena, *from._impl_.receiver_origin_);
      } else {
        _this->_impl_.receiver_origin_->MergeFrom(*from._impl_.receiver_origin_);
      }
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.existence_probability_ = from._impl_.existence_probability_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.ellipsoid_radial_ = from._impl_.ellipsoid_radial_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ellipsoid_axial_ = from._impl_.ellipsoid_axial_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UltrasonicIndirectDetection::CopyFrom(const UltrasonicIndirectDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.UltrasonicIndirectDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void UltrasonicIndirectDetection::InternalSwap(UltrasonicIndirectDetection* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_.ellipsoid_axial_)
      + sizeof(UltrasonicIndirectDetection::_impl_.ellipsoid_axial_)
      - PROTOBUF_FIELD_OFFSET(UltrasonicIndirectDetection, _impl_.object_id_)>(
          reinterpret_cast<char*>(&_impl_.object_id_),
          reinterpret_cast<char*>(&other->_impl_.object_id_));
}

::google::protobuf::Metadata UltrasonicIndirectDetection::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CameraDetectionSpecificHeader::_Internal {
 public:
  using HasBits =
      decltype(std::declval<CameraDetectionSpecificHeader>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CameraDetectionSpecificHeader, _impl_._has_bits_);
};

CameraDetectionSpecificHeader::CameraDetectionSpecificHeader(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.CameraDetectionSpecificHeader)
}
CameraDetectionSpecificHeader::CameraDetectionSpecificHeader(
    ::google::protobuf::Arena* arena, const CameraDetectionSpecificHeader& from)
    : CameraDetectionSpecificHeader(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CameraDetectionSpecificHeader::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CameraDetectionSpecificHeader::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.number_of_valid_points_ = {};
}
CameraDetectionSpecificHeader::~CameraDetectionSpecificHeader() {
  // @@protoc_insertion_point(destructor:osi3.CameraDetectionSpecificHeader)
  SharedDtor(*this);
}
inline void CameraDetectionSpecificHeader::SharedDtor(MessageLite& self) {
  CameraDetectionSpecificHeader& this_ = static_cast<CameraDetectionSpecificHeader&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* CameraDetectionSpecificHeader::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) CameraDetectionSpecificHeader(arena);
}
constexpr auto CameraDetectionSpecificHeader::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(CameraDetectionSpecificHeader),
                                            alignof(CameraDetectionSpecificHeader));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull CameraDetectionSpecificHeader::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_CameraDetectionSpecificHeader_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &CameraDetectionSpecificHeader::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<CameraDetectionSpecificHeader>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &CameraDetectionSpecificHeader::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<CameraDetectionSpecificHeader>(), &CameraDetectionSpecificHeader::ByteSizeLong,
            &CameraDetectionSpecificHeader::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(CameraDetectionSpecificHeader, _impl_._cached_size_),
        false,
    },
    &CameraDetectionSpecificHeader::kDescriptorMethods,
    &descriptor_table_osi_5ffeaturedata_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* CameraDetectionSpecificHeader::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> CameraDetectionSpecificHeader::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CameraDetectionSpecificHeader, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::CameraDetectionSpecificHeader>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional uint32 number_of_valid_points = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CameraDetectionSpecificHeader, _impl_.number_of_valid_points_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(CameraDetectionSpecificHeader, _impl_.number_of_valid_points_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 number_of_valid_points = 1;
    {PROTOBUF_FIELD_OFFSET(CameraDetectionSpecificHeader, _impl_.number_of_valid_points_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void CameraDetectionSpecificHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.CameraDetectionSpecificHeader)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.number_of_valid_points_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* CameraDetectionSpecificHeader::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const CameraDetectionSpecificHeader& this_ = static_cast<const CameraDetectionSpecificHeader&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* CameraDetectionSpecificHeader::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const CameraDetectionSpecificHeader& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.CameraDetectionSpecificHeader)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional uint32 number_of_valid_points = 1;
          if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                1, this_._internal_number_of_valid_points(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.CameraDetectionSpecificHeader)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t CameraDetectionSpecificHeader::ByteSizeLong(const MessageLite& base) {
          const CameraDetectionSpecificHeader& this_ = static_cast<const CameraDetectionSpecificHeader&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t CameraDetectionSpecificHeader::ByteSizeLong() const {
          const CameraDetectionSpecificHeader& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.CameraDetectionSpecificHeader)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

           {
            // optional uint32 number_of_valid_points = 1;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_number_of_valid_points());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void CameraDetectionSpecificHeader::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<CameraDetectionSpecificHeader*>(&to_msg);
  auto& from = static_cast<const CameraDetectionSpecificHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.CameraDetectionSpecificHeader)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_impl_.number_of_valid_points_ = from._impl_.number_of_valid_points_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CameraDetectionSpecificHeader::CopyFrom(const CameraDetectionSpecificHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.CameraDetectionSpecificHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CameraDetectionSpecificHeader::InternalSwap(CameraDetectionSpecificHeader* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
        swap(_impl_.number_of_valid_points_, other->_impl_.number_of_valid_points_);
}

::google::protobuf::Metadata CameraDetectionSpecificHeader::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CameraDetectionData::_Internal {
 public:
  using HasBits =
      decltype(std::declval<CameraDetectionData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CameraDetectionData, _impl_._has_bits_);
};

CameraDetectionData::CameraDetectionData(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.CameraDetectionData)
}
inline PROTOBUF_NDEBUG_INLINE CameraDetectionData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::CameraDetectionData& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        detection_{visibility, arena, from.detection_},
        point_{visibility, arena, from.point_} {}

CameraDetectionData::CameraDetectionData(
    ::google::protobuf::Arena* arena,
    const CameraDetectionData& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CameraDetectionData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.header_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::SensorDetectionHeader>(
                              arena, *from._impl_.header_)
                        : nullptr;
  _impl_.specific_header_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::osi3::CameraDetectionSpecificHeader>(
                              arena, *from._impl_.specific_header_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:osi3.CameraDetectionData)
}
inline PROTOBUF_NDEBUG_INLINE CameraDetectionData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        detection_{visibility, arena},
        point_{visibility, arena} {}

inline void CameraDetectionData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, header_),
           0,
           offsetof(Impl_, specific_header_) -
               offsetof(Impl_, header_) +
               sizeof(Impl_::specific_header_));
}
CameraDetectionData::~CameraDetectionData() {
  // @@protoc_insertion_point(destructor:osi3.CameraDetectionData)
  SharedDtor(*this);
}
inline void CameraDetectionData::SharedDtor(MessageLite& self) {
  CameraDetectionData& this_ = static_cast<CameraDetectionData&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.header_;
  delete this_._impl_.specific_header_;
  this_._impl_.~Impl_();
}

inline void* CameraDetectionData::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) CameraDetectionData(arena);
}
constexpr auto CameraDetectionData::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(CameraDetectionData, _impl_.detection_) +
          decltype(CameraDetectionData::_impl_.detection_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(CameraDetectionData, _impl_.point_) +
          decltype(CameraDetectionData::_impl_.point_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(CameraDetectionData), alignof(CameraDetectionData), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&CameraDetectionData::PlacementNew_,
                                 sizeof(CameraDetectionData),
                                 alignof(CameraDetectionData));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull CameraDetectionData::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_CameraDetectionData_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &CameraDetectionData::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<CameraDetectionData>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &CameraDetectionData::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<CameraDetectionData>(), &CameraDetectionData::ByteSizeLong,
            &CameraDetectionData::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(CameraDetectionData, _impl_._cached_size_),
        false,
    },
    &CameraDetectionData::kDescriptorMethods,
    &descriptor_table_osi_5ffeaturedata_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* CameraDetectionData::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 4, 0, 2> CameraDetectionData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CameraDetectionData, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::CameraDetectionData>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .osi3.CameraPoint point = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 3, PROTOBUF_FIELD_OFFSET(CameraDetectionData, _impl_.point_)}},
    // optional .osi3.SensorDetectionHeader header = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CameraDetectionData, _impl_.header_)}},
    // repeated .osi3.CameraDetection detection = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 1, PROTOBUF_FIELD_OFFSET(CameraDetectionData, _impl_.detection_)}},
    // optional .osi3.CameraDetectionSpecificHeader specific_header = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 2, PROTOBUF_FIELD_OFFSET(CameraDetectionData, _impl_.specific_header_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.SensorDetectionHeader header = 1;
    {PROTOBUF_FIELD_OFFSET(CameraDetectionData, _impl_.header_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.CameraDetection detection = 2;
    {PROTOBUF_FIELD_OFFSET(CameraDetectionData, _impl_.detection_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.CameraDetectionSpecificHeader specific_header = 3;
    {PROTOBUF_FIELD_OFFSET(CameraDetectionData, _impl_.specific_header_), _Internal::kHasBitsOffset + 1, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.CameraPoint point = 4;
    {PROTOBUF_FIELD_OFFSET(CameraDetectionData, _impl_.point_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::SensorDetectionHeader>()},
    {::_pbi::TcParser::GetTable<::osi3::CameraDetection>()},
    {::_pbi::TcParser::GetTable<::osi3::CameraDetectionSpecificHeader>()},
    {::_pbi::TcParser::GetTable<::osi3::CameraPoint>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void CameraDetectionData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.CameraDetectionData)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.detection_.Clear();
  _impl_.point_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.header_ != nullptr);
      _impl_.header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.specific_header_ != nullptr);
      _impl_.specific_header_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* CameraDetectionData::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const CameraDetectionData& this_ = static_cast<const CameraDetectionData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* CameraDetectionData::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const CameraDetectionData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.CameraDetectionData)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.SensorDetectionHeader header = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.header_, this_._impl_.header_->GetCachedSize(), target,
                stream);
          }

          // repeated .osi3.CameraDetection detection = 2;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_detection_size());
               i < n; i++) {
            const auto& repfield = this_._internal_detection().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    2, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // optional .osi3.CameraDetectionSpecificHeader specific_header = 3;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.specific_header_, this_._impl_.specific_header_->GetCachedSize(), target,
                stream);
          }

          // repeated .osi3.CameraPoint point = 4;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_point_size());
               i < n; i++) {
            const auto& repfield = this_._internal_point().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    4, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.CameraDetectionData)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t CameraDetectionData::ByteSizeLong(const MessageLite& base) {
          const CameraDetectionData& this_ = static_cast<const CameraDetectionData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t CameraDetectionData::ByteSizeLong() const {
          const CameraDetectionData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.CameraDetectionData)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .osi3.CameraDetection detection = 2;
            {
              total_size += 1UL * this_._internal_detection_size();
              for (const auto& msg : this_._internal_detection()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.CameraPoint point = 4;
            {
              total_size += 1UL * this_._internal_point_size();
              for (const auto& msg : this_._internal_point()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // optional .osi3.SensorDetectionHeader header = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.header_);
            }
            // optional .osi3.CameraDetectionSpecificHeader specific_header = 3;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.specific_header_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void CameraDetectionData::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<CameraDetectionData*>(&to_msg);
  auto& from = static_cast<const CameraDetectionData&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.CameraDetectionData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_detection()->MergeFrom(
      from._internal_detection());
  _this->_internal_mutable_point()->MergeFrom(
      from._internal_point());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.header_ != nullptr);
      if (_this->_impl_.header_ == nullptr) {
        _this->_impl_.header_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::SensorDetectionHeader>(arena, *from._impl_.header_);
      } else {
        _this->_impl_.header_->MergeFrom(*from._impl_.header_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.specific_header_ != nullptr);
      if (_this->_impl_.specific_header_ == nullptr) {
        _this->_impl_.specific_header_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::CameraDetectionSpecificHeader>(arena, *from._impl_.specific_header_);
      } else {
        _this->_impl_.specific_header_->MergeFrom(*from._impl_.specific_header_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CameraDetectionData::CopyFrom(const CameraDetectionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.CameraDetectionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CameraDetectionData::InternalSwap(CameraDetectionData* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.detection_.InternalSwap(&other->_impl_.detection_);
  _impl_.point_.InternalSwap(&other->_impl_.point_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CameraDetectionData, _impl_.specific_header_)
      + sizeof(CameraDetectionData::_impl_.specific_header_)
      - PROTOBUF_FIELD_OFFSET(CameraDetectionData, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::google::protobuf::Metadata CameraDetectionData::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CameraDetection::_Internal {
 public:
  using HasBits =
      decltype(std::declval<CameraDetection>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_._has_bits_);
};

void CameraDetection::clear_object_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.object_id_ != nullptr) _impl_.object_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CameraDetection::clear_time_difference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.time_difference_ != nullptr) _impl_.time_difference_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CameraDetection::clear_ambiguity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ambiguity_id_ != nullptr) _impl_.ambiguity_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CameraDetection::clear_color_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.color_description_ != nullptr) _impl_.color_description_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CameraDetection::CameraDetection(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.CameraDetection)
}
inline PROTOBUF_NDEBUG_INLINE CameraDetection::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::CameraDetection& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

CameraDetection::CameraDetection(
    ::google::protobuf::Arena* arena,
    const CameraDetection& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CameraDetection* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.object_id_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.object_id_)
                        : nullptr;
  _impl_.time_difference_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Timestamp>(
                              arena, *from._impl_.time_difference_)
                        : nullptr;
  _impl_.ambiguity_id_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.ambiguity_id_)
                        : nullptr;
  _impl_.color_description_ = (cached_has_bits & 0x00000008u) ? ::google::protobuf::Message::CopyConstruct<::osi3::ColorDescription>(
                              arena, *from._impl_.color_description_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, existence_probability_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, existence_probability_),
           offsetof(Impl_, number_of_points_) -
               offsetof(Impl_, existence_probability_) +
               sizeof(Impl_::number_of_points_));

  // @@protoc_insertion_point(copy_constructor:osi3.CameraDetection)
}
inline PROTOBUF_NDEBUG_INLINE CameraDetection::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CameraDetection::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, object_id_),
           0,
           offsetof(Impl_, number_of_points_) -
               offsetof(Impl_, object_id_) +
               sizeof(Impl_::number_of_points_));
}
CameraDetection::~CameraDetection() {
  // @@protoc_insertion_point(destructor:osi3.CameraDetection)
  SharedDtor(*this);
}
inline void CameraDetection::SharedDtor(MessageLite& self) {
  CameraDetection& this_ = static_cast<CameraDetection&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.object_id_;
  delete this_._impl_.time_difference_;
  delete this_._impl_.ambiguity_id_;
  delete this_._impl_.color_description_;
  this_._impl_.~Impl_();
}

inline void* CameraDetection::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) CameraDetection(arena);
}
constexpr auto CameraDetection::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(CameraDetection),
                                            alignof(CameraDetection));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull CameraDetection::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_CameraDetection_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &CameraDetection::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<CameraDetection>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &CameraDetection::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<CameraDetection>(), &CameraDetection::ByteSizeLong,
            &CameraDetection::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_._cached_size_),
        false,
    },
    &CameraDetection::kDescriptorMethods,
    &descriptor_table_osi_5ffeaturedata_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* CameraDetection::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 33, 6, 0, 7> CameraDetection::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_._has_bits_),
    0, // no _extensions_
    33, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    0,  // skipmap
    offsetof(decltype(_table_), field_entries),
    33,  // num_field_entries
    6,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::CameraDetection>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional double existence_probability = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 4, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.existence_probability_)}},
    // optional .osi3.Identifier object_id = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.object_id_)}},
    // optional .osi3.Timestamp time_difference = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.time_difference_)}},
    // optional .osi3.CameraDetection.ImageShapeType image_shape_type = 4;
    {::_pbi::TcParser::FastEr0S1,
     {32, 5, 7, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.image_shape_type_)}},
    // optional bool shape_classification_background = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CameraDetection, _impl_.shape_classification_background_), 6>(),
     {40, 6, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_background_)}},
    // optional bool shape_classification_foreground = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CameraDetection, _impl_.shape_classification_foreground_), 7>(),
     {48, 7, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_foreground_)}},
    // optional bool shape_classification_flat = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CameraDetection, _impl_.shape_classification_flat_), 8>(),
     {56, 8, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_flat_)}},
    // optional bool shape_classification_upright = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CameraDetection, _impl_.shape_classification_upright_), 9>(),
     {64, 9, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_upright_)}},
    // optional bool shape_classification_ground = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CameraDetection, _impl_.shape_classification_ground_), 10>(),
     {72, 10, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_ground_)}},
    // optional bool shape_classification_sky = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CameraDetection, _impl_.shape_classification_sky_), 11>(),
     {80, 11, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_sky_)}},
    // optional bool shape_classification_vegetation = 11;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CameraDetection, _impl_.shape_classification_vegetation_), 12>(),
     {88, 12, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_vegetation_)}},
    // optional bool shape_classification_road = 12;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CameraDetection, _impl_.shape_classification_road_), 13>(),
     {96, 13, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_road_)}},
    // optional bool shape_classification_non_driving_lane = 13;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CameraDetection, _impl_.shape_classification_non_driving_lane_), 14>(),
     {104, 14, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_non_driving_lane_)}},
    // optional bool shape_classification_non_road = 14;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CameraDetection, _impl_.shape_classification_non_road_), 15>(),
     {112, 15, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_non_road_)}},
    // optional bool shape_classification_stationary_object = 15;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CameraDetection, _impl_.shape_classification_stationary_object_), 16>(),
     {120, 16, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_stationary_object_)}},
    // optional bool shape_classification_moving_object = 16;
    {::_pbi::TcParser::FastV8S2,
     {384, 17, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_moving_object_)}},
    // optional bool shape_classification_landmark = 17;
    {::_pbi::TcParser::FastV8S2,
     {392, 18, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_landmark_)}},
    // optional bool shape_classification_traffic_sign = 18;
    {::_pbi::TcParser::FastV8S2,
     {400, 19, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_traffic_sign_)}},
    // optional bool shape_classification_traffic_light = 19;
    {::_pbi::TcParser::FastV8S2,
     {408, 20, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_traffic_light_)}},
    // optional bool shape_classification_road_marking = 20;
    {::_pbi::TcParser::FastV8S2,
     {416, 21, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_road_marking_)}},
    // optional bool shape_classification_vehicle = 21;
    {::_pbi::TcParser::FastV8S2,
     {424, 22, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_vehicle_)}},
    // optional bool shape_classification_pedestrian = 22;
    {::_pbi::TcParser::FastV8S2,
     {432, 23, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_pedestrian_)}},
    // optional bool shape_classification_animal = 23;
    {::_pbi::TcParser::FastV8S2,
     {440, 24, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_animal_)}},
    // optional bool shape_classification_pedestrian_front = 24;
    {::_pbi::TcParser::FastV8S2,
     {448, 25, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_pedestrian_front_)}},
    // optional bool shape_classification_pedestrian_side = 25;
    {::_pbi::TcParser::FastV8S2,
     {456, 26, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_pedestrian_side_)}},
    // optional bool shape_classification_pedestrian_rear = 26;
    {::_pbi::TcParser::FastV8S2,
     {464, 27, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_pedestrian_rear_)}},
    // optional double shape_classification_probability = 27;
    {::_pbi::TcParser::FastF64S2,
     {473, 29, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_probability_)}},
    // optional .osi3.CameraDetection.Color color = 28;
    {::_pbi::TcParser::FastEr0S2,
     {480, 28, 11, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.color_)}},
    // optional double color_probability = 29;
    {::_pbi::TcParser::FastF64S2,
     {489, 30, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.color_probability_)}},
    // optional .osi3.Identifier ambiguity_id = 30;
    {::_pbi::TcParser::FastMtS2,
     {498, 2, 2, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.ambiguity_id_)}},
    // optional uint32 first_point_index = 31;
    {::_pbi::TcParser::FastV32S2,
     {504, 31, 0, PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.first_point_index_)}},
  }}, {{
    33, 0, 1,
    65534, 32,
    65535, 65535
  }}, {{
    // optional double existence_probability = 1;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.existence_probability_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .osi3.Identifier object_id = 2;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.object_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.Timestamp time_difference = 3;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.time_difference_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.CameraDetection.ImageShapeType image_shape_type = 4;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.image_shape_type_), _Internal::kHasBitsOffset + 5, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional bool shape_classification_background = 5;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_background_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_foreground = 6;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_foreground_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_flat = 7;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_flat_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_upright = 8;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_upright_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_ground = 9;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_ground_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_sky = 10;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_sky_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_vegetation = 11;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_vegetation_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_road = 12;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_road_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_non_driving_lane = 13;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_non_driving_lane_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_non_road = 14;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_non_road_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_stationary_object = 15;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_stationary_object_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_moving_object = 16;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_moving_object_), _Internal::kHasBitsOffset + 17, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_landmark = 17;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_landmark_), _Internal::kHasBitsOffset + 18, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_traffic_sign = 18;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_traffic_sign_), _Internal::kHasBitsOffset + 19, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_traffic_light = 19;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_traffic_light_), _Internal::kHasBitsOffset + 20, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_road_marking = 20;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_road_marking_), _Internal::kHasBitsOffset + 21, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_vehicle = 21;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_vehicle_), _Internal::kHasBitsOffset + 22, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_pedestrian = 22;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_pedestrian_), _Internal::kHasBitsOffset + 23, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_animal = 23;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_animal_), _Internal::kHasBitsOffset + 24, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_pedestrian_front = 24;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_pedestrian_front_), _Internal::kHasBitsOffset + 25, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_pedestrian_side = 25;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_pedestrian_side_), _Internal::kHasBitsOffset + 26, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool shape_classification_pedestrian_rear = 26;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_pedestrian_rear_), _Internal::kHasBitsOffset + 27, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double shape_classification_probability = 27;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.shape_classification_probability_), _Internal::kHasBitsOffset + 29, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .osi3.CameraDetection.Color color = 28;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.color_), _Internal::kHasBitsOffset + 28, 5,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional double color_probability = 29;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.color_probability_), _Internal::kHasBitsOffset + 30, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .osi3.Identifier ambiguity_id = 30;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.ambiguity_id_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint32 first_point_index = 31;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.first_point_index_), _Internal::kHasBitsOffset + 31, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 number_of_points = 32;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.number_of_points_), _Internal::kHasBitsOffset + 32, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional .osi3.ColorDescription color_description = 33;
    {PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.color_description_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::Timestamp>()},
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::ColorDescription>()},
    {0, 8},
    {0, 12},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void CameraDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.CameraDetection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.object_id_ != nullptr);
      _impl_.object_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.time_difference_ != nullptr);
      _impl_.time_difference_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.ambiguity_id_ != nullptr);
      _impl_.ambiguity_id_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.color_description_ != nullptr);
      _impl_.color_description_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.existence_probability_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.shape_classification_foreground_) -
        reinterpret_cast<char*>(&_impl_.existence_probability_)) + sizeof(_impl_.shape_classification_foreground_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.shape_classification_flat_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.shape_classification_non_road_) -
        reinterpret_cast<char*>(&_impl_.shape_classification_flat_)) + sizeof(_impl_.shape_classification_non_road_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.shape_classification_stationary_object_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.shape_classification_pedestrian_) -
        reinterpret_cast<char*>(&_impl_.shape_classification_stationary_object_)) + sizeof(_impl_.shape_classification_pedestrian_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.shape_classification_animal_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.first_point_index_) -
        reinterpret_cast<char*>(&_impl_.shape_classification_animal_)) + sizeof(_impl_.first_point_index_));
  }
  _impl_.number_of_points_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* CameraDetection::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const CameraDetection& this_ = static_cast<const CameraDetection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* CameraDetection::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const CameraDetection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.CameraDetection)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional double existence_probability = 1;
          if (cached_has_bits & 0x00000010u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                1, this_._internal_existence_probability(), target);
          }

          // optional .osi3.Identifier object_id = 2;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.object_id_, this_._impl_.object_id_->GetCachedSize(), target,
                stream);
          }

          // optional .osi3.Timestamp time_difference = 3;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.time_difference_, this_._impl_.time_difference_->GetCachedSize(), target,
                stream);
          }

          // optional .osi3.CameraDetection.ImageShapeType image_shape_type = 4;
          if (cached_has_bits & 0x00000020u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                4, this_._internal_image_shape_type(), target);
          }

          // optional bool shape_classification_background = 5;
          if (cached_has_bits & 0x00000040u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                5, this_._internal_shape_classification_background(), target);
          }

          // optional bool shape_classification_foreground = 6;
          if (cached_has_bits & 0x00000080u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                6, this_._internal_shape_classification_foreground(), target);
          }

          // optional bool shape_classification_flat = 7;
          if (cached_has_bits & 0x00000100u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                7, this_._internal_shape_classification_flat(), target);
          }

          // optional bool shape_classification_upright = 8;
          if (cached_has_bits & 0x00000200u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                8, this_._internal_shape_classification_upright(), target);
          }

          // optional bool shape_classification_ground = 9;
          if (cached_has_bits & 0x00000400u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                9, this_._internal_shape_classification_ground(), target);
          }

          // optional bool shape_classification_sky = 10;
          if (cached_has_bits & 0x00000800u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                10, this_._internal_shape_classification_sky(), target);
          }

          // optional bool shape_classification_vegetation = 11;
          if (cached_has_bits & 0x00001000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                11, this_._internal_shape_classification_vegetation(), target);
          }

          // optional bool shape_classification_road = 12;
          if (cached_has_bits & 0x00002000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                12, this_._internal_shape_classification_road(), target);
          }

          // optional bool shape_classification_non_driving_lane = 13;
          if (cached_has_bits & 0x00004000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                13, this_._internal_shape_classification_non_driving_lane(), target);
          }

          // optional bool shape_classification_non_road = 14;
          if (cached_has_bits & 0x00008000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                14, this_._internal_shape_classification_non_road(), target);
          }

          // optional bool shape_classification_stationary_object = 15;
          if (cached_has_bits & 0x00010000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                15, this_._internal_shape_classification_stationary_object(), target);
          }

          // optional bool shape_classification_moving_object = 16;
          if (cached_has_bits & 0x00020000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                16, this_._internal_shape_classification_moving_object(), target);
          }

          // optional bool shape_classification_landmark = 17;
          if (cached_has_bits & 0x00040000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                17, this_._internal_shape_classification_landmark(), target);
          }

          // optional bool shape_classification_traffic_sign = 18;
          if (cached_has_bits & 0x00080000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                18, this_._internal_shape_classification_traffic_sign(), target);
          }

          // optional bool shape_classification_traffic_light = 19;
          if (cached_has_bits & 0x00100000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                19, this_._internal_shape_classification_traffic_light(), target);
          }

          // optional bool shape_classification_road_marking = 20;
          if (cached_has_bits & 0x00200000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                20, this_._internal_shape_classification_road_marking(), target);
          }

          // optional bool shape_classification_vehicle = 21;
          if (cached_has_bits & 0x00400000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                21, this_._internal_shape_classification_vehicle(), target);
          }

          // optional bool shape_classification_pedestrian = 22;
          if (cached_has_bits & 0x00800000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                22, this_._internal_shape_classification_pedestrian(), target);
          }

          // optional bool shape_classification_animal = 23;
          if (cached_has_bits & 0x01000000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                23, this_._internal_shape_classification_animal(), target);
          }

          // optional bool shape_classification_pedestrian_front = 24;
          if (cached_has_bits & 0x02000000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                24, this_._internal_shape_classification_pedestrian_front(), target);
          }

          // optional bool shape_classification_pedestrian_side = 25;
          if (cached_has_bits & 0x04000000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                25, this_._internal_shape_classification_pedestrian_side(), target);
          }

          // optional bool shape_classification_pedestrian_rear = 26;
          if (cached_has_bits & 0x08000000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                26, this_._internal_shape_classification_pedestrian_rear(), target);
          }

          // optional double shape_classification_probability = 27;
          if (cached_has_bits & 0x20000000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                27, this_._internal_shape_classification_probability(), target);
          }

          // optional .osi3.CameraDetection.Color color = 28;
          if (cached_has_bits & 0x10000000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                28, this_._internal_color(), target);
          }

          // optional double color_probability = 29;
          if (cached_has_bits & 0x40000000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                29, this_._internal_color_probability(), target);
          }

          // optional .osi3.Identifier ambiguity_id = 30;
          if (cached_has_bits & 0x00000004u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                30, *this_._impl_.ambiguity_id_, this_._impl_.ambiguity_id_->GetCachedSize(), target,
                stream);
          }

          // optional uint32 first_point_index = 31;
          if (cached_has_bits & 0x80000000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                31, this_._internal_first_point_index(), target);
          }

          cached_has_bits = this_._impl_._has_bits_[1];
          // optional uint32 number_of_points = 32;
          if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                32, this_._internal_number_of_points(), target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.ColorDescription color_description = 33;
          if (cached_has_bits & 0x00000008u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                33, *this_._impl_.color_description_, this_._impl_.color_description_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.CameraDetection)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t CameraDetection::ByteSizeLong(const MessageLite& base) {
          const CameraDetection& this_ = static_cast<const CameraDetection&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t CameraDetection::ByteSizeLong() const {
          const CameraDetection& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.CameraDetection)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x000000ffu) {
            // optional .osi3.Identifier object_id = 2;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.object_id_);
            }
            // optional .osi3.Timestamp time_difference = 3;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.time_difference_);
            }
            // optional .osi3.Identifier ambiguity_id = 30;
            if (cached_has_bits & 0x00000004u) {
              total_size += 2 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.ambiguity_id_);
            }
            // optional .osi3.ColorDescription color_description = 33;
            if (cached_has_bits & 0x00000008u) {
              total_size += 2 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.color_description_);
            }
            // optional double existence_probability = 1;
            if (cached_has_bits & 0x00000010u) {
              total_size += 9;
            }
            // optional .osi3.CameraDetection.ImageShapeType image_shape_type = 4;
            if (cached_has_bits & 0x00000020u) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_image_shape_type());
            }
            // optional bool shape_classification_background = 5;
            if (cached_has_bits & 0x00000040u) {
              total_size += 2;
            }
            // optional bool shape_classification_foreground = 6;
            if (cached_has_bits & 0x00000080u) {
              total_size += 2;
            }
          }
          if (cached_has_bits & 0x0000ff00u) {
            // optional bool shape_classification_flat = 7;
            if (cached_has_bits & 0x00000100u) {
              total_size += 2;
            }
            // optional bool shape_classification_upright = 8;
            if (cached_has_bits & 0x00000200u) {
              total_size += 2;
            }
            // optional bool shape_classification_ground = 9;
            if (cached_has_bits & 0x00000400u) {
              total_size += 2;
            }
            // optional bool shape_classification_sky = 10;
            if (cached_has_bits & 0x00000800u) {
              total_size += 2;
            }
            // optional bool shape_classification_vegetation = 11;
            if (cached_has_bits & 0x00001000u) {
              total_size += 2;
            }
            // optional bool shape_classification_road = 12;
            if (cached_has_bits & 0x00002000u) {
              total_size += 2;
            }
            // optional bool shape_classification_non_driving_lane = 13;
            if (cached_has_bits & 0x00004000u) {
              total_size += 2;
            }
            // optional bool shape_classification_non_road = 14;
            if (cached_has_bits & 0x00008000u) {
              total_size += 2;
            }
          }
          if (cached_has_bits & 0x00ff0000u) {
            // optional bool shape_classification_stationary_object = 15;
            if (cached_has_bits & 0x00010000u) {
              total_size += 2;
            }
            // optional bool shape_classification_moving_object = 16;
            if (cached_has_bits & 0x00020000u) {
              total_size += 3;
            }
            // optional bool shape_classification_landmark = 17;
            if (cached_has_bits & 0x00040000u) {
              total_size += 3;
            }
            // optional bool shape_classification_traffic_sign = 18;
            if (cached_has_bits & 0x00080000u) {
              total_size += 3;
            }
            // optional bool shape_classification_traffic_light = 19;
            if (cached_has_bits & 0x00100000u) {
              total_size += 3;
            }
            // optional bool shape_classification_road_marking = 20;
            if (cached_has_bits & 0x00200000u) {
              total_size += 3;
            }
            // optional bool shape_classification_vehicle = 21;
            if (cached_has_bits & 0x00400000u) {
              total_size += 3;
            }
            // optional bool shape_classification_pedestrian = 22;
            if (cached_has_bits & 0x00800000u) {
              total_size += 3;
            }
          }
          if (cached_has_bits & 0xff000000u) {
            // optional bool shape_classification_animal = 23;
            if (cached_has_bits & 0x01000000u) {
              total_size += 3;
            }
            // optional bool shape_classification_pedestrian_front = 24;
            if (cached_has_bits & 0x02000000u) {
              total_size += 3;
            }
            // optional bool shape_classification_pedestrian_side = 25;
            if (cached_has_bits & 0x04000000u) {
              total_size += 3;
            }
            // optional bool shape_classification_pedestrian_rear = 26;
            if (cached_has_bits & 0x08000000u) {
              total_size += 3;
            }
            // optional .osi3.CameraDetection.Color color = 28;
            if (cached_has_bits & 0x10000000u) {
              total_size += 2 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_color());
            }
            // optional double shape_classification_probability = 27;
            if (cached_has_bits & 0x20000000u) {
              total_size += 10;
            }
            // optional double color_probability = 29;
            if (cached_has_bits & 0x40000000u) {
              total_size += 10;
            }
            // optional uint32 first_point_index = 31;
            if (cached_has_bits & 0x80000000u) {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_first_point_index());
            }
          }
           {
            // optional uint32 number_of_points = 32;
            cached_has_bits = this_._impl_._has_bits_[1];
            if (cached_has_bits & 0x00000001u) {
              total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                              this_._internal_number_of_points());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void CameraDetection::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<CameraDetection*>(&to_msg);
  auto& from = static_cast<const CameraDetection&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.CameraDetection)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.object_id_ != nullptr);
      if (_this->_impl_.object_id_ == nullptr) {
        _this->_impl_.object_id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.object_id_);
      } else {
        _this->_impl_.object_id_->MergeFrom(*from._impl_.object_id_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.time_difference_ != nullptr);
      if (_this->_impl_.time_difference_ == nullptr) {
        _this->_impl_.time_difference_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Timestamp>(arena, *from._impl_.time_difference_);
      } else {
        _this->_impl_.time_difference_->MergeFrom(*from._impl_.time_difference_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.ambiguity_id_ != nullptr);
      if (_this->_impl_.ambiguity_id_ == nullptr) {
        _this->_impl_.ambiguity_id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.ambiguity_id_);
      } else {
        _this->_impl_.ambiguity_id_->MergeFrom(*from._impl_.ambiguity_id_);
      }
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(from._impl_.color_description_ != nullptr);
      if (_this->_impl_.color_description_ == nullptr) {
        _this->_impl_.color_description_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::ColorDescription>(arena, *from._impl_.color_description_);
      } else {
        _this->_impl_.color_description_->MergeFrom(*from._impl_.color_description_);
      }
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.existence_probability_ = from._impl_.existence_probability_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.image_shape_type_ = from._impl_.image_shape_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.shape_classification_background_ = from._impl_.shape_classification_background_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.shape_classification_foreground_ = from._impl_.shape_classification_foreground_;
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.shape_classification_flat_ = from._impl_.shape_classification_flat_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.shape_classification_upright_ = from._impl_.shape_classification_upright_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.shape_classification_ground_ = from._impl_.shape_classification_ground_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.shape_classification_sky_ = from._impl_.shape_classification_sky_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.shape_classification_vegetation_ = from._impl_.shape_classification_vegetation_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.shape_classification_road_ = from._impl_.shape_classification_road_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.shape_classification_non_driving_lane_ = from._impl_.shape_classification_non_driving_lane_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.shape_classification_non_road_ = from._impl_.shape_classification_non_road_;
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.shape_classification_stationary_object_ = from._impl_.shape_classification_stationary_object_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.shape_classification_moving_object_ = from._impl_.shape_classification_moving_object_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.shape_classification_landmark_ = from._impl_.shape_classification_landmark_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.shape_classification_traffic_sign_ = from._impl_.shape_classification_traffic_sign_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.shape_classification_traffic_light_ = from._impl_.shape_classification_traffic_light_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.shape_classification_road_marking_ = from._impl_.shape_classification_road_marking_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.shape_classification_vehicle_ = from._impl_.shape_classification_vehicle_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.shape_classification_pedestrian_ = from._impl_.shape_classification_pedestrian_;
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.shape_classification_animal_ = from._impl_.shape_classification_animal_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.shape_classification_pedestrian_front_ = from._impl_.shape_classification_pedestrian_front_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.shape_classification_pedestrian_side_ = from._impl_.shape_classification_pedestrian_side_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.shape_classification_pedestrian_rear_ = from._impl_.shape_classification_pedestrian_rear_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.color_ = from._impl_.color_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.shape_classification_probability_ = from._impl_.shape_classification_probability_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.color_probability_ = from._impl_.color_probability_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.first_point_index_ = from._impl_.first_point_index_;
    }
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x00000001u) {
    _this->_impl_.number_of_points_ = from._impl_.number_of_points_;
  }
  _this->_impl_._has_bits_.Or(from._impl_._has_bits_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CameraDetection::CopyFrom(const CameraDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.CameraDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CameraDetection::InternalSwap(CameraDetection* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.number_of_points_)
      + sizeof(CameraDetection::_impl_.number_of_points_)
      - PROTOBUF_FIELD_OFFSET(CameraDetection, _impl_.object_id_)>(
          reinterpret_cast<char*>(&_impl_.object_id_),
          reinterpret_cast<char*>(&other->_impl_.object_id_));
}

::google::protobuf::Metadata CameraDetection::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CameraPoint::_Internal {
 public:
  using HasBits =
      decltype(std::declval<CameraPoint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CameraPoint, _impl_._has_bits_);
};

void CameraPoint::clear_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CameraPoint::clear_point_rmse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.point_rmse_ != nullptr) _impl_.point_rmse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CameraPoint::CameraPoint(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.CameraPoint)
}
inline PROTOBUF_NDEBUG_INLINE CameraPoint::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::CameraPoint& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

CameraPoint::CameraPoint(
    ::google::protobuf::Arena* arena,
    const CameraPoint& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CameraPoint* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.point_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Spherical3d>(
                              arena, *from._impl_.point_)
                        : nullptr;
  _impl_.point_rmse_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Spherical3d>(
                              arena, *from._impl_.point_rmse_)
                        : nullptr;
  _impl_.existence_probability_ = from._impl_.existence_probability_;

  // @@protoc_insertion_point(copy_constructor:osi3.CameraPoint)
}
inline PROTOBUF_NDEBUG_INLINE CameraPoint::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CameraPoint::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, point_),
           0,
           offsetof(Impl_, existence_probability_) -
               offsetof(Impl_, point_) +
               sizeof(Impl_::existence_probability_));
}
CameraPoint::~CameraPoint() {
  // @@protoc_insertion_point(destructor:osi3.CameraPoint)
  SharedDtor(*this);
}
inline void CameraPoint::SharedDtor(MessageLite& self) {
  CameraPoint& this_ = static_cast<CameraPoint&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.point_;
  delete this_._impl_.point_rmse_;
  this_._impl_.~Impl_();
}

inline void* CameraPoint::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) CameraPoint(arena);
}
constexpr auto CameraPoint::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(CameraPoint),
                                            alignof(CameraPoint));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull CameraPoint::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_CameraPoint_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &CameraPoint::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<CameraPoint>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &CameraPoint::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<CameraPoint>(), &CameraPoint::ByteSizeLong,
            &CameraPoint::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(CameraPoint, _impl_._cached_size_),
        false,
    },
    &CameraPoint::kDescriptorMethods,
    &descriptor_table_osi_5ffeaturedata_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* CameraPoint::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 2, 0, 2> CameraPoint::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CameraPoint, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::CameraPoint>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional double existence_probability = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 2, 0, PROTOBUF_FIELD_OFFSET(CameraPoint, _impl_.existence_probability_)}},
    // optional .osi3.Spherical3d point = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(CameraPoint, _impl_.point_)}},
    // optional .osi3.Spherical3d point_rmse = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1, PROTOBUF_FIELD_OFFSET(CameraPoint, _impl_.point_rmse_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional double existence_probability = 1;
    {PROTOBUF_FIELD_OFFSET(CameraPoint, _impl_.existence_probability_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .osi3.Spherical3d point = 2;
    {PROTOBUF_FIELD_OFFSET(CameraPoint, _impl_.point_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.Spherical3d point_rmse = 3;
    {PROTOBUF_FIELD_OFFSET(CameraPoint, _impl_.point_rmse_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Spherical3d>()},
    {::_pbi::TcParser::GetTable<::osi3::Spherical3d>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void CameraPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.CameraPoint)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.point_ != nullptr);
      _impl_.point_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.point_rmse_ != nullptr);
      _impl_.point_rmse_->Clear();
    }
  }
  _impl_.existence_probability_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* CameraPoint::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const CameraPoint& this_ = static_cast<const CameraPoint&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* CameraPoint::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const CameraPoint& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.CameraPoint)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional double existence_probability = 1;
          if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                1, this_._internal_existence_probability(), target);
          }

          // optional .osi3.Spherical3d point = 2;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.point_, this_._impl_.point_->GetCachedSize(), target,
                stream);
          }

          // optional .osi3.Spherical3d point_rmse = 3;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.point_rmse_, this_._impl_.point_rmse_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.CameraPoint)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t CameraPoint::ByteSizeLong(const MessageLite& base) {
          const CameraPoint& this_ = static_cast<const CameraPoint&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t CameraPoint::ByteSizeLong() const {
          const CameraPoint& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.CameraPoint)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000007u) {
            // optional .osi3.Spherical3d point = 2;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.point_);
            }
            // optional .osi3.Spherical3d point_rmse = 3;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.point_rmse_);
            }
            // optional double existence_probability = 1;
            if (cached_has_bits & 0x00000004u) {
              total_size += 9;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void CameraPoint::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<CameraPoint*>(&to_msg);
  auto& from = static_cast<const CameraPoint&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.CameraPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.point_ != nullptr);
      if (_this->_impl_.point_ == nullptr) {
        _this->_impl_.point_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Spherical3d>(arena, *from._impl_.point_);
      } else {
        _this->_impl_.point_->MergeFrom(*from._impl_.point_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.point_rmse_ != nullptr);
      if (_this->_impl_.point_rmse_ == nullptr) {
        _this->_impl_.point_rmse_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Spherical3d>(arena, *from._impl_.point_rmse_);
      } else {
        _this->_impl_.point_rmse_->MergeFrom(*from._impl_.point_rmse_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.existence_probability_ = from._impl_.existence_probability_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CameraPoint::CopyFrom(const CameraPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.CameraPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CameraPoint::InternalSwap(CameraPoint* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CameraPoint, _impl_.existence_probability_)
      + sizeof(CameraPoint::_impl_.existence_probability_)
      - PROTOBUF_FIELD_OFFSET(CameraPoint, _impl_.point_)>(
          reinterpret_cast<char*>(&_impl_.point_),
          reinterpret_cast<char*>(&other->_impl_.point_));
}

::google::protobuf::Metadata CameraPoint::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace osi3
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ PROTOBUF_UNUSED =
        (::_pbi::AddDescriptors(&descriptor_table_osi_5ffeaturedata_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
