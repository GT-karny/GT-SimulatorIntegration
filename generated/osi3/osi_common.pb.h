// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: osi_common.proto
// Protobuf C++ Version: 5.29.5

#ifndef osi_5fcommon_2eproto_2epb_2eh
#define osi_5fcommon_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029005
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_osi_5fcommon_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_osi_5fcommon_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_osi_5fcommon_2eproto;
namespace osi3 {
class BaseMoving;
struct BaseMovingDefaultTypeInternal;
extern BaseMovingDefaultTypeInternal _BaseMoving_default_instance_;
class BaseStationary;
struct BaseStationaryDefaultTypeInternal;
extern BaseStationaryDefaultTypeInternal _BaseStationary_default_instance_;
class ColorCMYK;
struct ColorCMYKDefaultTypeInternal;
extern ColorCMYKDefaultTypeInternal _ColorCMYK_default_instance_;
class ColorDescription;
struct ColorDescriptionDefaultTypeInternal;
extern ColorDescriptionDefaultTypeInternal _ColorDescription_default_instance_;
class ColorGrey;
struct ColorGreyDefaultTypeInternal;
extern ColorGreyDefaultTypeInternal _ColorGrey_default_instance_;
class ColorHSV;
struct ColorHSVDefaultTypeInternal;
extern ColorHSVDefaultTypeInternal _ColorHSV_default_instance_;
class ColorLUV;
struct ColorLUVDefaultTypeInternal;
extern ColorLUVDefaultTypeInternal _ColorLUV_default_instance_;
class ColorRGB;
struct ColorRGBDefaultTypeInternal;
extern ColorRGBDefaultTypeInternal _ColorRGB_default_instance_;
class ColorRGBIR;
struct ColorRGBIRDefaultTypeInternal;
extern ColorRGBIRDefaultTypeInternal _ColorRGBIR_default_instance_;
class Dimension3d;
struct Dimension3dDefaultTypeInternal;
extern Dimension3dDefaultTypeInternal _Dimension3d_default_instance_;
class ExternalReference;
struct ExternalReferenceDefaultTypeInternal;
extern ExternalReferenceDefaultTypeInternal _ExternalReference_default_instance_;
class GeodeticPosition;
struct GeodeticPositionDefaultTypeInternal;
extern GeodeticPositionDefaultTypeInternal _GeodeticPosition_default_instance_;
class Identifier;
struct IdentifierDefaultTypeInternal;
extern IdentifierDefaultTypeInternal _Identifier_default_instance_;
class KeyValuePair;
struct KeyValuePairDefaultTypeInternal;
extern KeyValuePairDefaultTypeInternal _KeyValuePair_default_instance_;
class LogicalLaneAssignment;
struct LogicalLaneAssignmentDefaultTypeInternal;
extern LogicalLaneAssignmentDefaultTypeInternal _LogicalLaneAssignment_default_instance_;
class MountingPosition;
struct MountingPositionDefaultTypeInternal;
extern MountingPositionDefaultTypeInternal _MountingPosition_default_instance_;
class Orientation3d;
struct Orientation3dDefaultTypeInternal;
extern Orientation3dDefaultTypeInternal _Orientation3d_default_instance_;
class Pedalry;
struct PedalryDefaultTypeInternal;
extern PedalryDefaultTypeInternal _Pedalry_default_instance_;
class SpatialSignalStrength;
struct SpatialSignalStrengthDefaultTypeInternal;
extern SpatialSignalStrengthDefaultTypeInternal _SpatialSignalStrength_default_instance_;
class Spherical3d;
struct Spherical3dDefaultTypeInternal;
extern Spherical3dDefaultTypeInternal _Spherical3d_default_instance_;
class StatePoint;
struct StatePointDefaultTypeInternal;
extern StatePointDefaultTypeInternal _StatePoint_default_instance_;
class Timestamp;
struct TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
class Vector2d;
struct Vector2dDefaultTypeInternal;
extern Vector2dDefaultTypeInternal _Vector2d_default_instance_;
class Vector3d;
struct Vector3dDefaultTypeInternal;
extern Vector3dDefaultTypeInternal _Vector3d_default_instance_;
class VehicleSteeringWheel;
struct VehicleSteeringWheelDefaultTypeInternal;
extern VehicleSteeringWheelDefaultTypeInternal _VehicleSteeringWheel_default_instance_;
class WavelengthData;
struct WavelengthDataDefaultTypeInternal;
extern WavelengthDataDefaultTypeInternal _WavelengthData_default_instance_;
}  // namespace osi3
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace osi3 {

// ===================================================================


// -------------------------------------------------------------------

class WavelengthData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.WavelengthData) */ {
 public:
  inline WavelengthData() : WavelengthData(nullptr) {}
  ~WavelengthData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WavelengthData* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WavelengthData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WavelengthData(
      ::google::protobuf::internal::ConstantInitialized);

  inline WavelengthData(const WavelengthData& from) : WavelengthData(nullptr, from) {}
  inline WavelengthData(WavelengthData&& from) noexcept
      : WavelengthData(nullptr, std::move(from)) {}
  inline WavelengthData& operator=(const WavelengthData& from) {
    CopyFrom(from);
    return *this;
  }
  inline WavelengthData& operator=(WavelengthData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WavelengthData& default_instance() {
    return *internal_default_instance();
  }
  static inline const WavelengthData* internal_default_instance() {
    return reinterpret_cast<const WavelengthData*>(
        &_WavelengthData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(WavelengthData& a, WavelengthData& b) { a.Swap(&b); }
  inline void Swap(WavelengthData* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WavelengthData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WavelengthData* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WavelengthData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WavelengthData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WavelengthData& from) { WavelengthData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WavelengthData* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.WavelengthData"; }

 protected:
  explicit WavelengthData(::google::protobuf::Arena* arena);
  WavelengthData(::google::protobuf::Arena* arena, const WavelengthData& from);
  WavelengthData(::google::protobuf::Arena* arena, WavelengthData&& from) noexcept
      : WavelengthData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
    kSamplesNumberFieldNumber = 3,
  };
  // optional double start = 1;
  bool has_start() const;
  void clear_start() ;
  double start() const;
  void set_start(double value);

  private:
  double _internal_start() const;
  void _internal_set_start(double value);

  public:
  // optional double end = 2;
  bool has_end() const;
  void clear_end() ;
  double end() const;
  void set_end(double value);

  private:
  double _internal_end() const;
  void _internal_set_end(double value);

  public:
  // optional double samples_number = 3;
  bool has_samples_number() const;
  void clear_samples_number() ;
  double samples_number() const;
  void set_samples_number(double value);

  private:
  double _internal_samples_number() const;
  void _internal_set_samples_number(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.WavelengthData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WavelengthData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double start_;
    double end_;
    double samples_number_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class VehicleSteeringWheel final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.VehicleSteeringWheel) */ {
 public:
  inline VehicleSteeringWheel() : VehicleSteeringWheel(nullptr) {}
  ~VehicleSteeringWheel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VehicleSteeringWheel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VehicleSteeringWheel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VehicleSteeringWheel(
      ::google::protobuf::internal::ConstantInitialized);

  inline VehicleSteeringWheel(const VehicleSteeringWheel& from) : VehicleSteeringWheel(nullptr, from) {}
  inline VehicleSteeringWheel(VehicleSteeringWheel&& from) noexcept
      : VehicleSteeringWheel(nullptr, std::move(from)) {}
  inline VehicleSteeringWheel& operator=(const VehicleSteeringWheel& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleSteeringWheel& operator=(VehicleSteeringWheel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleSteeringWheel& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleSteeringWheel* internal_default_instance() {
    return reinterpret_cast<const VehicleSteeringWheel*>(
        &_VehicleSteeringWheel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(VehicleSteeringWheel& a, VehicleSteeringWheel& b) { a.Swap(&b); }
  inline void Swap(VehicleSteeringWheel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleSteeringWheel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleSteeringWheel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VehicleSteeringWheel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VehicleSteeringWheel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VehicleSteeringWheel& from) { VehicleSteeringWheel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VehicleSteeringWheel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.VehicleSteeringWheel"; }

 protected:
  explicit VehicleSteeringWheel(::google::protobuf::Arena* arena);
  VehicleSteeringWheel(::google::protobuf::Arena* arena, const VehicleSteeringWheel& from);
  VehicleSteeringWheel(::google::protobuf::Arena* arena, VehicleSteeringWheel&& from) noexcept
      : VehicleSteeringWheel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAngleFieldNumber = 1,
    kAngularSpeedFieldNumber = 2,
    kTorqueFieldNumber = 3,
  };
  // optional double angle = 1;
  bool has_angle() const;
  void clear_angle() ;
  double angle() const;
  void set_angle(double value);

  private:
  double _internal_angle() const;
  void _internal_set_angle(double value);

  public:
  // optional double angular_speed = 2;
  bool has_angular_speed() const;
  void clear_angular_speed() ;
  double angular_speed() const;
  void set_angular_speed(double value);

  private:
  double _internal_angular_speed() const;
  void _internal_set_angular_speed(double value);

  public:
  // optional double torque = 3;
  bool has_torque() const;
  void clear_torque() ;
  double torque() const;
  void set_torque(double value);

  private:
  double _internal_torque() const;
  void _internal_set_torque(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.VehicleSteeringWheel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VehicleSteeringWheel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double angle_;
    double angular_speed_;
    double torque_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class Vector3d final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.Vector3d) */ {
 public:
  inline Vector3d() : Vector3d(nullptr) {}
  ~Vector3d() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Vector3d* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Vector3d));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vector3d(
      ::google::protobuf::internal::ConstantInitialized);

  inline Vector3d(const Vector3d& from) : Vector3d(nullptr, from) {}
  inline Vector3d(Vector3d&& from) noexcept
      : Vector3d(nullptr, std::move(from)) {}
  inline Vector3d& operator=(const Vector3d& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3d& operator=(Vector3d&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3d& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3d* internal_default_instance() {
    return reinterpret_cast<const Vector3d*>(
        &_Vector3d_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Vector3d& a, Vector3d& b) { a.Swap(&b); }
  inline void Swap(Vector3d* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3d* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3d* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Vector3d>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector3d& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vector3d& from) { Vector3d::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Vector3d* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.Vector3d"; }

 protected:
  explicit Vector3d(::google::protobuf::Arena* arena);
  Vector3d(::google::protobuf::Arena* arena, const Vector3d& from);
  Vector3d(::google::protobuf::Arena* arena, Vector3d&& from) noexcept
      : Vector3d(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional double x = 1;
  bool has_x() const;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // optional double y = 2;
  bool has_y() const;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // optional double z = 3;
  bool has_z() const;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.Vector3d)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Vector3d& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double x_;
    double y_;
    double z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class Vector2d final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.Vector2d) */ {
 public:
  inline Vector2d() : Vector2d(nullptr) {}
  ~Vector2d() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Vector2d* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Vector2d));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vector2d(
      ::google::protobuf::internal::ConstantInitialized);

  inline Vector2d(const Vector2d& from) : Vector2d(nullptr, from) {}
  inline Vector2d(Vector2d&& from) noexcept
      : Vector2d(nullptr, std::move(from)) {}
  inline Vector2d& operator=(const Vector2d& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector2d& operator=(Vector2d&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector2d& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector2d* internal_default_instance() {
    return reinterpret_cast<const Vector2d*>(
        &_Vector2d_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Vector2d& a, Vector2d& b) { a.Swap(&b); }
  inline void Swap(Vector2d* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector2d* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector2d* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Vector2d>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector2d& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vector2d& from) { Vector2d::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Vector2d* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.Vector2d"; }

 protected:
  explicit Vector2d(::google::protobuf::Arena* arena);
  Vector2d(::google::protobuf::Arena* arena, const Vector2d& from);
  Vector2d(::google::protobuf::Arena* arena, Vector2d&& from) noexcept
      : Vector2d(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional double x = 1;
  bool has_x() const;
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // optional double y = 2;
  bool has_y() const;
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.Vector2d)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Vector2d& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double x_;
    double y_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class Timestamp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.Timestamp) */ {
 public:
  inline Timestamp() : Timestamp(nullptr) {}
  ~Timestamp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Timestamp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Timestamp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Timestamp(
      ::google::protobuf::internal::ConstantInitialized);

  inline Timestamp(const Timestamp& from) : Timestamp(nullptr, from) {}
  inline Timestamp(Timestamp&& from) noexcept
      : Timestamp(nullptr, std::move(from)) {}
  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Timestamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
        &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Timestamp& a, Timestamp& b) { a.Swap(&b); }
  inline void Swap(Timestamp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Timestamp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Timestamp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Timestamp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Timestamp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Timestamp& from) { Timestamp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Timestamp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.Timestamp"; }

 protected:
  explicit Timestamp(::google::protobuf::Arena* arena);
  Timestamp(::google::protobuf::Arena* arena, const Timestamp& from);
  Timestamp(::google::protobuf::Arena* arena, Timestamp&& from) noexcept
      : Timestamp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSecondsFieldNumber = 1,
    kNanosFieldNumber = 2,
  };
  // optional int64 seconds = 1;
  bool has_seconds() const;
  void clear_seconds() ;
  ::int64_t seconds() const;
  void set_seconds(::int64_t value);

  private:
  ::int64_t _internal_seconds() const;
  void _internal_set_seconds(::int64_t value);

  public:
  // optional uint32 nanos = 2;
  bool has_nanos() const;
  void clear_nanos() ;
  ::uint32_t nanos() const;
  void set_nanos(::uint32_t value);

  private:
  ::uint32_t _internal_nanos() const;
  void _internal_set_nanos(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.Timestamp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Timestamp& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t seconds_;
    ::uint32_t nanos_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class Spherical3d final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.Spherical3d) */ {
 public:
  inline Spherical3d() : Spherical3d(nullptr) {}
  ~Spherical3d() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Spherical3d* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Spherical3d));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Spherical3d(
      ::google::protobuf::internal::ConstantInitialized);

  inline Spherical3d(const Spherical3d& from) : Spherical3d(nullptr, from) {}
  inline Spherical3d(Spherical3d&& from) noexcept
      : Spherical3d(nullptr, std::move(from)) {}
  inline Spherical3d& operator=(const Spherical3d& from) {
    CopyFrom(from);
    return *this;
  }
  inline Spherical3d& operator=(Spherical3d&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Spherical3d& default_instance() {
    return *internal_default_instance();
  }
  static inline const Spherical3d* internal_default_instance() {
    return reinterpret_cast<const Spherical3d*>(
        &_Spherical3d_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(Spherical3d& a, Spherical3d& b) { a.Swap(&b); }
  inline void Swap(Spherical3d* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Spherical3d* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Spherical3d* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Spherical3d>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Spherical3d& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Spherical3d& from) { Spherical3d::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Spherical3d* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.Spherical3d"; }

 protected:
  explicit Spherical3d(::google::protobuf::Arena* arena);
  Spherical3d(::google::protobuf::Arena* arena, const Spherical3d& from);
  Spherical3d(::google::protobuf::Arena* arena, Spherical3d&& from) noexcept
      : Spherical3d(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDistanceFieldNumber = 1,
    kAzimuthFieldNumber = 2,
    kElevationFieldNumber = 3,
  };
  // optional double distance = 1;
  bool has_distance() const;
  void clear_distance() ;
  double distance() const;
  void set_distance(double value);

  private:
  double _internal_distance() const;
  void _internal_set_distance(double value);

  public:
  // optional double azimuth = 2;
  bool has_azimuth() const;
  void clear_azimuth() ;
  double azimuth() const;
  void set_azimuth(double value);

  private:
  double _internal_azimuth() const;
  void _internal_set_azimuth(double value);

  public:
  // optional double elevation = 3;
  bool has_elevation() const;
  void clear_elevation() ;
  double elevation() const;
  void set_elevation(double value);

  private:
  double _internal_elevation() const;
  void _internal_set_elevation(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.Spherical3d)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Spherical3d& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double distance_;
    double azimuth_;
    double elevation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SpatialSignalStrength final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.SpatialSignalStrength) */ {
 public:
  inline SpatialSignalStrength() : SpatialSignalStrength(nullptr) {}
  ~SpatialSignalStrength() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SpatialSignalStrength* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SpatialSignalStrength));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SpatialSignalStrength(
      ::google::protobuf::internal::ConstantInitialized);

  inline SpatialSignalStrength(const SpatialSignalStrength& from) : SpatialSignalStrength(nullptr, from) {}
  inline SpatialSignalStrength(SpatialSignalStrength&& from) noexcept
      : SpatialSignalStrength(nullptr, std::move(from)) {}
  inline SpatialSignalStrength& operator=(const SpatialSignalStrength& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpatialSignalStrength& operator=(SpatialSignalStrength&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpatialSignalStrength& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpatialSignalStrength* internal_default_instance() {
    return reinterpret_cast<const SpatialSignalStrength*>(
        &_SpatialSignalStrength_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(SpatialSignalStrength& a, SpatialSignalStrength& b) { a.Swap(&b); }
  inline void Swap(SpatialSignalStrength* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpatialSignalStrength* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpatialSignalStrength* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SpatialSignalStrength>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SpatialSignalStrength& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SpatialSignalStrength& from) { SpatialSignalStrength::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SpatialSignalStrength* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.SpatialSignalStrength"; }

 protected:
  explicit SpatialSignalStrength(::google::protobuf::Arena* arena);
  SpatialSignalStrength(::google::protobuf::Arena* arena, const SpatialSignalStrength& from);
  SpatialSignalStrength(::google::protobuf::Arena* arena, SpatialSignalStrength&& from) noexcept
      : SpatialSignalStrength(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHorizontalAngleFieldNumber = 1,
    kVerticalAngleFieldNumber = 2,
    kSignalStrengthFieldNumber = 3,
  };
  // optional double horizontal_angle = 1;
  bool has_horizontal_angle() const;
  void clear_horizontal_angle() ;
  double horizontal_angle() const;
  void set_horizontal_angle(double value);

  private:
  double _internal_horizontal_angle() const;
  void _internal_set_horizontal_angle(double value);

  public:
  // optional double vertical_angle = 2;
  bool has_vertical_angle() const;
  void clear_vertical_angle() ;
  double vertical_angle() const;
  void set_vertical_angle(double value);

  private:
  double _internal_vertical_angle() const;
  void _internal_set_vertical_angle(double value);

  public:
  // optional double signal_strength = 3;
  bool has_signal_strength() const;
  void clear_signal_strength() ;
  double signal_strength() const;
  void set_signal_strength(double value);

  private:
  double _internal_signal_strength() const;
  void _internal_set_signal_strength(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.SpatialSignalStrength)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SpatialSignalStrength& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double horizontal_angle_;
    double vertical_angle_;
    double signal_strength_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class Pedalry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.Pedalry) */ {
 public:
  inline Pedalry() : Pedalry(nullptr) {}
  ~Pedalry() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Pedalry* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Pedalry));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Pedalry(
      ::google::protobuf::internal::ConstantInitialized);

  inline Pedalry(const Pedalry& from) : Pedalry(nullptr, from) {}
  inline Pedalry(Pedalry&& from) noexcept
      : Pedalry(nullptr, std::move(from)) {}
  inline Pedalry& operator=(const Pedalry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pedalry& operator=(Pedalry&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pedalry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pedalry* internal_default_instance() {
    return reinterpret_cast<const Pedalry*>(
        &_Pedalry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(Pedalry& a, Pedalry& b) { a.Swap(&b); }
  inline void Swap(Pedalry* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pedalry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pedalry* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Pedalry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Pedalry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Pedalry& from) { Pedalry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Pedalry* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.Pedalry"; }

 protected:
  explicit Pedalry(::google::protobuf::Arena* arena);
  Pedalry(::google::protobuf::Arena* arena, const Pedalry& from);
  Pedalry(::google::protobuf::Arena* arena, Pedalry&& from) noexcept
      : Pedalry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPedalPositionAccelerationFieldNumber = 1,
    kPedalPositionBrakeFieldNumber = 2,
    kPedalPositionClutchFieldNumber = 3,
  };
  // optional double pedal_position_acceleration = 1;
  bool has_pedal_position_acceleration() const;
  void clear_pedal_position_acceleration() ;
  double pedal_position_acceleration() const;
  void set_pedal_position_acceleration(double value);

  private:
  double _internal_pedal_position_acceleration() const;
  void _internal_set_pedal_position_acceleration(double value);

  public:
  // optional double pedal_position_brake = 2;
  bool has_pedal_position_brake() const;
  void clear_pedal_position_brake() ;
  double pedal_position_brake() const;
  void set_pedal_position_brake(double value);

  private:
  double _internal_pedal_position_brake() const;
  void _internal_set_pedal_position_brake(double value);

  public:
  // optional double pedal_position_clutch = 3;
  bool has_pedal_position_clutch() const;
  void clear_pedal_position_clutch() ;
  double pedal_position_clutch() const;
  void set_pedal_position_clutch(double value);

  private:
  double _internal_pedal_position_clutch() const;
  void _internal_set_pedal_position_clutch(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.Pedalry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Pedalry& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double pedal_position_acceleration_;
    double pedal_position_brake_;
    double pedal_position_clutch_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class Orientation3d final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.Orientation3d) */ {
 public:
  inline Orientation3d() : Orientation3d(nullptr) {}
  ~Orientation3d() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Orientation3d* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Orientation3d));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Orientation3d(
      ::google::protobuf::internal::ConstantInitialized);

  inline Orientation3d(const Orientation3d& from) : Orientation3d(nullptr, from) {}
  inline Orientation3d(Orientation3d&& from) noexcept
      : Orientation3d(nullptr, std::move(from)) {}
  inline Orientation3d& operator=(const Orientation3d& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation3d& operator=(Orientation3d&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Orientation3d& default_instance() {
    return *internal_default_instance();
  }
  static inline const Orientation3d* internal_default_instance() {
    return reinterpret_cast<const Orientation3d*>(
        &_Orientation3d_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Orientation3d& a, Orientation3d& b) { a.Swap(&b); }
  inline void Swap(Orientation3d* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Orientation3d* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Orientation3d* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Orientation3d>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Orientation3d& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Orientation3d& from) { Orientation3d::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Orientation3d* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.Orientation3d"; }

 protected:
  explicit Orientation3d(::google::protobuf::Arena* arena);
  Orientation3d(::google::protobuf::Arena* arena, const Orientation3d& from);
  Orientation3d(::google::protobuf::Arena* arena, Orientation3d&& from) noexcept
      : Orientation3d(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRollFieldNumber = 1,
    kPitchFieldNumber = 2,
    kYawFieldNumber = 3,
  };
  // optional double roll = 1;
  bool has_roll() const;
  void clear_roll() ;
  double roll() const;
  void set_roll(double value);

  private:
  double _internal_roll() const;
  void _internal_set_roll(double value);

  public:
  // optional double pitch = 2;
  bool has_pitch() const;
  void clear_pitch() ;
  double pitch() const;
  void set_pitch(double value);

  private:
  double _internal_pitch() const;
  void _internal_set_pitch(double value);

  public:
  // optional double yaw = 3;
  bool has_yaw() const;
  void clear_yaw() ;
  double yaw() const;
  void set_yaw(double value);

  private:
  double _internal_yaw() const;
  void _internal_set_yaw(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.Orientation3d)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Orientation3d& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double roll_;
    double pitch_;
    double yaw_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class KeyValuePair final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.KeyValuePair) */ {
 public:
  inline KeyValuePair() : KeyValuePair(nullptr) {}
  ~KeyValuePair() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(KeyValuePair* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(KeyValuePair));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeyValuePair(
      ::google::protobuf::internal::ConstantInitialized);

  inline KeyValuePair(const KeyValuePair& from) : KeyValuePair(nullptr, from) {}
  inline KeyValuePair(KeyValuePair&& from) noexcept
      : KeyValuePair(nullptr, std::move(from)) {}
  inline KeyValuePair& operator=(const KeyValuePair& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValuePair& operator=(KeyValuePair&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyValuePair& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyValuePair* internal_default_instance() {
    return reinterpret_cast<const KeyValuePair*>(
        &_KeyValuePair_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(KeyValuePair& a, KeyValuePair& b) { a.Swap(&b); }
  inline void Swap(KeyValuePair* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValuePair* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyValuePair* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<KeyValuePair>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeyValuePair& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeyValuePair& from) { KeyValuePair::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(KeyValuePair* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.KeyValuePair"; }

 protected:
  explicit KeyValuePair(::google::protobuf::Arena* arena);
  KeyValuePair(::google::protobuf::Arena* arena, const KeyValuePair& from);
  KeyValuePair(::google::protobuf::Arena* arena, KeyValuePair&& from) noexcept
      : KeyValuePair(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional string key = 1;
  bool has_key() const;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // optional string value = 2;
  bool has_value() const;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:osi3.KeyValuePair)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      34, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KeyValuePair& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class Identifier final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.Identifier) */ {
 public:
  inline Identifier() : Identifier(nullptr) {}
  ~Identifier() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Identifier* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Identifier));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Identifier(
      ::google::protobuf::internal::ConstantInitialized);

  inline Identifier(const Identifier& from) : Identifier(nullptr, from) {}
  inline Identifier(Identifier&& from) noexcept
      : Identifier(nullptr, std::move(from)) {}
  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline Identifier& operator=(Identifier&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Identifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const Identifier* internal_default_instance() {
    return reinterpret_cast<const Identifier*>(
        &_Identifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Identifier& a, Identifier& b) { a.Swap(&b); }
  inline void Swap(Identifier* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Identifier* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Identifier* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Identifier>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Identifier& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Identifier& from) { Identifier::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Identifier* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.Identifier"; }

 protected:
  explicit Identifier(::google::protobuf::Arena* arena);
  Identifier(::google::protobuf::Arena* arena, const Identifier& from);
  Identifier(::google::protobuf::Arena* arena, Identifier&& from) noexcept
      : Identifier(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // optional uint64 value = 1;
  bool has_value() const;
  void clear_value() ;
  ::uint64_t value() const;
  void set_value(::uint64_t value);

  private:
  ::uint64_t _internal_value() const;
  void _internal_set_value(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.Identifier)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Identifier& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class GeodeticPosition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.GeodeticPosition) */ {
 public:
  inline GeodeticPosition() : GeodeticPosition(nullptr) {}
  ~GeodeticPosition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GeodeticPosition* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GeodeticPosition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GeodeticPosition(
      ::google::protobuf::internal::ConstantInitialized);

  inline GeodeticPosition(const GeodeticPosition& from) : GeodeticPosition(nullptr, from) {}
  inline GeodeticPosition(GeodeticPosition&& from) noexcept
      : GeodeticPosition(nullptr, std::move(from)) {}
  inline GeodeticPosition& operator=(const GeodeticPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeodeticPosition& operator=(GeodeticPosition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeodeticPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeodeticPosition* internal_default_instance() {
    return reinterpret_cast<const GeodeticPosition*>(
        &_GeodeticPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(GeodeticPosition& a, GeodeticPosition& b) { a.Swap(&b); }
  inline void Swap(GeodeticPosition* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeodeticPosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeodeticPosition* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GeodeticPosition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GeodeticPosition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GeodeticPosition& from) { GeodeticPosition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GeodeticPosition* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.GeodeticPosition"; }

 protected:
  explicit GeodeticPosition(::google::protobuf::Arena* arena);
  GeodeticPosition(::google::protobuf::Arena* arena, const GeodeticPosition& from);
  GeodeticPosition(::google::protobuf::Arena* arena, GeodeticPosition&& from) noexcept
      : GeodeticPosition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLongitudeFieldNumber = 1,
    kLatitudeFieldNumber = 2,
    kAltitudeFieldNumber = 3,
  };
  // optional double longitude = 1;
  bool has_longitude() const;
  void clear_longitude() ;
  double longitude() const;
  void set_longitude(double value);

  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);

  public:
  // optional double latitude = 2;
  bool has_latitude() const;
  void clear_latitude() ;
  double latitude() const;
  void set_latitude(double value);

  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);

  public:
  // optional double altitude = 3;
  bool has_altitude() const;
  void clear_altitude() ;
  double altitude() const;
  void set_altitude(double value);

  private:
  double _internal_altitude() const;
  void _internal_set_altitude(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.GeodeticPosition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GeodeticPosition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double longitude_;
    double latitude_;
    double altitude_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class ExternalReference final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.ExternalReference) */ {
 public:
  inline ExternalReference() : ExternalReference(nullptr) {}
  ~ExternalReference() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExternalReference* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExternalReference));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExternalReference(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExternalReference(const ExternalReference& from) : ExternalReference(nullptr, from) {}
  inline ExternalReference(ExternalReference&& from) noexcept
      : ExternalReference(nullptr, std::move(from)) {}
  inline ExternalReference& operator=(const ExternalReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalReference& operator=(ExternalReference&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExternalReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalReference* internal_default_instance() {
    return reinterpret_cast<const ExternalReference*>(
        &_ExternalReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ExternalReference& a, ExternalReference& b) { a.Swap(&b); }
  inline void Swap(ExternalReference* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalReference* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExternalReference* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExternalReference>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExternalReference& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExternalReference& from) { ExternalReference::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExternalReference* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.ExternalReference"; }

 protected:
  explicit ExternalReference(::google::protobuf::Arena* arena);
  ExternalReference(::google::protobuf::Arena* arena, const ExternalReference& from);
  ExternalReference(::google::protobuf::Arena* arena, ExternalReference&& from) noexcept
      : ExternalReference(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdentifierFieldNumber = 3,
    kReferenceFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // repeated string identifier = 3;
  int identifier_size() const;
  private:
  int _internal_identifier_size() const;

  public:
  void clear_identifier() ;
  const std::string& identifier(int index) const;
  std::string* mutable_identifier(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_identifier(int index, Arg_&& value, Args_... args);
  std::string* add_identifier();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_identifier(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& identifier() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_identifier();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_identifier() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_identifier();

  public:
  // optional string reference = 1;
  bool has_reference() const;
  void clear_reference() ;
  const std::string& reference() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reference(Arg_&& arg, Args_... args);
  std::string* mutable_reference();
  PROTOBUF_NODISCARD std::string* release_reference();
  void set_allocated_reference(std::string* value);

  private:
  const std::string& _internal_reference() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reference(
      const std::string& value);
  std::string* _internal_mutable_reference();

  public:
  // optional string type = 2;
  bool has_type() const;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // @@protoc_insertion_point(class_scope:osi3.ExternalReference)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      54, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExternalReference& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> identifier_;
    ::google::protobuf::internal::ArenaStringPtr reference_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class Dimension3d final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.Dimension3d) */ {
 public:
  inline Dimension3d() : Dimension3d(nullptr) {}
  ~Dimension3d() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Dimension3d* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Dimension3d));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Dimension3d(
      ::google::protobuf::internal::ConstantInitialized);

  inline Dimension3d(const Dimension3d& from) : Dimension3d(nullptr, from) {}
  inline Dimension3d(Dimension3d&& from) noexcept
      : Dimension3d(nullptr, std::move(from)) {}
  inline Dimension3d& operator=(const Dimension3d& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dimension3d& operator=(Dimension3d&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dimension3d& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dimension3d* internal_default_instance() {
    return reinterpret_cast<const Dimension3d*>(
        &_Dimension3d_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Dimension3d& a, Dimension3d& b) { a.Swap(&b); }
  inline void Swap(Dimension3d* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dimension3d* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dimension3d* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Dimension3d>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Dimension3d& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Dimension3d& from) { Dimension3d::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Dimension3d* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.Dimension3d"; }

 protected:
  explicit Dimension3d(::google::protobuf::Arena* arena);
  Dimension3d(::google::protobuf::Arena* arena, const Dimension3d& from);
  Dimension3d(::google::protobuf::Arena* arena, Dimension3d&& from) noexcept
      : Dimension3d(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLengthFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // optional double length = 1;
  bool has_length() const;
  void clear_length() ;
  double length() const;
  void set_length(double value);

  private:
  double _internal_length() const;
  void _internal_set_length(double value);

  public:
  // optional double width = 2;
  bool has_width() const;
  void clear_width() ;
  double width() const;
  void set_width(double value);

  private:
  double _internal_width() const;
  void _internal_set_width(double value);

  public:
  // optional double height = 3;
  bool has_height() const;
  void clear_height() ;
  double height() const;
  void set_height(double value);

  private:
  double _internal_height() const;
  void _internal_set_height(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.Dimension3d)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Dimension3d& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double length_;
    double width_;
    double height_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class ColorRGBIR final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.ColorRGBIR) */ {
 public:
  inline ColorRGBIR() : ColorRGBIR(nullptr) {}
  ~ColorRGBIR() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ColorRGBIR* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ColorRGBIR));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ColorRGBIR(
      ::google::protobuf::internal::ConstantInitialized);

  inline ColorRGBIR(const ColorRGBIR& from) : ColorRGBIR(nullptr, from) {}
  inline ColorRGBIR(ColorRGBIR&& from) noexcept
      : ColorRGBIR(nullptr, std::move(from)) {}
  inline ColorRGBIR& operator=(const ColorRGBIR& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColorRGBIR& operator=(ColorRGBIR&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColorRGBIR& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColorRGBIR* internal_default_instance() {
    return reinterpret_cast<const ColorRGBIR*>(
        &_ColorRGBIR_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(ColorRGBIR& a, ColorRGBIR& b) { a.Swap(&b); }
  inline void Swap(ColorRGBIR* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColorRGBIR* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColorRGBIR* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ColorRGBIR>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ColorRGBIR& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ColorRGBIR& from) { ColorRGBIR::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ColorRGBIR* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.ColorRGBIR"; }

 protected:
  explicit ColorRGBIR(::google::protobuf::Arena* arena);
  ColorRGBIR(::google::protobuf::Arena* arena, const ColorRGBIR& from);
  ColorRGBIR(::google::protobuf::Arena* arena, ColorRGBIR&& from) noexcept
      : ColorRGBIR(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRedFieldNumber = 1,
    kGreenFieldNumber = 2,
    kBlueFieldNumber = 3,
    kInfraredFieldNumber = 4,
  };
  // optional double red = 1;
  bool has_red() const;
  void clear_red() ;
  double red() const;
  void set_red(double value);

  private:
  double _internal_red() const;
  void _internal_set_red(double value);

  public:
  // optional double green = 2;
  bool has_green() const;
  void clear_green() ;
  double green() const;
  void set_green(double value);

  private:
  double _internal_green() const;
  void _internal_set_green(double value);

  public:
  // optional double blue = 3;
  bool has_blue() const;
  void clear_blue() ;
  double blue() const;
  void set_blue(double value);

  private:
  double _internal_blue() const;
  void _internal_set_blue(double value);

  public:
  // optional double infrared = 4;
  bool has_infrared() const;
  void clear_infrared() ;
  double infrared() const;
  void set_infrared(double value);

  private:
  double _internal_infrared() const;
  void _internal_set_infrared(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.ColorRGBIR)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ColorRGBIR& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double red_;
    double green_;
    double blue_;
    double infrared_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class ColorRGB final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.ColorRGB) */ {
 public:
  inline ColorRGB() : ColorRGB(nullptr) {}
  ~ColorRGB() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ColorRGB* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ColorRGB));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ColorRGB(
      ::google::protobuf::internal::ConstantInitialized);

  inline ColorRGB(const ColorRGB& from) : ColorRGB(nullptr, from) {}
  inline ColorRGB(ColorRGB&& from) noexcept
      : ColorRGB(nullptr, std::move(from)) {}
  inline ColorRGB& operator=(const ColorRGB& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColorRGB& operator=(ColorRGB&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColorRGB& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColorRGB* internal_default_instance() {
    return reinterpret_cast<const ColorRGB*>(
        &_ColorRGB_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(ColorRGB& a, ColorRGB& b) { a.Swap(&b); }
  inline void Swap(ColorRGB* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColorRGB* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColorRGB* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ColorRGB>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ColorRGB& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ColorRGB& from) { ColorRGB::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ColorRGB* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.ColorRGB"; }

 protected:
  explicit ColorRGB(::google::protobuf::Arena* arena);
  ColorRGB(::google::protobuf::Arena* arena, const ColorRGB& from);
  ColorRGB(::google::protobuf::Arena* arena, ColorRGB&& from) noexcept
      : ColorRGB(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRedFieldNumber = 1,
    kGreenFieldNumber = 2,
    kBlueFieldNumber = 3,
  };
  // optional double red = 1;
  bool has_red() const;
  void clear_red() ;
  double red() const;
  void set_red(double value);

  private:
  double _internal_red() const;
  void _internal_set_red(double value);

  public:
  // optional double green = 2;
  bool has_green() const;
  void clear_green() ;
  double green() const;
  void set_green(double value);

  private:
  double _internal_green() const;
  void _internal_set_green(double value);

  public:
  // optional double blue = 3;
  bool has_blue() const;
  void clear_blue() ;
  double blue() const;
  void set_blue(double value);

  private:
  double _internal_blue() const;
  void _internal_set_blue(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.ColorRGB)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ColorRGB& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double red_;
    double green_;
    double blue_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class ColorLUV final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.ColorLUV) */ {
 public:
  inline ColorLUV() : ColorLUV(nullptr) {}
  ~ColorLUV() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ColorLUV* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ColorLUV));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ColorLUV(
      ::google::protobuf::internal::ConstantInitialized);

  inline ColorLUV(const ColorLUV& from) : ColorLUV(nullptr, from) {}
  inline ColorLUV(ColorLUV&& from) noexcept
      : ColorLUV(nullptr, std::move(from)) {}
  inline ColorLUV& operator=(const ColorLUV& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColorLUV& operator=(ColorLUV&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColorLUV& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColorLUV* internal_default_instance() {
    return reinterpret_cast<const ColorLUV*>(
        &_ColorLUV_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(ColorLUV& a, ColorLUV& b) { a.Swap(&b); }
  inline void Swap(ColorLUV* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColorLUV* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColorLUV* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ColorLUV>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ColorLUV& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ColorLUV& from) { ColorLUV::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ColorLUV* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.ColorLUV"; }

 protected:
  explicit ColorLUV(::google::protobuf::Arena* arena);
  ColorLUV(::google::protobuf::Arena* arena, const ColorLUV& from);
  ColorLUV(::google::protobuf::Arena* arena, ColorLUV&& from) noexcept
      : ColorLUV(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLuminanceFieldNumber = 1,
    kUFieldNumber = 2,
    kVFieldNumber = 3,
  };
  // optional double luminance = 1;
  bool has_luminance() const;
  void clear_luminance() ;
  double luminance() const;
  void set_luminance(double value);

  private:
  double _internal_luminance() const;
  void _internal_set_luminance(double value);

  public:
  // optional double u = 2;
  bool has_u() const;
  void clear_u() ;
  double u() const;
  void set_u(double value);

  private:
  double _internal_u() const;
  void _internal_set_u(double value);

  public:
  // optional double v = 3;
  bool has_v() const;
  void clear_v() ;
  double v() const;
  void set_v(double value);

  private:
  double _internal_v() const;
  void _internal_set_v(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.ColorLUV)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ColorLUV& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double luminance_;
    double u_;
    double v_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class ColorHSV final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.ColorHSV) */ {
 public:
  inline ColorHSV() : ColorHSV(nullptr) {}
  ~ColorHSV() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ColorHSV* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ColorHSV));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ColorHSV(
      ::google::protobuf::internal::ConstantInitialized);

  inline ColorHSV(const ColorHSV& from) : ColorHSV(nullptr, from) {}
  inline ColorHSV(ColorHSV&& from) noexcept
      : ColorHSV(nullptr, std::move(from)) {}
  inline ColorHSV& operator=(const ColorHSV& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColorHSV& operator=(ColorHSV&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColorHSV& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColorHSV* internal_default_instance() {
    return reinterpret_cast<const ColorHSV*>(
        &_ColorHSV_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(ColorHSV& a, ColorHSV& b) { a.Swap(&b); }
  inline void Swap(ColorHSV* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColorHSV* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColorHSV* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ColorHSV>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ColorHSV& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ColorHSV& from) { ColorHSV::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ColorHSV* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.ColorHSV"; }

 protected:
  explicit ColorHSV(::google::protobuf::Arena* arena);
  ColorHSV(::google::protobuf::Arena* arena, const ColorHSV& from);
  ColorHSV(::google::protobuf::Arena* arena, ColorHSV&& from) noexcept
      : ColorHSV(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHueFieldNumber = 1,
    kSaturationFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // optional double hue = 1;
  bool has_hue() const;
  void clear_hue() ;
  double hue() const;
  void set_hue(double value);

  private:
  double _internal_hue() const;
  void _internal_set_hue(double value);

  public:
  // optional double saturation = 2;
  bool has_saturation() const;
  void clear_saturation() ;
  double saturation() const;
  void set_saturation(double value);

  private:
  double _internal_saturation() const;
  void _internal_set_saturation(double value);

  public:
  // optional double value = 3;
  bool has_value() const;
  void clear_value() ;
  double value() const;
  void set_value(double value);

  private:
  double _internal_value() const;
  void _internal_set_value(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.ColorHSV)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ColorHSV& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double hue_;
    double saturation_;
    double value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class ColorGrey final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.ColorGrey) */ {
 public:
  inline ColorGrey() : ColorGrey(nullptr) {}
  ~ColorGrey() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ColorGrey* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ColorGrey));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ColorGrey(
      ::google::protobuf::internal::ConstantInitialized);

  inline ColorGrey(const ColorGrey& from) : ColorGrey(nullptr, from) {}
  inline ColorGrey(ColorGrey&& from) noexcept
      : ColorGrey(nullptr, std::move(from)) {}
  inline ColorGrey& operator=(const ColorGrey& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColorGrey& operator=(ColorGrey&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColorGrey& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColorGrey* internal_default_instance() {
    return reinterpret_cast<const ColorGrey*>(
        &_ColorGrey_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ColorGrey& a, ColorGrey& b) { a.Swap(&b); }
  inline void Swap(ColorGrey* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColorGrey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColorGrey* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ColorGrey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ColorGrey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ColorGrey& from) { ColorGrey::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ColorGrey* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.ColorGrey"; }

 protected:
  explicit ColorGrey(::google::protobuf::Arena* arena);
  ColorGrey(::google::protobuf::Arena* arena, const ColorGrey& from);
  ColorGrey(::google::protobuf::Arena* arena, ColorGrey&& from) noexcept
      : ColorGrey(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGreyFieldNumber = 1,
  };
  // optional double grey = 1;
  bool has_grey() const;
  void clear_grey() ;
  double grey() const;
  void set_grey(double value);

  private:
  double _internal_grey() const;
  void _internal_set_grey(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.ColorGrey)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ColorGrey& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double grey_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class ColorCMYK final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.ColorCMYK) */ {
 public:
  inline ColorCMYK() : ColorCMYK(nullptr) {}
  ~ColorCMYK() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ColorCMYK* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ColorCMYK));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ColorCMYK(
      ::google::protobuf::internal::ConstantInitialized);

  inline ColorCMYK(const ColorCMYK& from) : ColorCMYK(nullptr, from) {}
  inline ColorCMYK(ColorCMYK&& from) noexcept
      : ColorCMYK(nullptr, std::move(from)) {}
  inline ColorCMYK& operator=(const ColorCMYK& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColorCMYK& operator=(ColorCMYK&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColorCMYK& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColorCMYK* internal_default_instance() {
    return reinterpret_cast<const ColorCMYK*>(
        &_ColorCMYK_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(ColorCMYK& a, ColorCMYK& b) { a.Swap(&b); }
  inline void Swap(ColorCMYK* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColorCMYK* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColorCMYK* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ColorCMYK>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ColorCMYK& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ColorCMYK& from) { ColorCMYK::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ColorCMYK* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.ColorCMYK"; }

 protected:
  explicit ColorCMYK(::google::protobuf::Arena* arena);
  ColorCMYK(::google::protobuf::Arena* arena, const ColorCMYK& from);
  ColorCMYK(::google::protobuf::Arena* arena, ColorCMYK&& from) noexcept
      : ColorCMYK(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCyanFieldNumber = 1,
    kMagentaFieldNumber = 2,
    kYellowFieldNumber = 3,
    kKeyFieldNumber = 4,
  };
  // optional double cyan = 1;
  bool has_cyan() const;
  void clear_cyan() ;
  double cyan() const;
  void set_cyan(double value);

  private:
  double _internal_cyan() const;
  void _internal_set_cyan(double value);

  public:
  // optional double magenta = 2;
  bool has_magenta() const;
  void clear_magenta() ;
  double magenta() const;
  void set_magenta(double value);

  private:
  double _internal_magenta() const;
  void _internal_set_magenta(double value);

  public:
  // optional double yellow = 3;
  bool has_yellow() const;
  void clear_yellow() ;
  double yellow() const;
  void set_yellow(double value);

  private:
  double _internal_yellow() const;
  void _internal_set_yellow(double value);

  public:
  // optional double key = 4;
  bool has_key() const;
  void clear_key() ;
  double key() const;
  void set_key(double value);

  private:
  double _internal_key() const;
  void _internal_set_key(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.ColorCMYK)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ColorCMYK& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double cyan_;
    double magenta_;
    double yellow_;
    double key_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class StatePoint final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.StatePoint) */ {
 public:
  inline StatePoint() : StatePoint(nullptr) {}
  ~StatePoint() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StatePoint* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StatePoint));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StatePoint(
      ::google::protobuf::internal::ConstantInitialized);

  inline StatePoint(const StatePoint& from) : StatePoint(nullptr, from) {}
  inline StatePoint(StatePoint&& from) noexcept
      : StatePoint(nullptr, std::move(from)) {}
  inline StatePoint& operator=(const StatePoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatePoint& operator=(StatePoint&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatePoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatePoint* internal_default_instance() {
    return reinterpret_cast<const StatePoint*>(
        &_StatePoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(StatePoint& a, StatePoint& b) { a.Swap(&b); }
  inline void Swap(StatePoint* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatePoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatePoint* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StatePoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StatePoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StatePoint& from) { StatePoint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StatePoint* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.StatePoint"; }

 protected:
  explicit StatePoint(::google::protobuf::Arena* arena);
  StatePoint(::google::protobuf::Arena* arena, const StatePoint& from);
  StatePoint(::google::protobuf::Arena* arena, StatePoint&& from) noexcept
      : StatePoint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimestampFieldNumber = 1,
    kPositionFieldNumber = 2,
    kOrientationFieldNumber = 3,
  };
  // optional .osi3.Timestamp timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::osi3::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::osi3::Timestamp* release_timestamp();
  ::osi3::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::osi3::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::osi3::Timestamp* value);
  ::osi3::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::osi3::Timestamp& _internal_timestamp() const;
  ::osi3::Timestamp* _internal_mutable_timestamp();

  public:
  // optional .osi3.Vector3d position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::osi3::Vector3d& position() const;
  PROTOBUF_NODISCARD ::osi3::Vector3d* release_position();
  ::osi3::Vector3d* mutable_position();
  void set_allocated_position(::osi3::Vector3d* value);
  void unsafe_arena_set_allocated_position(::osi3::Vector3d* value);
  ::osi3::Vector3d* unsafe_arena_release_position();

  private:
  const ::osi3::Vector3d& _internal_position() const;
  ::osi3::Vector3d* _internal_mutable_position();

  public:
  // optional .osi3.Orientation3d orientation = 3;
  bool has_orientation() const;
  void clear_orientation() ;
  const ::osi3::Orientation3d& orientation() const;
  PROTOBUF_NODISCARD ::osi3::Orientation3d* release_orientation();
  ::osi3::Orientation3d* mutable_orientation();
  void set_allocated_orientation(::osi3::Orientation3d* value);
  void unsafe_arena_set_allocated_orientation(::osi3::Orientation3d* value);
  ::osi3::Orientation3d* unsafe_arena_release_orientation();

  private:
  const ::osi3::Orientation3d& _internal_orientation() const;
  ::osi3::Orientation3d* _internal_mutable_orientation();

  public:
  // @@protoc_insertion_point(class_scope:osi3.StatePoint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StatePoint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::osi3::Timestamp* timestamp_;
    ::osi3::Vector3d* position_;
    ::osi3::Orientation3d* orientation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class MountingPosition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.MountingPosition) */ {
 public:
  inline MountingPosition() : MountingPosition(nullptr) {}
  ~MountingPosition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MountingPosition* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MountingPosition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MountingPosition(
      ::google::protobuf::internal::ConstantInitialized);

  inline MountingPosition(const MountingPosition& from) : MountingPosition(nullptr, from) {}
  inline MountingPosition(MountingPosition&& from) noexcept
      : MountingPosition(nullptr, std::move(from)) {}
  inline MountingPosition& operator=(const MountingPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline MountingPosition& operator=(MountingPosition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MountingPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const MountingPosition* internal_default_instance() {
    return reinterpret_cast<const MountingPosition*>(
        &_MountingPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(MountingPosition& a, MountingPosition& b) { a.Swap(&b); }
  inline void Swap(MountingPosition* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MountingPosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MountingPosition* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MountingPosition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MountingPosition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MountingPosition& from) { MountingPosition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MountingPosition* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.MountingPosition"; }

 protected:
  explicit MountingPosition(::google::protobuf::Arena* arena);
  MountingPosition(::google::protobuf::Arena* arena, const MountingPosition& from);
  MountingPosition(::google::protobuf::Arena* arena, MountingPosition&& from) noexcept
      : MountingPosition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 1,
    kOrientationFieldNumber = 2,
  };
  // optional .osi3.Vector3d position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::osi3::Vector3d& position() const;
  PROTOBUF_NODISCARD ::osi3::Vector3d* release_position();
  ::osi3::Vector3d* mutable_position();
  void set_allocated_position(::osi3::Vector3d* value);
  void unsafe_arena_set_allocated_position(::osi3::Vector3d* value);
  ::osi3::Vector3d* unsafe_arena_release_position();

  private:
  const ::osi3::Vector3d& _internal_position() const;
  ::osi3::Vector3d* _internal_mutable_position();

  public:
  // optional .osi3.Orientation3d orientation = 2;
  bool has_orientation() const;
  void clear_orientation() ;
  const ::osi3::Orientation3d& orientation() const;
  PROTOBUF_NODISCARD ::osi3::Orientation3d* release_orientation();
  ::osi3::Orientation3d* mutable_orientation();
  void set_allocated_orientation(::osi3::Orientation3d* value);
  void unsafe_arena_set_allocated_orientation(::osi3::Orientation3d* value);
  ::osi3::Orientation3d* unsafe_arena_release_orientation();

  private:
  const ::osi3::Orientation3d& _internal_orientation() const;
  ::osi3::Orientation3d* _internal_mutable_orientation();

  public:
  // @@protoc_insertion_point(class_scope:osi3.MountingPosition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MountingPosition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::osi3::Vector3d* position_;
    ::osi3::Orientation3d* orientation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class LogicalLaneAssignment final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.LogicalLaneAssignment) */ {
 public:
  inline LogicalLaneAssignment() : LogicalLaneAssignment(nullptr) {}
  ~LogicalLaneAssignment() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LogicalLaneAssignment* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LogicalLaneAssignment));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LogicalLaneAssignment(
      ::google::protobuf::internal::ConstantInitialized);

  inline LogicalLaneAssignment(const LogicalLaneAssignment& from) : LogicalLaneAssignment(nullptr, from) {}
  inline LogicalLaneAssignment(LogicalLaneAssignment&& from) noexcept
      : LogicalLaneAssignment(nullptr, std::move(from)) {}
  inline LogicalLaneAssignment& operator=(const LogicalLaneAssignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogicalLaneAssignment& operator=(LogicalLaneAssignment&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogicalLaneAssignment& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogicalLaneAssignment* internal_default_instance() {
    return reinterpret_cast<const LogicalLaneAssignment*>(
        &_LogicalLaneAssignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(LogicalLaneAssignment& a, LogicalLaneAssignment& b) { a.Swap(&b); }
  inline void Swap(LogicalLaneAssignment* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogicalLaneAssignment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogicalLaneAssignment* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LogicalLaneAssignment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LogicalLaneAssignment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LogicalLaneAssignment& from) { LogicalLaneAssignment::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LogicalLaneAssignment* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.LogicalLaneAssignment"; }

 protected:
  explicit LogicalLaneAssignment(::google::protobuf::Arena* arena);
  LogicalLaneAssignment(::google::protobuf::Arena* arena, const LogicalLaneAssignment& from);
  LogicalLaneAssignment(::google::protobuf::Arena* arena, LogicalLaneAssignment&& from) noexcept
      : LogicalLaneAssignment(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAssignedLaneIdFieldNumber = 1,
    kSPositionFieldNumber = 2,
    kTPositionFieldNumber = 3,
    kAngleToLaneFieldNumber = 4,
  };
  // optional .osi3.Identifier assigned_lane_id = 1;
  bool has_assigned_lane_id() const;
  void clear_assigned_lane_id() ;
  const ::osi3::Identifier& assigned_lane_id() const;
  PROTOBUF_NODISCARD ::osi3::Identifier* release_assigned_lane_id();
  ::osi3::Identifier* mutable_assigned_lane_id();
  void set_allocated_assigned_lane_id(::osi3::Identifier* value);
  void unsafe_arena_set_allocated_assigned_lane_id(::osi3::Identifier* value);
  ::osi3::Identifier* unsafe_arena_release_assigned_lane_id();

  private:
  const ::osi3::Identifier& _internal_assigned_lane_id() const;
  ::osi3::Identifier* _internal_mutable_assigned_lane_id();

  public:
  // optional double s_position = 2;
  bool has_s_position() const;
  void clear_s_position() ;
  double s_position() const;
  void set_s_position(double value);

  private:
  double _internal_s_position() const;
  void _internal_set_s_position(double value);

  public:
  // optional double t_position = 3;
  bool has_t_position() const;
  void clear_t_position() ;
  double t_position() const;
  void set_t_position(double value);

  private:
  double _internal_t_position() const;
  void _internal_set_t_position(double value);

  public:
  // optional double angle_to_lane = 4;
  bool has_angle_to_lane() const;
  void clear_angle_to_lane() ;
  double angle_to_lane() const;
  void set_angle_to_lane(double value);

  private:
  double _internal_angle_to_lane() const;
  void _internal_set_angle_to_lane(double value);

  public:
  // @@protoc_insertion_point(class_scope:osi3.LogicalLaneAssignment)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LogicalLaneAssignment& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::osi3::Identifier* assigned_lane_id_;
    double s_position_;
    double t_position_;
    double angle_to_lane_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class ColorDescription final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.ColorDescription) */ {
 public:
  inline ColorDescription() : ColorDescription(nullptr) {}
  ~ColorDescription() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ColorDescription* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ColorDescription));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ColorDescription(
      ::google::protobuf::internal::ConstantInitialized);

  inline ColorDescription(const ColorDescription& from) : ColorDescription(nullptr, from) {}
  inline ColorDescription(ColorDescription&& from) noexcept
      : ColorDescription(nullptr, std::move(from)) {}
  inline ColorDescription& operator=(const ColorDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColorDescription& operator=(ColorDescription&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColorDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColorDescription* internal_default_instance() {
    return reinterpret_cast<const ColorDescription*>(
        &_ColorDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ColorDescription& a, ColorDescription& b) { a.Swap(&b); }
  inline void Swap(ColorDescription* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColorDescription* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColorDescription* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ColorDescription>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ColorDescription& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ColorDescription& from) { ColorDescription::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ColorDescription* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.ColorDescription"; }

 protected:
  explicit ColorDescription(::google::protobuf::Arena* arena);
  ColorDescription(::google::protobuf::Arena* arena, const ColorDescription& from);
  ColorDescription(::google::protobuf::Arena* arena, ColorDescription&& from) noexcept
      : ColorDescription(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGreyFieldNumber = 1,
    kRgbFieldNumber = 2,
    kRgbirFieldNumber = 3,
    kHsvFieldNumber = 4,
    kLuvFieldNumber = 5,
    kCmykFieldNumber = 6,
  };
  // optional .osi3.ColorGrey grey = 1;
  bool has_grey() const;
  void clear_grey() ;
  const ::osi3::ColorGrey& grey() const;
  PROTOBUF_NODISCARD ::osi3::ColorGrey* release_grey();
  ::osi3::ColorGrey* mutable_grey();
  void set_allocated_grey(::osi3::ColorGrey* value);
  void unsafe_arena_set_allocated_grey(::osi3::ColorGrey* value);
  ::osi3::ColorGrey* unsafe_arena_release_grey();

  private:
  const ::osi3::ColorGrey& _internal_grey() const;
  ::osi3::ColorGrey* _internal_mutable_grey();

  public:
  // optional .osi3.ColorRGB rgb = 2;
  bool has_rgb() const;
  void clear_rgb() ;
  const ::osi3::ColorRGB& rgb() const;
  PROTOBUF_NODISCARD ::osi3::ColorRGB* release_rgb();
  ::osi3::ColorRGB* mutable_rgb();
  void set_allocated_rgb(::osi3::ColorRGB* value);
  void unsafe_arena_set_allocated_rgb(::osi3::ColorRGB* value);
  ::osi3::ColorRGB* unsafe_arena_release_rgb();

  private:
  const ::osi3::ColorRGB& _internal_rgb() const;
  ::osi3::ColorRGB* _internal_mutable_rgb();

  public:
  // optional .osi3.ColorRGBIR rgbir = 3;
  bool has_rgbir() const;
  void clear_rgbir() ;
  const ::osi3::ColorRGBIR& rgbir() const;
  PROTOBUF_NODISCARD ::osi3::ColorRGBIR* release_rgbir();
  ::osi3::ColorRGBIR* mutable_rgbir();
  void set_allocated_rgbir(::osi3::ColorRGBIR* value);
  void unsafe_arena_set_allocated_rgbir(::osi3::ColorRGBIR* value);
  ::osi3::ColorRGBIR* unsafe_arena_release_rgbir();

  private:
  const ::osi3::ColorRGBIR& _internal_rgbir() const;
  ::osi3::ColorRGBIR* _internal_mutable_rgbir();

  public:
  // optional .osi3.ColorHSV hsv = 4;
  bool has_hsv() const;
  void clear_hsv() ;
  const ::osi3::ColorHSV& hsv() const;
  PROTOBUF_NODISCARD ::osi3::ColorHSV* release_hsv();
  ::osi3::ColorHSV* mutable_hsv();
  void set_allocated_hsv(::osi3::ColorHSV* value);
  void unsafe_arena_set_allocated_hsv(::osi3::ColorHSV* value);
  ::osi3::ColorHSV* unsafe_arena_release_hsv();

  private:
  const ::osi3::ColorHSV& _internal_hsv() const;
  ::osi3::ColorHSV* _internal_mutable_hsv();

  public:
  // optional .osi3.ColorLUV luv = 5;
  bool has_luv() const;
  void clear_luv() ;
  const ::osi3::ColorLUV& luv() const;
  PROTOBUF_NODISCARD ::osi3::ColorLUV* release_luv();
  ::osi3::ColorLUV* mutable_luv();
  void set_allocated_luv(::osi3::ColorLUV* value);
  void unsafe_arena_set_allocated_luv(::osi3::ColorLUV* value);
  ::osi3::ColorLUV* unsafe_arena_release_luv();

  private:
  const ::osi3::ColorLUV& _internal_luv() const;
  ::osi3::ColorLUV* _internal_mutable_luv();

  public:
  // optional .osi3.ColorCMYK cmyk = 6;
  bool has_cmyk() const;
  void clear_cmyk() ;
  const ::osi3::ColorCMYK& cmyk() const;
  PROTOBUF_NODISCARD ::osi3::ColorCMYK* release_cmyk();
  ::osi3::ColorCMYK* mutable_cmyk();
  void set_allocated_cmyk(::osi3::ColorCMYK* value);
  void unsafe_arena_set_allocated_cmyk(::osi3::ColorCMYK* value);
  ::osi3::ColorCMYK* unsafe_arena_release_cmyk();

  private:
  const ::osi3::ColorCMYK& _internal_cmyk() const;
  ::osi3::ColorCMYK* _internal_mutable_cmyk();

  public:
  // @@protoc_insertion_point(class_scope:osi3.ColorDescription)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 6,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ColorDescription& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::osi3::ColorGrey* grey_;
    ::osi3::ColorRGB* rgb_;
    ::osi3::ColorRGBIR* rgbir_;
    ::osi3::ColorHSV* hsv_;
    ::osi3::ColorLUV* luv_;
    ::osi3::ColorCMYK* cmyk_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class BaseStationary final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.BaseStationary) */ {
 public:
  inline BaseStationary() : BaseStationary(nullptr) {}
  ~BaseStationary() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BaseStationary* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BaseStationary));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BaseStationary(
      ::google::protobuf::internal::ConstantInitialized);

  inline BaseStationary(const BaseStationary& from) : BaseStationary(nullptr, from) {}
  inline BaseStationary(BaseStationary&& from) noexcept
      : BaseStationary(nullptr, std::move(from)) {}
  inline BaseStationary& operator=(const BaseStationary& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseStationary& operator=(BaseStationary&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseStationary& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseStationary* internal_default_instance() {
    return reinterpret_cast<const BaseStationary*>(
        &_BaseStationary_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(BaseStationary& a, BaseStationary& b) { a.Swap(&b); }
  inline void Swap(BaseStationary* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseStationary* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseStationary* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BaseStationary>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BaseStationary& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BaseStationary& from) { BaseStationary::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BaseStationary* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.BaseStationary"; }

 protected:
  explicit BaseStationary(::google::protobuf::Arena* arena);
  BaseStationary(::google::protobuf::Arena* arena, const BaseStationary& from);
  BaseStationary(::google::protobuf::Arena* arena, BaseStationary&& from) noexcept
      : BaseStationary(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBasePolygonFieldNumber = 4,
    kDimensionFieldNumber = 1,
    kPositionFieldNumber = 2,
    kOrientationFieldNumber = 3,
  };
  // repeated .osi3.Vector2d base_polygon = 4;
  int base_polygon_size() const;
  private:
  int _internal_base_polygon_size() const;

  public:
  void clear_base_polygon() ;
  ::osi3::Vector2d* mutable_base_polygon(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::Vector2d>* mutable_base_polygon();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::Vector2d>& _internal_base_polygon() const;
  ::google::protobuf::RepeatedPtrField<::osi3::Vector2d>* _internal_mutable_base_polygon();
  public:
  const ::osi3::Vector2d& base_polygon(int index) const;
  ::osi3::Vector2d* add_base_polygon();
  const ::google::protobuf::RepeatedPtrField<::osi3::Vector2d>& base_polygon() const;
  // optional .osi3.Dimension3d dimension = 1;
  bool has_dimension() const;
  void clear_dimension() ;
  const ::osi3::Dimension3d& dimension() const;
  PROTOBUF_NODISCARD ::osi3::Dimension3d* release_dimension();
  ::osi3::Dimension3d* mutable_dimension();
  void set_allocated_dimension(::osi3::Dimension3d* value);
  void unsafe_arena_set_allocated_dimension(::osi3::Dimension3d* value);
  ::osi3::Dimension3d* unsafe_arena_release_dimension();

  private:
  const ::osi3::Dimension3d& _internal_dimension() const;
  ::osi3::Dimension3d* _internal_mutable_dimension();

  public:
  // optional .osi3.Vector3d position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::osi3::Vector3d& position() const;
  PROTOBUF_NODISCARD ::osi3::Vector3d* release_position();
  ::osi3::Vector3d* mutable_position();
  void set_allocated_position(::osi3::Vector3d* value);
  void unsafe_arena_set_allocated_position(::osi3::Vector3d* value);
  ::osi3::Vector3d* unsafe_arena_release_position();

  private:
  const ::osi3::Vector3d& _internal_position() const;
  ::osi3::Vector3d* _internal_mutable_position();

  public:
  // optional .osi3.Orientation3d orientation = 3;
  bool has_orientation() const;
  void clear_orientation() ;
  const ::osi3::Orientation3d& orientation() const;
  PROTOBUF_NODISCARD ::osi3::Orientation3d* release_orientation();
  ::osi3::Orientation3d* mutable_orientation();
  void set_allocated_orientation(::osi3::Orientation3d* value);
  void unsafe_arena_set_allocated_orientation(::osi3::Orientation3d* value);
  ::osi3::Orientation3d* unsafe_arena_release_orientation();

  private:
  const ::osi3::Orientation3d& _internal_orientation() const;
  ::osi3::Orientation3d* _internal_mutable_orientation();

  public:
  // @@protoc_insertion_point(class_scope:osi3.BaseStationary)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BaseStationary& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::osi3::Vector2d > base_polygon_;
    ::osi3::Dimension3d* dimension_;
    ::osi3::Vector3d* position_;
    ::osi3::Orientation3d* orientation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class BaseMoving final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:osi3.BaseMoving) */ {
 public:
  inline BaseMoving() : BaseMoving(nullptr) {}
  ~BaseMoving() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BaseMoving* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BaseMoving));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BaseMoving(
      ::google::protobuf::internal::ConstantInitialized);

  inline BaseMoving(const BaseMoving& from) : BaseMoving(nullptr, from) {}
  inline BaseMoving(BaseMoving&& from) noexcept
      : BaseMoving(nullptr, std::move(from)) {}
  inline BaseMoving& operator=(const BaseMoving& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseMoving& operator=(BaseMoving&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseMoving& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseMoving* internal_default_instance() {
    return reinterpret_cast<const BaseMoving*>(
        &_BaseMoving_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(BaseMoving& a, BaseMoving& b) { a.Swap(&b); }
  inline void Swap(BaseMoving* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseMoving* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseMoving* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BaseMoving>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BaseMoving& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BaseMoving& from) { BaseMoving::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BaseMoving* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "osi3.BaseMoving"; }

 protected:
  explicit BaseMoving(::google::protobuf::Arena* arena);
  BaseMoving(::google::protobuf::Arena* arena, const BaseMoving& from);
  BaseMoving(::google::protobuf::Arena* arena, BaseMoving&& from) noexcept
      : BaseMoving(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBasePolygonFieldNumber = 7,
    kDimensionFieldNumber = 1,
    kPositionFieldNumber = 2,
    kOrientationFieldNumber = 3,
    kVelocityFieldNumber = 4,
    kAccelerationFieldNumber = 5,
    kOrientationRateFieldNumber = 6,
    kOrientationAccelerationFieldNumber = 8,
  };
  // repeated .osi3.Vector2d base_polygon = 7;
  int base_polygon_size() const;
  private:
  int _internal_base_polygon_size() const;

  public:
  void clear_base_polygon() ;
  ::osi3::Vector2d* mutable_base_polygon(int index);
  ::google::protobuf::RepeatedPtrField<::osi3::Vector2d>* mutable_base_polygon();

  private:
  const ::google::protobuf::RepeatedPtrField<::osi3::Vector2d>& _internal_base_polygon() const;
  ::google::protobuf::RepeatedPtrField<::osi3::Vector2d>* _internal_mutable_base_polygon();
  public:
  const ::osi3::Vector2d& base_polygon(int index) const;
  ::osi3::Vector2d* add_base_polygon();
  const ::google::protobuf::RepeatedPtrField<::osi3::Vector2d>& base_polygon() const;
  // optional .osi3.Dimension3d dimension = 1;
  bool has_dimension() const;
  void clear_dimension() ;
  const ::osi3::Dimension3d& dimension() const;
  PROTOBUF_NODISCARD ::osi3::Dimension3d* release_dimension();
  ::osi3::Dimension3d* mutable_dimension();
  void set_allocated_dimension(::osi3::Dimension3d* value);
  void unsafe_arena_set_allocated_dimension(::osi3::Dimension3d* value);
  ::osi3::Dimension3d* unsafe_arena_release_dimension();

  private:
  const ::osi3::Dimension3d& _internal_dimension() const;
  ::osi3::Dimension3d* _internal_mutable_dimension();

  public:
  // optional .osi3.Vector3d position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::osi3::Vector3d& position() const;
  PROTOBUF_NODISCARD ::osi3::Vector3d* release_position();
  ::osi3::Vector3d* mutable_position();
  void set_allocated_position(::osi3::Vector3d* value);
  void unsafe_arena_set_allocated_position(::osi3::Vector3d* value);
  ::osi3::Vector3d* unsafe_arena_release_position();

  private:
  const ::osi3::Vector3d& _internal_position() const;
  ::osi3::Vector3d* _internal_mutable_position();

  public:
  // optional .osi3.Orientation3d orientation = 3;
  bool has_orientation() const;
  void clear_orientation() ;
  const ::osi3::Orientation3d& orientation() const;
  PROTOBUF_NODISCARD ::osi3::Orientation3d* release_orientation();
  ::osi3::Orientation3d* mutable_orientation();
  void set_allocated_orientation(::osi3::Orientation3d* value);
  void unsafe_arena_set_allocated_orientation(::osi3::Orientation3d* value);
  ::osi3::Orientation3d* unsafe_arena_release_orientation();

  private:
  const ::osi3::Orientation3d& _internal_orientation() const;
  ::osi3::Orientation3d* _internal_mutable_orientation();

  public:
  // optional .osi3.Vector3d velocity = 4;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::osi3::Vector3d& velocity() const;
  PROTOBUF_NODISCARD ::osi3::Vector3d* release_velocity();
  ::osi3::Vector3d* mutable_velocity();
  void set_allocated_velocity(::osi3::Vector3d* value);
  void unsafe_arena_set_allocated_velocity(::osi3::Vector3d* value);
  ::osi3::Vector3d* unsafe_arena_release_velocity();

  private:
  const ::osi3::Vector3d& _internal_velocity() const;
  ::osi3::Vector3d* _internal_mutable_velocity();

  public:
  // optional .osi3.Vector3d acceleration = 5;
  bool has_acceleration() const;
  void clear_acceleration() ;
  const ::osi3::Vector3d& acceleration() const;
  PROTOBUF_NODISCARD ::osi3::Vector3d* release_acceleration();
  ::osi3::Vector3d* mutable_acceleration();
  void set_allocated_acceleration(::osi3::Vector3d* value);
  void unsafe_arena_set_allocated_acceleration(::osi3::Vector3d* value);
  ::osi3::Vector3d* unsafe_arena_release_acceleration();

  private:
  const ::osi3::Vector3d& _internal_acceleration() const;
  ::osi3::Vector3d* _internal_mutable_acceleration();

  public:
  // optional .osi3.Orientation3d orientation_rate = 6;
  bool has_orientation_rate() const;
  void clear_orientation_rate() ;
  const ::osi3::Orientation3d& orientation_rate() const;
  PROTOBUF_NODISCARD ::osi3::Orientation3d* release_orientation_rate();
  ::osi3::Orientation3d* mutable_orientation_rate();
  void set_allocated_orientation_rate(::osi3::Orientation3d* value);
  void unsafe_arena_set_allocated_orientation_rate(::osi3::Orientation3d* value);
  ::osi3::Orientation3d* unsafe_arena_release_orientation_rate();

  private:
  const ::osi3::Orientation3d& _internal_orientation_rate() const;
  ::osi3::Orientation3d* _internal_mutable_orientation_rate();

  public:
  // optional .osi3.Orientation3d orientation_acceleration = 8;
  bool has_orientation_acceleration() const;
  void clear_orientation_acceleration() ;
  const ::osi3::Orientation3d& orientation_acceleration() const;
  PROTOBUF_NODISCARD ::osi3::Orientation3d* release_orientation_acceleration();
  ::osi3::Orientation3d* mutable_orientation_acceleration();
  void set_allocated_orientation_acceleration(::osi3::Orientation3d* value);
  void unsafe_arena_set_allocated_orientation_acceleration(::osi3::Orientation3d* value);
  ::osi3::Orientation3d* unsafe_arena_release_orientation_acceleration();

  private:
  const ::osi3::Orientation3d& _internal_orientation_acceleration() const;
  ::osi3::Orientation3d* _internal_mutable_orientation_acceleration();

  public:
  // @@protoc_insertion_point(class_scope:osi3.BaseMoving)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 8,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BaseMoving& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::osi3::Vector2d > base_polygon_;
    ::osi3::Dimension3d* dimension_;
    ::osi3::Vector3d* position_;
    ::osi3::Orientation3d* orientation_;
    ::osi3::Vector3d* velocity_;
    ::osi3::Vector3d* acceleration_;
    ::osi3::Orientation3d* orientation_rate_;
    ::osi3::Orientation3d* orientation_acceleration_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_osi_5fcommon_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Vector3d

// optional double x = 1;
inline bool Vector3d::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Vector3d::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Vector3d::x() const {
  // @@protoc_insertion_point(field_get:osi3.Vector3d.x)
  return _internal_x();
}
inline void Vector3d::set_x(double value) {
  _internal_set_x(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.Vector3d.x)
}
inline double Vector3d::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Vector3d::_internal_set_x(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// optional double y = 2;
inline bool Vector3d::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Vector3d::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Vector3d::y() const {
  // @@protoc_insertion_point(field_get:osi3.Vector3d.y)
  return _internal_y();
}
inline void Vector3d::set_y(double value) {
  _internal_set_y(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.Vector3d.y)
}
inline double Vector3d::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Vector3d::_internal_set_y(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// optional double z = 3;
inline bool Vector3d::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Vector3d::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Vector3d::z() const {
  // @@protoc_insertion_point(field_get:osi3.Vector3d.z)
  return _internal_z();
}
inline void Vector3d::set_z(double value) {
  _internal_set_z(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.Vector3d.z)
}
inline double Vector3d::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Vector3d::_internal_set_z(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Vector2d

// optional double x = 1;
inline bool Vector2d::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Vector2d::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Vector2d::x() const {
  // @@protoc_insertion_point(field_get:osi3.Vector2d.x)
  return _internal_x();
}
inline void Vector2d::set_x(double value) {
  _internal_set_x(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.Vector2d.x)
}
inline double Vector2d::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Vector2d::_internal_set_x(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// optional double y = 2;
inline bool Vector2d::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Vector2d::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Vector2d::y() const {
  // @@protoc_insertion_point(field_get:osi3.Vector2d.y)
  return _internal_y();
}
inline void Vector2d::set_y(double value) {
  _internal_set_y(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.Vector2d.y)
}
inline double Vector2d::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Vector2d::_internal_set_y(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// Timestamp

// optional int64 seconds = 1;
inline bool Timestamp::has_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Timestamp::clear_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.seconds_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t Timestamp::seconds() const {
  // @@protoc_insertion_point(field_get:osi3.Timestamp.seconds)
  return _internal_seconds();
}
inline void Timestamp::set_seconds(::int64_t value) {
  _internal_set_seconds(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.Timestamp.seconds)
}
inline ::int64_t Timestamp::_internal_seconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.seconds_;
}
inline void Timestamp::_internal_set_seconds(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.seconds_ = value;
}

// optional uint32 nanos = 2;
inline bool Timestamp::has_nanos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Timestamp::clear_nanos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nanos_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t Timestamp::nanos() const {
  // @@protoc_insertion_point(field_get:osi3.Timestamp.nanos)
  return _internal_nanos();
}
inline void Timestamp::set_nanos(::uint32_t value) {
  _internal_set_nanos(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.Timestamp.nanos)
}
inline ::uint32_t Timestamp::_internal_nanos() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nanos_;
}
inline void Timestamp::_internal_set_nanos(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nanos_ = value;
}

// -------------------------------------------------------------------

// Dimension3d

// optional double length = 1;
inline bool Dimension3d::has_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Dimension3d::clear_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Dimension3d::length() const {
  // @@protoc_insertion_point(field_get:osi3.Dimension3d.length)
  return _internal_length();
}
inline void Dimension3d::set_length(double value) {
  _internal_set_length(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.Dimension3d.length)
}
inline double Dimension3d::_internal_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.length_;
}
inline void Dimension3d::_internal_set_length(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_ = value;
}

// optional double width = 2;
inline bool Dimension3d::has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Dimension3d::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Dimension3d::width() const {
  // @@protoc_insertion_point(field_get:osi3.Dimension3d.width)
  return _internal_width();
}
inline void Dimension3d::set_width(double value) {
  _internal_set_width(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.Dimension3d.width)
}
inline double Dimension3d::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void Dimension3d::_internal_set_width(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// optional double height = 3;
inline bool Dimension3d::has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Dimension3d::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Dimension3d::height() const {
  // @@protoc_insertion_point(field_get:osi3.Dimension3d.height)
  return _internal_height();
}
inline void Dimension3d::set_height(double value) {
  _internal_set_height(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.Dimension3d.height)
}
inline double Dimension3d::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void Dimension3d::_internal_set_height(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// -------------------------------------------------------------------

// Orientation3d

// optional double roll = 1;
inline bool Orientation3d::has_roll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Orientation3d::clear_roll() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.roll_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Orientation3d::roll() const {
  // @@protoc_insertion_point(field_get:osi3.Orientation3d.roll)
  return _internal_roll();
}
inline void Orientation3d::set_roll(double value) {
  _internal_set_roll(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.Orientation3d.roll)
}
inline double Orientation3d::_internal_roll() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.roll_;
}
inline void Orientation3d::_internal_set_roll(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.roll_ = value;
}

// optional double pitch = 2;
inline bool Orientation3d::has_pitch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Orientation3d::clear_pitch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pitch_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Orientation3d::pitch() const {
  // @@protoc_insertion_point(field_get:osi3.Orientation3d.pitch)
  return _internal_pitch();
}
inline void Orientation3d::set_pitch(double value) {
  _internal_set_pitch(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.Orientation3d.pitch)
}
inline double Orientation3d::_internal_pitch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pitch_;
}
inline void Orientation3d::_internal_set_pitch(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pitch_ = value;
}

// optional double yaw = 3;
inline bool Orientation3d::has_yaw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Orientation3d::clear_yaw() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.yaw_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Orientation3d::yaw() const {
  // @@protoc_insertion_point(field_get:osi3.Orientation3d.yaw)
  return _internal_yaw();
}
inline void Orientation3d::set_yaw(double value) {
  _internal_set_yaw(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.Orientation3d.yaw)
}
inline double Orientation3d::_internal_yaw() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.yaw_;
}
inline void Orientation3d::_internal_set_yaw(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.yaw_ = value;
}

// -------------------------------------------------------------------

// Identifier

// optional uint64 value = 1;
inline bool Identifier::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Identifier::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t Identifier::value() const {
  // @@protoc_insertion_point(field_get:osi3.Identifier.value)
  return _internal_value();
}
inline void Identifier::set_value(::uint64_t value) {
  _internal_set_value(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.Identifier.value)
}
inline ::uint64_t Identifier::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void Identifier::_internal_set_value(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ExternalReference

// optional string reference = 1;
inline bool ExternalReference::has_reference() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ExternalReference::clear_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reference_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExternalReference::reference() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.ExternalReference.reference)
  return _internal_reference();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExternalReference::set_reference(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reference_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:osi3.ExternalReference.reference)
}
inline std::string* ExternalReference::mutable_reference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:osi3.ExternalReference.reference)
  return _s;
}
inline const std::string& ExternalReference::_internal_reference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reference_.Get();
}
inline void ExternalReference::_internal_set_reference(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reference_.Set(value, GetArena());
}
inline std::string* ExternalReference::_internal_mutable_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.reference_.Mutable( GetArena());
}
inline std::string* ExternalReference::release_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.ExternalReference.reference)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.reference_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.reference_.Set("", GetArena());
  }
  return released;
}
inline void ExternalReference::set_allocated_reference(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.reference_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reference_.IsDefault()) {
    _impl_.reference_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.ExternalReference.reference)
}

// optional string type = 2;
inline bool ExternalReference::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ExternalReference::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ExternalReference::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.ExternalReference.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExternalReference::set_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:osi3.ExternalReference.type)
}
inline std::string* ExternalReference::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:osi3.ExternalReference.type)
  return _s;
}
inline const std::string& ExternalReference::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void ExternalReference::_internal_set_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* ExternalReference::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* ExternalReference::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.ExternalReference.type)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.type_.Set("", GetArena());
  }
  return released;
}
inline void ExternalReference::set_allocated_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.ExternalReference.type)
}

// repeated string identifier = 3;
inline int ExternalReference::_internal_identifier_size() const {
  return _internal_identifier().size();
}
inline int ExternalReference::identifier_size() const {
  return _internal_identifier_size();
}
inline void ExternalReference::clear_identifier() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.identifier_.Clear();
}
inline std::string* ExternalReference::add_identifier() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_identifier()->Add();
  // @@protoc_insertion_point(field_add_mutable:osi3.ExternalReference.identifier)
  return _s;
}
inline const std::string& ExternalReference::identifier(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.ExternalReference.identifier)
  return _internal_identifier().Get(index);
}
inline std::string* ExternalReference::mutable_identifier(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.ExternalReference.identifier)
  return _internal_mutable_identifier()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ExternalReference::set_identifier(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_identifier()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:osi3.ExternalReference.identifier)
}
template <typename Arg_, typename... Args_>
inline void ExternalReference::add_identifier(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_identifier(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:osi3.ExternalReference.identifier)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ExternalReference::identifier() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.ExternalReference.identifier)
  return _internal_identifier();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ExternalReference::mutable_identifier() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.ExternalReference.identifier)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_identifier();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ExternalReference::_internal_identifier() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.identifier_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ExternalReference::_internal_mutable_identifier() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.identifier_;
}

// -------------------------------------------------------------------

// MountingPosition

// optional .osi3.Vector3d position = 1;
inline bool MountingPosition::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void MountingPosition::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::osi3::Vector3d& MountingPosition::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Vector3d* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Vector3d&>(::osi3::_Vector3d_default_instance_);
}
inline const ::osi3::Vector3d& MountingPosition::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.MountingPosition.position)
  return _internal_position();
}
inline void MountingPosition::unsafe_arena_set_allocated_position(::osi3::Vector3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::osi3::Vector3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.MountingPosition.position)
}
inline ::osi3::Vector3d* MountingPosition::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Vector3d* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Vector3d* MountingPosition::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.MountingPosition.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Vector3d* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::osi3::Vector3d* MountingPosition::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Vector3d>(GetArena());
    _impl_.position_ = reinterpret_cast<::osi3::Vector3d*>(p);
  }
  return _impl_.position_;
}
inline ::osi3::Vector3d* MountingPosition::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::Vector3d* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:osi3.MountingPosition.position)
  return _msg;
}
inline void MountingPosition::set_allocated_position(::osi3::Vector3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::osi3::Vector3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.MountingPosition.position)
}

// optional .osi3.Orientation3d orientation = 2;
inline bool MountingPosition::has_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orientation_ != nullptr);
  return value;
}
inline void MountingPosition::clear_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_ != nullptr) _impl_.orientation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::osi3::Orientation3d& MountingPosition::_internal_orientation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Orientation3d* p = _impl_.orientation_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Orientation3d&>(::osi3::_Orientation3d_default_instance_);
}
inline const ::osi3::Orientation3d& MountingPosition::orientation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.MountingPosition.orientation)
  return _internal_orientation();
}
inline void MountingPosition::unsafe_arena_set_allocated_orientation(::osi3::Orientation3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_);
  }
  _impl_.orientation_ = reinterpret_cast<::osi3::Orientation3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.MountingPosition.orientation)
}
inline ::osi3::Orientation3d* MountingPosition::release_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Orientation3d* released = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Orientation3d* MountingPosition::unsafe_arena_release_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.MountingPosition.orientation)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Orientation3d* temp = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
  return temp;
}
inline ::osi3::Orientation3d* MountingPosition::_internal_mutable_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Orientation3d>(GetArena());
    _impl_.orientation_ = reinterpret_cast<::osi3::Orientation3d*>(p);
  }
  return _impl_.orientation_;
}
inline ::osi3::Orientation3d* MountingPosition::mutable_orientation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::osi3::Orientation3d* _msg = _internal_mutable_orientation();
  // @@protoc_insertion_point(field_mutable:osi3.MountingPosition.orientation)
  return _msg;
}
inline void MountingPosition::set_allocated_orientation(::osi3::Orientation3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.orientation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.orientation_ = reinterpret_cast<::osi3::Orientation3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.MountingPosition.orientation)
}

// -------------------------------------------------------------------

// Spherical3d

// optional double distance = 1;
inline bool Spherical3d::has_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Spherical3d::clear_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Spherical3d::distance() const {
  // @@protoc_insertion_point(field_get:osi3.Spherical3d.distance)
  return _internal_distance();
}
inline void Spherical3d::set_distance(double value) {
  _internal_set_distance(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.Spherical3d.distance)
}
inline double Spherical3d::_internal_distance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.distance_;
}
inline void Spherical3d::_internal_set_distance(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_ = value;
}

// optional double azimuth = 2;
inline bool Spherical3d::has_azimuth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Spherical3d::clear_azimuth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.azimuth_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Spherical3d::azimuth() const {
  // @@protoc_insertion_point(field_get:osi3.Spherical3d.azimuth)
  return _internal_azimuth();
}
inline void Spherical3d::set_azimuth(double value) {
  _internal_set_azimuth(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.Spherical3d.azimuth)
}
inline double Spherical3d::_internal_azimuth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.azimuth_;
}
inline void Spherical3d::_internal_set_azimuth(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.azimuth_ = value;
}

// optional double elevation = 3;
inline bool Spherical3d::has_elevation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Spherical3d::clear_elevation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.elevation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Spherical3d::elevation() const {
  // @@protoc_insertion_point(field_get:osi3.Spherical3d.elevation)
  return _internal_elevation();
}
inline void Spherical3d::set_elevation(double value) {
  _internal_set_elevation(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.Spherical3d.elevation)
}
inline double Spherical3d::_internal_elevation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.elevation_;
}
inline void Spherical3d::_internal_set_elevation(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.elevation_ = value;
}

// -------------------------------------------------------------------

// LogicalLaneAssignment

// optional .osi3.Identifier assigned_lane_id = 1;
inline bool LogicalLaneAssignment::has_assigned_lane_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.assigned_lane_id_ != nullptr);
  return value;
}
inline void LogicalLaneAssignment::clear_assigned_lane_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.assigned_lane_id_ != nullptr) _impl_.assigned_lane_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::osi3::Identifier& LogicalLaneAssignment::_internal_assigned_lane_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Identifier* p = _impl_.assigned_lane_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Identifier&>(::osi3::_Identifier_default_instance_);
}
inline const ::osi3::Identifier& LogicalLaneAssignment::assigned_lane_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.LogicalLaneAssignment.assigned_lane_id)
  return _internal_assigned_lane_id();
}
inline void LogicalLaneAssignment::unsafe_arena_set_allocated_assigned_lane_id(::osi3::Identifier* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.assigned_lane_id_);
  }
  _impl_.assigned_lane_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.LogicalLaneAssignment.assigned_lane_id)
}
inline ::osi3::Identifier* LogicalLaneAssignment::release_assigned_lane_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Identifier* released = _impl_.assigned_lane_id_;
  _impl_.assigned_lane_id_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Identifier* LogicalLaneAssignment::unsafe_arena_release_assigned_lane_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.LogicalLaneAssignment.assigned_lane_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Identifier* temp = _impl_.assigned_lane_id_;
  _impl_.assigned_lane_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* LogicalLaneAssignment::_internal_mutable_assigned_lane_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.assigned_lane_id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Identifier>(GetArena());
    _impl_.assigned_lane_id_ = reinterpret_cast<::osi3::Identifier*>(p);
  }
  return _impl_.assigned_lane_id_;
}
inline ::osi3::Identifier* LogicalLaneAssignment::mutable_assigned_lane_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::Identifier* _msg = _internal_mutable_assigned_lane_id();
  // @@protoc_insertion_point(field_mutable:osi3.LogicalLaneAssignment.assigned_lane_id)
  return _msg;
}
inline void LogicalLaneAssignment::set_allocated_assigned_lane_id(::osi3::Identifier* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.assigned_lane_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.assigned_lane_id_ = reinterpret_cast<::osi3::Identifier*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.LogicalLaneAssignment.assigned_lane_id)
}

// optional double s_position = 2;
inline bool LogicalLaneAssignment::has_s_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void LogicalLaneAssignment::clear_s_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s_position_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double LogicalLaneAssignment::s_position() const {
  // @@protoc_insertion_point(field_get:osi3.LogicalLaneAssignment.s_position)
  return _internal_s_position();
}
inline void LogicalLaneAssignment::set_s_position(double value) {
  _internal_set_s_position(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.LogicalLaneAssignment.s_position)
}
inline double LogicalLaneAssignment::_internal_s_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.s_position_;
}
inline void LogicalLaneAssignment::_internal_set_s_position(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s_position_ = value;
}

// optional double t_position = 3;
inline bool LogicalLaneAssignment::has_t_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void LogicalLaneAssignment::clear_t_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.t_position_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double LogicalLaneAssignment::t_position() const {
  // @@protoc_insertion_point(field_get:osi3.LogicalLaneAssignment.t_position)
  return _internal_t_position();
}
inline void LogicalLaneAssignment::set_t_position(double value) {
  _internal_set_t_position(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.LogicalLaneAssignment.t_position)
}
inline double LogicalLaneAssignment::_internal_t_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.t_position_;
}
inline void LogicalLaneAssignment::_internal_set_t_position(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.t_position_ = value;
}

// optional double angle_to_lane = 4;
inline bool LogicalLaneAssignment::has_angle_to_lane() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void LogicalLaneAssignment::clear_angle_to_lane() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.angle_to_lane_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double LogicalLaneAssignment::angle_to_lane() const {
  // @@protoc_insertion_point(field_get:osi3.LogicalLaneAssignment.angle_to_lane)
  return _internal_angle_to_lane();
}
inline void LogicalLaneAssignment::set_angle_to_lane(double value) {
  _internal_set_angle_to_lane(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:osi3.LogicalLaneAssignment.angle_to_lane)
}
inline double LogicalLaneAssignment::_internal_angle_to_lane() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.angle_to_lane_;
}
inline void LogicalLaneAssignment::_internal_set_angle_to_lane(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.angle_to_lane_ = value;
}

// -------------------------------------------------------------------

// BaseStationary

// optional .osi3.Dimension3d dimension = 1;
inline bool BaseStationary::has_dimension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dimension_ != nullptr);
  return value;
}
inline void BaseStationary::clear_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dimension_ != nullptr) _impl_.dimension_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::osi3::Dimension3d& BaseStationary::_internal_dimension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Dimension3d* p = _impl_.dimension_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Dimension3d&>(::osi3::_Dimension3d_default_instance_);
}
inline const ::osi3::Dimension3d& BaseStationary::dimension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.BaseStationary.dimension)
  return _internal_dimension();
}
inline void BaseStationary::unsafe_arena_set_allocated_dimension(::osi3::Dimension3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dimension_);
  }
  _impl_.dimension_ = reinterpret_cast<::osi3::Dimension3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.BaseStationary.dimension)
}
inline ::osi3::Dimension3d* BaseStationary::release_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Dimension3d* released = _impl_.dimension_;
  _impl_.dimension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Dimension3d* BaseStationary::unsafe_arena_release_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.BaseStationary.dimension)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Dimension3d* temp = _impl_.dimension_;
  _impl_.dimension_ = nullptr;
  return temp;
}
inline ::osi3::Dimension3d* BaseStationary::_internal_mutable_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dimension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Dimension3d>(GetArena());
    _impl_.dimension_ = reinterpret_cast<::osi3::Dimension3d*>(p);
  }
  return _impl_.dimension_;
}
inline ::osi3::Dimension3d* BaseStationary::mutable_dimension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::Dimension3d* _msg = _internal_mutable_dimension();
  // @@protoc_insertion_point(field_mutable:osi3.BaseStationary.dimension)
  return _msg;
}
inline void BaseStationary::set_allocated_dimension(::osi3::Dimension3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dimension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dimension_ = reinterpret_cast<::osi3::Dimension3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.BaseStationary.dimension)
}

// optional .osi3.Vector3d position = 2;
inline bool BaseStationary::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void BaseStationary::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::osi3::Vector3d& BaseStationary::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Vector3d* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Vector3d&>(::osi3::_Vector3d_default_instance_);
}
inline const ::osi3::Vector3d& BaseStationary::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.BaseStationary.position)
  return _internal_position();
}
inline void BaseStationary::unsafe_arena_set_allocated_position(::osi3::Vector3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::osi3::Vector3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.BaseStationary.position)
}
inline ::osi3::Vector3d* BaseStationary::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Vector3d* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Vector3d* BaseStationary::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.BaseStationary.position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Vector3d* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::osi3::Vector3d* BaseStationary::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Vector3d>(GetArena());
    _impl_.position_ = reinterpret_cast<::osi3::Vector3d*>(p);
  }
  return _impl_.position_;
}
inline ::osi3::Vector3d* BaseStationary::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::osi3::Vector3d* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:osi3.BaseStationary.position)
  return _msg;
}
inline void BaseStationary::set_allocated_position(::osi3::Vector3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.position_ = reinterpret_cast<::osi3::Vector3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.BaseStationary.position)
}

// optional .osi3.Orientation3d orientation = 3;
inline bool BaseStationary::has_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orientation_ != nullptr);
  return value;
}
inline void BaseStationary::clear_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_ != nullptr) _impl_.orientation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::osi3::Orientation3d& BaseStationary::_internal_orientation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Orientation3d* p = _impl_.orientation_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Orientation3d&>(::osi3::_Orientation3d_default_instance_);
}
inline const ::osi3::Orientation3d& BaseStationary::orientation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.BaseStationary.orientation)
  return _internal_orientation();
}
inline void BaseStationary::unsafe_arena_set_allocated_orientation(::osi3::Orientation3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_);
  }
  _impl_.orientation_ = reinterpret_cast<::osi3::Orientation3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.BaseStationary.orientation)
}
inline ::osi3::Orientation3d* BaseStationary::release_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::Orientation3d* released = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Orientation3d* BaseStationary::unsafe_arena_release_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.BaseStationary.orientation)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::Orientation3d* temp = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
  return temp;
}
inline ::osi3::Orientation3d* BaseStationary::_internal_mutable_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Orientation3d>(GetArena());
    _impl_.orientation_ = reinterpret_cast<::osi3::Orientation3d*>(p);
  }
  return _impl_.orientation_;
}
inline ::osi3::Orientation3d* BaseStationary::mutable_orientation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::osi3::Orientation3d* _msg = _internal_mutable_orientation();
  // @@protoc_insertion_point(field_mutable:osi3.BaseStationary.orientation)
  return _msg;
}
inline void BaseStationary::set_allocated_orientation(::osi3::Orientation3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.orientation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.orientation_ = reinterpret_cast<::osi3::Orientation3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.BaseStationary.orientation)
}

// repeated .osi3.Vector2d base_polygon = 4;
inline int BaseStationary::_internal_base_polygon_size() const {
  return _internal_base_polygon().size();
}
inline int BaseStationary::base_polygon_size() const {
  return _internal_base_polygon_size();
}
inline void BaseStationary::clear_base_polygon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.base_polygon_.Clear();
}
inline ::osi3::Vector2d* BaseStationary::mutable_base_polygon(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.BaseStationary.base_polygon)
  return _internal_mutable_base_polygon()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::Vector2d>* BaseStationary::mutable_base_polygon()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.BaseStationary.base_polygon)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_base_polygon();
}
inline const ::osi3::Vector2d& BaseStationary::base_polygon(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.BaseStationary.base_polygon)
  return _internal_base_polygon().Get(index);
}
inline ::osi3::Vector2d* BaseStationary::add_base_polygon() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::Vector2d* _add = _internal_mutable_base_polygon()->Add();
  // @@protoc_insertion_point(field_add:osi3.BaseStationary.base_polygon)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::Vector2d>& BaseStationary::base_polygon() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.BaseStationary.base_polygon)
  return _internal_base_polygon();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::Vector2d>&
BaseStationary::_internal_base_polygon() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.base_polygon_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::Vector2d>*
BaseStationary::_internal_mutable_base_polygon() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.base_polygon_;
}

// -------------------------------------------------------------------

// BaseMoving

// optional .osi3.Dimension3d dimension = 1;
inline bool BaseMoving::has_dimension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dimension_ != nullptr);
  return value;
}
inline void BaseMoving::clear_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dimension_ != nullptr) _impl_.dimension_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::osi3::Dimension3d& BaseMoving::_internal_dimension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Dimension3d* p = _impl_.dimension_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Dimension3d&>(::osi3::_Dimension3d_default_instance_);
}
inline const ::osi3::Dimension3d& BaseMoving::dimension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.BaseMoving.dimension)
  return _internal_dimension();
}
inline void BaseMoving::unsafe_arena_set_allocated_dimension(::osi3::Dimension3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dimension_);
  }
  _impl_.dimension_ = reinterpret_cast<::osi3::Dimension3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.BaseMoving.dimension)
}
inline ::osi3::Dimension3d* BaseMoving::release_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Dimension3d* released = _impl_.dimension_;
  _impl_.dimension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Dimension3d* BaseMoving::unsafe_arena_release_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.BaseMoving.dimension)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Dimension3d* temp = _impl_.dimension_;
  _impl_.dimension_ = nullptr;
  return temp;
}
inline ::osi3::Dimension3d* BaseMoving::_internal_mutable_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dimension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Dimension3d>(GetArena());
    _impl_.dimension_ = reinterpret_cast<::osi3::Dimension3d*>(p);
  }
  return _impl_.dimension_;
}
inline ::osi3::Dimension3d* BaseMoving::mutable_dimension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::Dimension3d* _msg = _internal_mutable_dimension();
  // @@protoc_insertion_point(field_mutable:osi3.BaseMoving.dimension)
  return _msg;
}
inline void BaseMoving::set_allocated_dimension(::osi3::Dimension3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dimension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dimension_ = reinterpret_cast<::osi3::Dimension3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.BaseMoving.dimension)
}

// optional .osi3.Vector3d position = 2;
inline bool BaseMoving::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void BaseMoving::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::osi3::Vector3d& BaseMoving::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Vector3d* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Vector3d&>(::osi3::_Vector3d_default_instance_);
}
inline const ::osi3::Vector3d& BaseMoving::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.BaseMoving.position)
  return _internal_position();
}
inline void BaseMoving::unsafe_arena_set_allocated_position(::osi3::Vector3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::osi3::Vector3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.BaseMoving.position)
}
inline ::osi3::Vector3d* BaseMoving::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Vector3d* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Vector3d* BaseMoving::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.BaseMoving.position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Vector3d* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::osi3::Vector3d* BaseMoving::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Vector3d>(GetArena());
    _impl_.position_ = reinterpret_cast<::osi3::Vector3d*>(p);
  }
  return _impl_.position_;
}
inline ::osi3::Vector3d* BaseMoving::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::osi3::Vector3d* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:osi3.BaseMoving.position)
  return _msg;
}
inline void BaseMoving::set_allocated_position(::osi3::Vector3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.position_ = reinterpret_cast<::osi3::Vector3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.BaseMoving.position)
}

// optional .osi3.Orientation3d orientation = 3;
inline bool BaseMoving::has_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orientation_ != nullptr);
  return value;
}
inline void BaseMoving::clear_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_ != nullptr) _impl_.orientation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::osi3::Orientation3d& BaseMoving::_internal_orientation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Orientation3d* p = _impl_.orientation_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Orientation3d&>(::osi3::_Orientation3d_default_instance_);
}
inline const ::osi3::Orientation3d& BaseMoving::orientation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.BaseMoving.orientation)
  return _internal_orientation();
}
inline void BaseMoving::unsafe_arena_set_allocated_orientation(::osi3::Orientation3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_);
  }
  _impl_.orientation_ = reinterpret_cast<::osi3::Orientation3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.BaseMoving.orientation)
}
inline ::osi3::Orientation3d* BaseMoving::release_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::Orientation3d* released = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Orientation3d* BaseMoving::unsafe_arena_release_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.BaseMoving.orientation)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::Orientation3d* temp = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
  return temp;
}
inline ::osi3::Orientation3d* BaseMoving::_internal_mutable_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Orientation3d>(GetArena());
    _impl_.orientation_ = reinterpret_cast<::osi3::Orientation3d*>(p);
  }
  return _impl_.orientation_;
}
inline ::osi3::Orientation3d* BaseMoving::mutable_orientation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::osi3::Orientation3d* _msg = _internal_mutable_orientation();
  // @@protoc_insertion_point(field_mutable:osi3.BaseMoving.orientation)
  return _msg;
}
inline void BaseMoving::set_allocated_orientation(::osi3::Orientation3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.orientation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.orientation_ = reinterpret_cast<::osi3::Orientation3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.BaseMoving.orientation)
}

// optional .osi3.Vector3d velocity = 4;
inline bool BaseMoving::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void BaseMoving::clear_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::osi3::Vector3d& BaseMoving::_internal_velocity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Vector3d* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Vector3d&>(::osi3::_Vector3d_default_instance_);
}
inline const ::osi3::Vector3d& BaseMoving::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.BaseMoving.velocity)
  return _internal_velocity();
}
inline void BaseMoving::unsafe_arena_set_allocated_velocity(::osi3::Vector3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::osi3::Vector3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.BaseMoving.velocity)
}
inline ::osi3::Vector3d* BaseMoving::release_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::osi3::Vector3d* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Vector3d* BaseMoving::unsafe_arena_release_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.BaseMoving.velocity)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::osi3::Vector3d* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::osi3::Vector3d* BaseMoving::_internal_mutable_velocity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.velocity_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Vector3d>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::osi3::Vector3d*>(p);
  }
  return _impl_.velocity_;
}
inline ::osi3::Vector3d* BaseMoving::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::osi3::Vector3d* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:osi3.BaseMoving.velocity)
  return _msg;
}
inline void BaseMoving::set_allocated_velocity(::osi3::Vector3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.velocity_ = reinterpret_cast<::osi3::Vector3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.BaseMoving.velocity)
}

// optional .osi3.Vector3d acceleration = 5;
inline bool BaseMoving::has_acceleration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.acceleration_ != nullptr);
  return value;
}
inline void BaseMoving::clear_acceleration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.acceleration_ != nullptr) _impl_.acceleration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::osi3::Vector3d& BaseMoving::_internal_acceleration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Vector3d* p = _impl_.acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Vector3d&>(::osi3::_Vector3d_default_instance_);
}
inline const ::osi3::Vector3d& BaseMoving::acceleration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.BaseMoving.acceleration)
  return _internal_acceleration();
}
inline void BaseMoving::unsafe_arena_set_allocated_acceleration(::osi3::Vector3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.acceleration_);
  }
  _impl_.acceleration_ = reinterpret_cast<::osi3::Vector3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.BaseMoving.acceleration)
}
inline ::osi3::Vector3d* BaseMoving::release_acceleration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::osi3::Vector3d* released = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Vector3d* BaseMoving::unsafe_arena_release_acceleration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.BaseMoving.acceleration)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::osi3::Vector3d* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
  return temp;
}
inline ::osi3::Vector3d* BaseMoving::_internal_mutable_acceleration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.acceleration_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Vector3d>(GetArena());
    _impl_.acceleration_ = reinterpret_cast<::osi3::Vector3d*>(p);
  }
  return _impl_.acceleration_;
}
inline ::osi3::Vector3d* BaseMoving::mutable_acceleration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::osi3::Vector3d* _msg = _internal_mutable_acceleration();
  // @@protoc_insertion_point(field_mutable:osi3.BaseMoving.acceleration)
  return _msg;
}
inline void BaseMoving::set_allocated_acceleration(::osi3::Vector3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.acceleration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.acceleration_ = reinterpret_cast<::osi3::Vector3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.BaseMoving.acceleration)
}

// optional .osi3.Orientation3d orientation_rate = 6;
inline bool BaseMoving::has_orientation_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orientation_rate_ != nullptr);
  return value;
}
inline void BaseMoving::clear_orientation_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_rate_ != nullptr) _impl_.orientation_rate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::osi3::Orientation3d& BaseMoving::_internal_orientation_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Orientation3d* p = _impl_.orientation_rate_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Orientation3d&>(::osi3::_Orientation3d_default_instance_);
}
inline const ::osi3::Orientation3d& BaseMoving::orientation_rate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.BaseMoving.orientation_rate)
  return _internal_orientation_rate();
}
inline void BaseMoving::unsafe_arena_set_allocated_orientation_rate(::osi3::Orientation3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_rate_);
  }
  _impl_.orientation_rate_ = reinterpret_cast<::osi3::Orientation3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.BaseMoving.orientation_rate)
}
inline ::osi3::Orientation3d* BaseMoving::release_orientation_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::osi3::Orientation3d* released = _impl_.orientation_rate_;
  _impl_.orientation_rate_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Orientation3d* BaseMoving::unsafe_arena_release_orientation_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.BaseMoving.orientation_rate)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::osi3::Orientation3d* temp = _impl_.orientation_rate_;
  _impl_.orientation_rate_ = nullptr;
  return temp;
}
inline ::osi3::Orientation3d* BaseMoving::_internal_mutable_orientation_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_rate_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Orientation3d>(GetArena());
    _impl_.orientation_rate_ = reinterpret_cast<::osi3::Orientation3d*>(p);
  }
  return _impl_.orientation_rate_;
}
inline ::osi3::Orientation3d* BaseMoving::mutable_orientation_rate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::osi3::Orientation3d* _msg = _internal_mutable_orientation_rate();
  // @@protoc_insertion_point(field_mutable:osi3.BaseMoving.orientation_rate)
  return _msg;
}
inline void BaseMoving::set_allocated_orientation_rate(::osi3::Orientation3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.orientation_rate_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.orientation_rate_ = reinterpret_cast<::osi3::Orientation3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.BaseMoving.orientation_rate)
}

// optional .osi3.Orientation3d orientation_acceleration = 8;
inline bool BaseMoving::has_orientation_acceleration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orientation_acceleration_ != nullptr);
  return value;
}
inline void BaseMoving::clear_orientation_acceleration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_acceleration_ != nullptr) _impl_.orientation_acceleration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::osi3::Orientation3d& BaseMoving::_internal_orientation_acceleration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Orientation3d* p = _impl_.orientation_acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Orientation3d&>(::osi3::_Orientation3d_default_instance_);
}
inline const ::osi3::Orientation3d& BaseMoving::orientation_acceleration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.BaseMoving.orientation_acceleration)
  return _internal_orientation_acceleration();
}
inline void BaseMoving::unsafe_arena_set_allocated_orientation_acceleration(::osi3::Orientation3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_acceleration_);
  }
  _impl_.orientation_acceleration_ = reinterpret_cast<::osi3::Orientation3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.BaseMoving.orientation_acceleration)
}
inline ::osi3::Orientation3d* BaseMoving::release_orientation_acceleration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::osi3::Orientation3d* released = _impl_.orientation_acceleration_;
  _impl_.orientation_acceleration_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Orientation3d* BaseMoving::unsafe_arena_release_orientation_acceleration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.BaseMoving.orientation_acceleration)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::osi3::Orientation3d* temp = _impl_.orientation_acceleration_;
  _impl_.orientation_acceleration_ = nullptr;
  return temp;
}
inline ::osi3::Orientation3d* BaseMoving::_internal_mutable_orientation_acceleration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_acceleration_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Orientation3d>(GetArena());
    _impl_.orientation_acceleration_ = reinterpret_cast<::osi3::Orientation3d*>(p);
  }
  return _impl_.orientation_acceleration_;
}
inline ::osi3::Orientation3d* BaseMoving::mutable_orientation_acceleration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::osi3::Orientation3d* _msg = _internal_mutable_orientation_acceleration();
  // @@protoc_insertion_point(field_mutable:osi3.BaseMoving.orientation_acceleration)
  return _msg;
}
inline void BaseMoving::set_allocated_orientation_acceleration(::osi3::Orientation3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.orientation_acceleration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.orientation_acceleration_ = reinterpret_cast<::osi3::Orientation3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.BaseMoving.orientation_acceleration)
}

// repeated .osi3.Vector2d base_polygon = 7;
inline int BaseMoving::_internal_base_polygon_size() const {
  return _internal_base_polygon().size();
}
inline int BaseMoving::base_polygon_size() const {
  return _internal_base_polygon_size();
}
inline void BaseMoving::clear_base_polygon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.base_polygon_.Clear();
}
inline ::osi3::Vector2d* BaseMoving::mutable_base_polygon(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:osi3.BaseMoving.base_polygon)
  return _internal_mutable_base_polygon()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::osi3::Vector2d>* BaseMoving::mutable_base_polygon()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:osi3.BaseMoving.base_polygon)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_base_polygon();
}
inline const ::osi3::Vector2d& BaseMoving::base_polygon(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.BaseMoving.base_polygon)
  return _internal_base_polygon().Get(index);
}
inline ::osi3::Vector2d* BaseMoving::add_base_polygon() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::osi3::Vector2d* _add = _internal_mutable_base_polygon()->Add();
  // @@protoc_insertion_point(field_add:osi3.BaseMoving.base_polygon)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::Vector2d>& BaseMoving::base_polygon() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:osi3.BaseMoving.base_polygon)
  return _internal_base_polygon();
}
inline const ::google::protobuf::RepeatedPtrField<::osi3::Vector2d>&
BaseMoving::_internal_base_polygon() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.base_polygon_;
}
inline ::google::protobuf::RepeatedPtrField<::osi3::Vector2d>*
BaseMoving::_internal_mutable_base_polygon() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.base_polygon_;
}

// -------------------------------------------------------------------

// StatePoint

// optional .osi3.Timestamp timestamp = 1;
inline bool StatePoint::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline void StatePoint::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.timestamp_ != nullptr) _impl_.timestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::osi3::Timestamp& StatePoint::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Timestamp&>(::osi3::_Timestamp_default_instance_);
}
inline const ::osi3::Timestamp& StatePoint::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.StatePoint.timestamp)
  return _internal_timestamp();
}
inline void StatePoint::unsafe_arena_set_allocated_timestamp(::osi3::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::osi3::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.StatePoint.timestamp)
}
inline ::osi3::Timestamp* StatePoint::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Timestamp* StatePoint::unsafe_arena_release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.StatePoint.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::osi3::Timestamp* StatePoint::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.timestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::osi3::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::osi3::Timestamp* StatePoint::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:osi3.StatePoint.timestamp)
  return _msg;
}
inline void StatePoint::set_allocated_timestamp(::osi3::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::osi3::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.StatePoint.timestamp)
}

// optional .osi3.Vector3d position = 2;
inline bool StatePoint::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void StatePoint::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::osi3::Vector3d& StatePoint::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Vector3d* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Vector3d&>(::osi3::_Vector3d_default_instance_);
}
inline const ::osi3::Vector3d& StatePoint::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.StatePoint.position)
  return _internal_position();
}
inline void StatePoint::unsafe_arena_set_allocated_position(::osi3::Vector3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::osi3::Vector3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.StatePoint.position)
}
inline ::osi3::Vector3d* StatePoint::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Vector3d* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Vector3d* StatePoint::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.StatePoint.position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::Vector3d* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::osi3::Vector3d* StatePoint::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Vector3d>(GetArena());
    _impl_.position_ = reinterpret_cast<::osi3::Vector3d*>(p);
  }
  return _impl_.position_;
}
inline ::osi3::Vector3d* StatePoint::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::osi3::Vector3d* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:osi3.StatePoint.position)
  return _msg;
}
inline void StatePoint::set_allocated_position(::osi3::Vector3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.position_ = reinterpret_cast<::osi3::Vector3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.StatePoint.position)
}

// optional .osi3.Orientation3d orientation = 3;
inline bool StatePoint::has_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orientation_ != nullptr);
  return value;
}
inline void StatePoint::clear_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_ != nullptr) _impl_.orientation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::osi3::Orientation3d& StatePoint::_internal_orientation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::Orientation3d* p = _impl_.orientation_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::Orientation3d&>(::osi3::_Orientation3d_default_instance_);
}
inline const ::osi3::Orientation3d& StatePoint::orientation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.StatePoint.orientation)
  return _internal_orientation();
}
inline void StatePoint::unsafe_arena_set_allocated_orientation(::osi3::Orientation3d* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_);
  }
  _impl_.orientation_ = reinterpret_cast<::osi3::Orientation3d*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.StatePoint.orientation)
}
inline ::osi3::Orientation3d* StatePoint::release_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::Orientation3d* released = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::Orientation3d* StatePoint::unsafe_arena_release_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.StatePoint.orientation)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::Orientation3d* temp = _impl_.orientation_;
  _impl_.orientation_ = nullptr;
  return temp;
}
inline ::osi3::Orientation3d* StatePoint::_internal_mutable_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.orientation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::Orientation3d>(GetArena());
    _impl_.orientation_ = reinterpret_cast<::osi3::Orientation3d*>(p);
  }
  return _impl_.orientation_;
}
inline ::osi3::Orientation3d* StatePoint::mutable_orientation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::osi3::Orientation3d* _msg = _internal_mutable_orientation();
  // @@protoc_insertion_point(field_mutable:osi3.StatePoint.orientation)
  return _msg;
}
inline void StatePoint::set_allocated_orientation(::osi3::Orientation3d* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.orientation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.orientation_ = reinterpret_cast<::osi3::Orientation3d*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.StatePoint.orientation)
}

// -------------------------------------------------------------------

// WavelengthData

// optional double start = 1;
inline bool WavelengthData::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void WavelengthData::clear_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double WavelengthData::start() const {
  // @@protoc_insertion_point(field_get:osi3.WavelengthData.start)
  return _internal_start();
}
inline void WavelengthData::set_start(double value) {
  _internal_set_start(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.WavelengthData.start)
}
inline double WavelengthData::_internal_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_;
}
inline void WavelengthData::_internal_set_start(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_ = value;
}

// optional double end = 2;
inline bool WavelengthData::has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void WavelengthData::clear_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double WavelengthData::end() const {
  // @@protoc_insertion_point(field_get:osi3.WavelengthData.end)
  return _internal_end();
}
inline void WavelengthData::set_end(double value) {
  _internal_set_end(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.WavelengthData.end)
}
inline double WavelengthData::_internal_end() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.end_;
}
inline void WavelengthData::_internal_set_end(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_ = value;
}

// optional double samples_number = 3;
inline bool WavelengthData::has_samples_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void WavelengthData::clear_samples_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.samples_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double WavelengthData::samples_number() const {
  // @@protoc_insertion_point(field_get:osi3.WavelengthData.samples_number)
  return _internal_samples_number();
}
inline void WavelengthData::set_samples_number(double value) {
  _internal_set_samples_number(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.WavelengthData.samples_number)
}
inline double WavelengthData::_internal_samples_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.samples_number_;
}
inline void WavelengthData::_internal_set_samples_number(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.samples_number_ = value;
}

// -------------------------------------------------------------------

// SpatialSignalStrength

// optional double horizontal_angle = 1;
inline bool SpatialSignalStrength::has_horizontal_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SpatialSignalStrength::clear_horizontal_angle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.horizontal_angle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double SpatialSignalStrength::horizontal_angle() const {
  // @@protoc_insertion_point(field_get:osi3.SpatialSignalStrength.horizontal_angle)
  return _internal_horizontal_angle();
}
inline void SpatialSignalStrength::set_horizontal_angle(double value) {
  _internal_set_horizontal_angle(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.SpatialSignalStrength.horizontal_angle)
}
inline double SpatialSignalStrength::_internal_horizontal_angle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.horizontal_angle_;
}
inline void SpatialSignalStrength::_internal_set_horizontal_angle(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.horizontal_angle_ = value;
}

// optional double vertical_angle = 2;
inline bool SpatialSignalStrength::has_vertical_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SpatialSignalStrength::clear_vertical_angle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vertical_angle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double SpatialSignalStrength::vertical_angle() const {
  // @@protoc_insertion_point(field_get:osi3.SpatialSignalStrength.vertical_angle)
  return _internal_vertical_angle();
}
inline void SpatialSignalStrength::set_vertical_angle(double value) {
  _internal_set_vertical_angle(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.SpatialSignalStrength.vertical_angle)
}
inline double SpatialSignalStrength::_internal_vertical_angle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vertical_angle_;
}
inline void SpatialSignalStrength::_internal_set_vertical_angle(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vertical_angle_ = value;
}

// optional double signal_strength = 3;
inline bool SpatialSignalStrength::has_signal_strength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SpatialSignalStrength::clear_signal_strength() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signal_strength_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double SpatialSignalStrength::signal_strength() const {
  // @@protoc_insertion_point(field_get:osi3.SpatialSignalStrength.signal_strength)
  return _internal_signal_strength();
}
inline void SpatialSignalStrength::set_signal_strength(double value) {
  _internal_set_signal_strength(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.SpatialSignalStrength.signal_strength)
}
inline double SpatialSignalStrength::_internal_signal_strength() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signal_strength_;
}
inline void SpatialSignalStrength::_internal_set_signal_strength(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signal_strength_ = value;
}

// -------------------------------------------------------------------

// ColorDescription

// optional .osi3.ColorGrey grey = 1;
inline bool ColorDescription::has_grey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.grey_ != nullptr);
  return value;
}
inline void ColorDescription::clear_grey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.grey_ != nullptr) _impl_.grey_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::osi3::ColorGrey& ColorDescription::_internal_grey() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::ColorGrey* p = _impl_.grey_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::ColorGrey&>(::osi3::_ColorGrey_default_instance_);
}
inline const ::osi3::ColorGrey& ColorDescription::grey() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.ColorDescription.grey)
  return _internal_grey();
}
inline void ColorDescription::unsafe_arena_set_allocated_grey(::osi3::ColorGrey* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.grey_);
  }
  _impl_.grey_ = reinterpret_cast<::osi3::ColorGrey*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.ColorDescription.grey)
}
inline ::osi3::ColorGrey* ColorDescription::release_grey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::ColorGrey* released = _impl_.grey_;
  _impl_.grey_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::ColorGrey* ColorDescription::unsafe_arena_release_grey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.ColorDescription.grey)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::osi3::ColorGrey* temp = _impl_.grey_;
  _impl_.grey_ = nullptr;
  return temp;
}
inline ::osi3::ColorGrey* ColorDescription::_internal_mutable_grey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.grey_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::ColorGrey>(GetArena());
    _impl_.grey_ = reinterpret_cast<::osi3::ColorGrey*>(p);
  }
  return _impl_.grey_;
}
inline ::osi3::ColorGrey* ColorDescription::mutable_grey() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::osi3::ColorGrey* _msg = _internal_mutable_grey();
  // @@protoc_insertion_point(field_mutable:osi3.ColorDescription.grey)
  return _msg;
}
inline void ColorDescription::set_allocated_grey(::osi3::ColorGrey* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.grey_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.grey_ = reinterpret_cast<::osi3::ColorGrey*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.ColorDescription.grey)
}

// optional .osi3.ColorRGB rgb = 2;
inline bool ColorDescription::has_rgb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rgb_ != nullptr);
  return value;
}
inline void ColorDescription::clear_rgb() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rgb_ != nullptr) _impl_.rgb_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::osi3::ColorRGB& ColorDescription::_internal_rgb() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::ColorRGB* p = _impl_.rgb_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::ColorRGB&>(::osi3::_ColorRGB_default_instance_);
}
inline const ::osi3::ColorRGB& ColorDescription::rgb() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.ColorDescription.rgb)
  return _internal_rgb();
}
inline void ColorDescription::unsafe_arena_set_allocated_rgb(::osi3::ColorRGB* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rgb_);
  }
  _impl_.rgb_ = reinterpret_cast<::osi3::ColorRGB*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.ColorDescription.rgb)
}
inline ::osi3::ColorRGB* ColorDescription::release_rgb() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::ColorRGB* released = _impl_.rgb_;
  _impl_.rgb_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::ColorRGB* ColorDescription::unsafe_arena_release_rgb() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.ColorDescription.rgb)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::osi3::ColorRGB* temp = _impl_.rgb_;
  _impl_.rgb_ = nullptr;
  return temp;
}
inline ::osi3::ColorRGB* ColorDescription::_internal_mutable_rgb() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rgb_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::ColorRGB>(GetArena());
    _impl_.rgb_ = reinterpret_cast<::osi3::ColorRGB*>(p);
  }
  return _impl_.rgb_;
}
inline ::osi3::ColorRGB* ColorDescription::mutable_rgb() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::osi3::ColorRGB* _msg = _internal_mutable_rgb();
  // @@protoc_insertion_point(field_mutable:osi3.ColorDescription.rgb)
  return _msg;
}
inline void ColorDescription::set_allocated_rgb(::osi3::ColorRGB* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rgb_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rgb_ = reinterpret_cast<::osi3::ColorRGB*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.ColorDescription.rgb)
}

// optional .osi3.ColorRGBIR rgbir = 3;
inline bool ColorDescription::has_rgbir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rgbir_ != nullptr);
  return value;
}
inline void ColorDescription::clear_rgbir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rgbir_ != nullptr) _impl_.rgbir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::osi3::ColorRGBIR& ColorDescription::_internal_rgbir() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::ColorRGBIR* p = _impl_.rgbir_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::ColorRGBIR&>(::osi3::_ColorRGBIR_default_instance_);
}
inline const ::osi3::ColorRGBIR& ColorDescription::rgbir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.ColorDescription.rgbir)
  return _internal_rgbir();
}
inline void ColorDescription::unsafe_arena_set_allocated_rgbir(::osi3::ColorRGBIR* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rgbir_);
  }
  _impl_.rgbir_ = reinterpret_cast<::osi3::ColorRGBIR*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.ColorDescription.rgbir)
}
inline ::osi3::ColorRGBIR* ColorDescription::release_rgbir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::ColorRGBIR* released = _impl_.rgbir_;
  _impl_.rgbir_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::ColorRGBIR* ColorDescription::unsafe_arena_release_rgbir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.ColorDescription.rgbir)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::osi3::ColorRGBIR* temp = _impl_.rgbir_;
  _impl_.rgbir_ = nullptr;
  return temp;
}
inline ::osi3::ColorRGBIR* ColorDescription::_internal_mutable_rgbir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rgbir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::ColorRGBIR>(GetArena());
    _impl_.rgbir_ = reinterpret_cast<::osi3::ColorRGBIR*>(p);
  }
  return _impl_.rgbir_;
}
inline ::osi3::ColorRGBIR* ColorDescription::mutable_rgbir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::osi3::ColorRGBIR* _msg = _internal_mutable_rgbir();
  // @@protoc_insertion_point(field_mutable:osi3.ColorDescription.rgbir)
  return _msg;
}
inline void ColorDescription::set_allocated_rgbir(::osi3::ColorRGBIR* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rgbir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.rgbir_ = reinterpret_cast<::osi3::ColorRGBIR*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.ColorDescription.rgbir)
}

// optional .osi3.ColorHSV hsv = 4;
inline bool ColorDescription::has_hsv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hsv_ != nullptr);
  return value;
}
inline void ColorDescription::clear_hsv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hsv_ != nullptr) _impl_.hsv_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::osi3::ColorHSV& ColorDescription::_internal_hsv() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::ColorHSV* p = _impl_.hsv_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::ColorHSV&>(::osi3::_ColorHSV_default_instance_);
}
inline const ::osi3::ColorHSV& ColorDescription::hsv() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.ColorDescription.hsv)
  return _internal_hsv();
}
inline void ColorDescription::unsafe_arena_set_allocated_hsv(::osi3::ColorHSV* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hsv_);
  }
  _impl_.hsv_ = reinterpret_cast<::osi3::ColorHSV*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.ColorDescription.hsv)
}
inline ::osi3::ColorHSV* ColorDescription::release_hsv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::osi3::ColorHSV* released = _impl_.hsv_;
  _impl_.hsv_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::ColorHSV* ColorDescription::unsafe_arena_release_hsv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.ColorDescription.hsv)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::osi3::ColorHSV* temp = _impl_.hsv_;
  _impl_.hsv_ = nullptr;
  return temp;
}
inline ::osi3::ColorHSV* ColorDescription::_internal_mutable_hsv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hsv_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::ColorHSV>(GetArena());
    _impl_.hsv_ = reinterpret_cast<::osi3::ColorHSV*>(p);
  }
  return _impl_.hsv_;
}
inline ::osi3::ColorHSV* ColorDescription::mutable_hsv() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::osi3::ColorHSV* _msg = _internal_mutable_hsv();
  // @@protoc_insertion_point(field_mutable:osi3.ColorDescription.hsv)
  return _msg;
}
inline void ColorDescription::set_allocated_hsv(::osi3::ColorHSV* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.hsv_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.hsv_ = reinterpret_cast<::osi3::ColorHSV*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.ColorDescription.hsv)
}

// optional .osi3.ColorLUV luv = 5;
inline bool ColorDescription::has_luv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.luv_ != nullptr);
  return value;
}
inline void ColorDescription::clear_luv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.luv_ != nullptr) _impl_.luv_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::osi3::ColorLUV& ColorDescription::_internal_luv() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::ColorLUV* p = _impl_.luv_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::ColorLUV&>(::osi3::_ColorLUV_default_instance_);
}
inline const ::osi3::ColorLUV& ColorDescription::luv() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.ColorDescription.luv)
  return _internal_luv();
}
inline void ColorDescription::unsafe_arena_set_allocated_luv(::osi3::ColorLUV* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.luv_);
  }
  _impl_.luv_ = reinterpret_cast<::osi3::ColorLUV*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.ColorDescription.luv)
}
inline ::osi3::ColorLUV* ColorDescription::release_luv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::osi3::ColorLUV* released = _impl_.luv_;
  _impl_.luv_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::ColorLUV* ColorDescription::unsafe_arena_release_luv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.ColorDescription.luv)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::osi3::ColorLUV* temp = _impl_.luv_;
  _impl_.luv_ = nullptr;
  return temp;
}
inline ::osi3::ColorLUV* ColorDescription::_internal_mutable_luv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.luv_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::ColorLUV>(GetArena());
    _impl_.luv_ = reinterpret_cast<::osi3::ColorLUV*>(p);
  }
  return _impl_.luv_;
}
inline ::osi3::ColorLUV* ColorDescription::mutable_luv() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::osi3::ColorLUV* _msg = _internal_mutable_luv();
  // @@protoc_insertion_point(field_mutable:osi3.ColorDescription.luv)
  return _msg;
}
inline void ColorDescription::set_allocated_luv(::osi3::ColorLUV* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.luv_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.luv_ = reinterpret_cast<::osi3::ColorLUV*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.ColorDescription.luv)
}

// optional .osi3.ColorCMYK cmyk = 6;
inline bool ColorDescription::has_cmyk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cmyk_ != nullptr);
  return value;
}
inline void ColorDescription::clear_cmyk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cmyk_ != nullptr) _impl_.cmyk_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::osi3::ColorCMYK& ColorDescription::_internal_cmyk() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::osi3::ColorCMYK* p = _impl_.cmyk_;
  return p != nullptr ? *p : reinterpret_cast<const ::osi3::ColorCMYK&>(::osi3::_ColorCMYK_default_instance_);
}
inline const ::osi3::ColorCMYK& ColorDescription::cmyk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.ColorDescription.cmyk)
  return _internal_cmyk();
}
inline void ColorDescription::unsafe_arena_set_allocated_cmyk(::osi3::ColorCMYK* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cmyk_);
  }
  _impl_.cmyk_ = reinterpret_cast<::osi3::ColorCMYK*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:osi3.ColorDescription.cmyk)
}
inline ::osi3::ColorCMYK* ColorDescription::release_cmyk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::osi3::ColorCMYK* released = _impl_.cmyk_;
  _impl_.cmyk_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::osi3::ColorCMYK* ColorDescription::unsafe_arena_release_cmyk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.ColorDescription.cmyk)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::osi3::ColorCMYK* temp = _impl_.cmyk_;
  _impl_.cmyk_ = nullptr;
  return temp;
}
inline ::osi3::ColorCMYK* ColorDescription::_internal_mutable_cmyk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cmyk_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::osi3::ColorCMYK>(GetArena());
    _impl_.cmyk_ = reinterpret_cast<::osi3::ColorCMYK*>(p);
  }
  return _impl_.cmyk_;
}
inline ::osi3::ColorCMYK* ColorDescription::mutable_cmyk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::osi3::ColorCMYK* _msg = _internal_mutable_cmyk();
  // @@protoc_insertion_point(field_mutable:osi3.ColorDescription.cmyk)
  return _msg;
}
inline void ColorDescription::set_allocated_cmyk(::osi3::ColorCMYK* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.cmyk_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.cmyk_ = reinterpret_cast<::osi3::ColorCMYK*>(value);
  // @@protoc_insertion_point(field_set_allocated:osi3.ColorDescription.cmyk)
}

// -------------------------------------------------------------------

// ColorGrey

// optional double grey = 1;
inline bool ColorGrey::has_grey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ColorGrey::clear_grey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grey_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double ColorGrey::grey() const {
  // @@protoc_insertion_point(field_get:osi3.ColorGrey.grey)
  return _internal_grey();
}
inline void ColorGrey::set_grey(double value) {
  _internal_set_grey(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.ColorGrey.grey)
}
inline double ColorGrey::_internal_grey() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.grey_;
}
inline void ColorGrey::_internal_set_grey(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grey_ = value;
}

// -------------------------------------------------------------------

// ColorRGB

// optional double red = 1;
inline bool ColorRGB::has_red() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ColorRGB::clear_red() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.red_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double ColorRGB::red() const {
  // @@protoc_insertion_point(field_get:osi3.ColorRGB.red)
  return _internal_red();
}
inline void ColorRGB::set_red(double value) {
  _internal_set_red(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.ColorRGB.red)
}
inline double ColorRGB::_internal_red() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.red_;
}
inline void ColorRGB::_internal_set_red(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.red_ = value;
}

// optional double green = 2;
inline bool ColorRGB::has_green() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ColorRGB::clear_green() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.green_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ColorRGB::green() const {
  // @@protoc_insertion_point(field_get:osi3.ColorRGB.green)
  return _internal_green();
}
inline void ColorRGB::set_green(double value) {
  _internal_set_green(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.ColorRGB.green)
}
inline double ColorRGB::_internal_green() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.green_;
}
inline void ColorRGB::_internal_set_green(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.green_ = value;
}

// optional double blue = 3;
inline bool ColorRGB::has_blue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ColorRGB::clear_blue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ColorRGB::blue() const {
  // @@protoc_insertion_point(field_get:osi3.ColorRGB.blue)
  return _internal_blue();
}
inline void ColorRGB::set_blue(double value) {
  _internal_set_blue(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.ColorRGB.blue)
}
inline double ColorRGB::_internal_blue() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blue_;
}
inline void ColorRGB::_internal_set_blue(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blue_ = value;
}

// -------------------------------------------------------------------

// ColorRGBIR

// optional double red = 1;
inline bool ColorRGBIR::has_red() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ColorRGBIR::clear_red() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.red_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double ColorRGBIR::red() const {
  // @@protoc_insertion_point(field_get:osi3.ColorRGBIR.red)
  return _internal_red();
}
inline void ColorRGBIR::set_red(double value) {
  _internal_set_red(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.ColorRGBIR.red)
}
inline double ColorRGBIR::_internal_red() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.red_;
}
inline void ColorRGBIR::_internal_set_red(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.red_ = value;
}

// optional double green = 2;
inline bool ColorRGBIR::has_green() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ColorRGBIR::clear_green() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.green_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ColorRGBIR::green() const {
  // @@protoc_insertion_point(field_get:osi3.ColorRGBIR.green)
  return _internal_green();
}
inline void ColorRGBIR::set_green(double value) {
  _internal_set_green(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.ColorRGBIR.green)
}
inline double ColorRGBIR::_internal_green() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.green_;
}
inline void ColorRGBIR::_internal_set_green(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.green_ = value;
}

// optional double blue = 3;
inline bool ColorRGBIR::has_blue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ColorRGBIR::clear_blue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ColorRGBIR::blue() const {
  // @@protoc_insertion_point(field_get:osi3.ColorRGBIR.blue)
  return _internal_blue();
}
inline void ColorRGBIR::set_blue(double value) {
  _internal_set_blue(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.ColorRGBIR.blue)
}
inline double ColorRGBIR::_internal_blue() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blue_;
}
inline void ColorRGBIR::_internal_set_blue(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blue_ = value;
}

// optional double infrared = 4;
inline bool ColorRGBIR::has_infrared() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ColorRGBIR::clear_infrared() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.infrared_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double ColorRGBIR::infrared() const {
  // @@protoc_insertion_point(field_get:osi3.ColorRGBIR.infrared)
  return _internal_infrared();
}
inline void ColorRGBIR::set_infrared(double value) {
  _internal_set_infrared(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:osi3.ColorRGBIR.infrared)
}
inline double ColorRGBIR::_internal_infrared() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.infrared_;
}
inline void ColorRGBIR::_internal_set_infrared(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.infrared_ = value;
}

// -------------------------------------------------------------------

// ColorHSV

// optional double hue = 1;
inline bool ColorHSV::has_hue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ColorHSV::clear_hue() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double ColorHSV::hue() const {
  // @@protoc_insertion_point(field_get:osi3.ColorHSV.hue)
  return _internal_hue();
}
inline void ColorHSV::set_hue(double value) {
  _internal_set_hue(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.ColorHSV.hue)
}
inline double ColorHSV::_internal_hue() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hue_;
}
inline void ColorHSV::_internal_set_hue(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hue_ = value;
}

// optional double saturation = 2;
inline bool ColorHSV::has_saturation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ColorHSV::clear_saturation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.saturation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ColorHSV::saturation() const {
  // @@protoc_insertion_point(field_get:osi3.ColorHSV.saturation)
  return _internal_saturation();
}
inline void ColorHSV::set_saturation(double value) {
  _internal_set_saturation(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.ColorHSV.saturation)
}
inline double ColorHSV::_internal_saturation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.saturation_;
}
inline void ColorHSV::_internal_set_saturation(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.saturation_ = value;
}

// optional double value = 3;
inline bool ColorHSV::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ColorHSV::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ColorHSV::value() const {
  // @@protoc_insertion_point(field_get:osi3.ColorHSV.value)
  return _internal_value();
}
inline void ColorHSV::set_value(double value) {
  _internal_set_value(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.ColorHSV.value)
}
inline double ColorHSV::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void ColorHSV::_internal_set_value(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ColorLUV

// optional double luminance = 1;
inline bool ColorLUV::has_luminance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ColorLUV::clear_luminance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.luminance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double ColorLUV::luminance() const {
  // @@protoc_insertion_point(field_get:osi3.ColorLUV.luminance)
  return _internal_luminance();
}
inline void ColorLUV::set_luminance(double value) {
  _internal_set_luminance(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.ColorLUV.luminance)
}
inline double ColorLUV::_internal_luminance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.luminance_;
}
inline void ColorLUV::_internal_set_luminance(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.luminance_ = value;
}

// optional double u = 2;
inline bool ColorLUV::has_u() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ColorLUV::clear_u() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.u_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ColorLUV::u() const {
  // @@protoc_insertion_point(field_get:osi3.ColorLUV.u)
  return _internal_u();
}
inline void ColorLUV::set_u(double value) {
  _internal_set_u(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.ColorLUV.u)
}
inline double ColorLUV::_internal_u() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.u_;
}
inline void ColorLUV::_internal_set_u(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.u_ = value;
}

// optional double v = 3;
inline bool ColorLUV::has_v() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ColorLUV::clear_v() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.v_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ColorLUV::v() const {
  // @@protoc_insertion_point(field_get:osi3.ColorLUV.v)
  return _internal_v();
}
inline void ColorLUV::set_v(double value) {
  _internal_set_v(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.ColorLUV.v)
}
inline double ColorLUV::_internal_v() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.v_;
}
inline void ColorLUV::_internal_set_v(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.v_ = value;
}

// -------------------------------------------------------------------

// ColorCMYK

// optional double cyan = 1;
inline bool ColorCMYK::has_cyan() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ColorCMYK::clear_cyan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cyan_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double ColorCMYK::cyan() const {
  // @@protoc_insertion_point(field_get:osi3.ColorCMYK.cyan)
  return _internal_cyan();
}
inline void ColorCMYK::set_cyan(double value) {
  _internal_set_cyan(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.ColorCMYK.cyan)
}
inline double ColorCMYK::_internal_cyan() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cyan_;
}
inline void ColorCMYK::_internal_set_cyan(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cyan_ = value;
}

// optional double magenta = 2;
inline bool ColorCMYK::has_magenta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ColorCMYK::clear_magenta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.magenta_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double ColorCMYK::magenta() const {
  // @@protoc_insertion_point(field_get:osi3.ColorCMYK.magenta)
  return _internal_magenta();
}
inline void ColorCMYK::set_magenta(double value) {
  _internal_set_magenta(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.ColorCMYK.magenta)
}
inline double ColorCMYK::_internal_magenta() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.magenta_;
}
inline void ColorCMYK::_internal_set_magenta(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.magenta_ = value;
}

// optional double yellow = 3;
inline bool ColorCMYK::has_yellow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ColorCMYK::clear_yellow() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.yellow_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double ColorCMYK::yellow() const {
  // @@protoc_insertion_point(field_get:osi3.ColorCMYK.yellow)
  return _internal_yellow();
}
inline void ColorCMYK::set_yellow(double value) {
  _internal_set_yellow(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.ColorCMYK.yellow)
}
inline double ColorCMYK::_internal_yellow() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.yellow_;
}
inline void ColorCMYK::_internal_set_yellow(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.yellow_ = value;
}

// optional double key = 4;
inline bool ColorCMYK::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ColorCMYK::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double ColorCMYK::key() const {
  // @@protoc_insertion_point(field_get:osi3.ColorCMYK.key)
  return _internal_key();
}
inline void ColorCMYK::set_key(double value) {
  _internal_set_key(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:osi3.ColorCMYK.key)
}
inline double ColorCMYK::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_;
}
inline void ColorCMYK::_internal_set_key(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_ = value;
}

// -------------------------------------------------------------------

// Pedalry

// optional double pedal_position_acceleration = 1;
inline bool Pedalry::has_pedal_position_acceleration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Pedalry::clear_pedal_position_acceleration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pedal_position_acceleration_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Pedalry::pedal_position_acceleration() const {
  // @@protoc_insertion_point(field_get:osi3.Pedalry.pedal_position_acceleration)
  return _internal_pedal_position_acceleration();
}
inline void Pedalry::set_pedal_position_acceleration(double value) {
  _internal_set_pedal_position_acceleration(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.Pedalry.pedal_position_acceleration)
}
inline double Pedalry::_internal_pedal_position_acceleration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pedal_position_acceleration_;
}
inline void Pedalry::_internal_set_pedal_position_acceleration(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pedal_position_acceleration_ = value;
}

// optional double pedal_position_brake = 2;
inline bool Pedalry::has_pedal_position_brake() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Pedalry::clear_pedal_position_brake() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pedal_position_brake_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Pedalry::pedal_position_brake() const {
  // @@protoc_insertion_point(field_get:osi3.Pedalry.pedal_position_brake)
  return _internal_pedal_position_brake();
}
inline void Pedalry::set_pedal_position_brake(double value) {
  _internal_set_pedal_position_brake(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.Pedalry.pedal_position_brake)
}
inline double Pedalry::_internal_pedal_position_brake() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pedal_position_brake_;
}
inline void Pedalry::_internal_set_pedal_position_brake(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pedal_position_brake_ = value;
}

// optional double pedal_position_clutch = 3;
inline bool Pedalry::has_pedal_position_clutch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Pedalry::clear_pedal_position_clutch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pedal_position_clutch_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Pedalry::pedal_position_clutch() const {
  // @@protoc_insertion_point(field_get:osi3.Pedalry.pedal_position_clutch)
  return _internal_pedal_position_clutch();
}
inline void Pedalry::set_pedal_position_clutch(double value) {
  _internal_set_pedal_position_clutch(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.Pedalry.pedal_position_clutch)
}
inline double Pedalry::_internal_pedal_position_clutch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pedal_position_clutch_;
}
inline void Pedalry::_internal_set_pedal_position_clutch(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pedal_position_clutch_ = value;
}

// -------------------------------------------------------------------

// VehicleSteeringWheel

// optional double angle = 1;
inline bool VehicleSteeringWheel::has_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VehicleSteeringWheel::clear_angle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.angle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double VehicleSteeringWheel::angle() const {
  // @@protoc_insertion_point(field_get:osi3.VehicleSteeringWheel.angle)
  return _internal_angle();
}
inline void VehicleSteeringWheel::set_angle(double value) {
  _internal_set_angle(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.VehicleSteeringWheel.angle)
}
inline double VehicleSteeringWheel::_internal_angle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.angle_;
}
inline void VehicleSteeringWheel::_internal_set_angle(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.angle_ = value;
}

// optional double angular_speed = 2;
inline bool VehicleSteeringWheel::has_angular_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VehicleSteeringWheel::clear_angular_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.angular_speed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double VehicleSteeringWheel::angular_speed() const {
  // @@protoc_insertion_point(field_get:osi3.VehicleSteeringWheel.angular_speed)
  return _internal_angular_speed();
}
inline void VehicleSteeringWheel::set_angular_speed(double value) {
  _internal_set_angular_speed(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.VehicleSteeringWheel.angular_speed)
}
inline double VehicleSteeringWheel::_internal_angular_speed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.angular_speed_;
}
inline void VehicleSteeringWheel::_internal_set_angular_speed(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.angular_speed_ = value;
}

// optional double torque = 3;
inline bool VehicleSteeringWheel::has_torque() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void VehicleSteeringWheel::clear_torque() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.torque_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double VehicleSteeringWheel::torque() const {
  // @@protoc_insertion_point(field_get:osi3.VehicleSteeringWheel.torque)
  return _internal_torque();
}
inline void VehicleSteeringWheel::set_torque(double value) {
  _internal_set_torque(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.VehicleSteeringWheel.torque)
}
inline double VehicleSteeringWheel::_internal_torque() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.torque_;
}
inline void VehicleSteeringWheel::_internal_set_torque(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.torque_ = value;
}

// -------------------------------------------------------------------

// GeodeticPosition

// optional double longitude = 1;
inline bool GeodeticPosition::has_longitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GeodeticPosition::clear_longitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double GeodeticPosition::longitude() const {
  // @@protoc_insertion_point(field_get:osi3.GeodeticPosition.longitude)
  return _internal_longitude();
}
inline void GeodeticPosition::set_longitude(double value) {
  _internal_set_longitude(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:osi3.GeodeticPosition.longitude)
}
inline double GeodeticPosition::_internal_longitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.longitude_;
}
inline void GeodeticPosition::_internal_set_longitude(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_ = value;
}

// optional double latitude = 2;
inline bool GeodeticPosition::has_latitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GeodeticPosition::clear_latitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double GeodeticPosition::latitude() const {
  // @@protoc_insertion_point(field_get:osi3.GeodeticPosition.latitude)
  return _internal_latitude();
}
inline void GeodeticPosition::set_latitude(double value) {
  _internal_set_latitude(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:osi3.GeodeticPosition.latitude)
}
inline double GeodeticPosition::_internal_latitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.latitude_;
}
inline void GeodeticPosition::_internal_set_latitude(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_ = value;
}

// optional double altitude = 3;
inline bool GeodeticPosition::has_altitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GeodeticPosition::clear_altitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.altitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double GeodeticPosition::altitude() const {
  // @@protoc_insertion_point(field_get:osi3.GeodeticPosition.altitude)
  return _internal_altitude();
}
inline void GeodeticPosition::set_altitude(double value) {
  _internal_set_altitude(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:osi3.GeodeticPosition.altitude)
}
inline double GeodeticPosition::_internal_altitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.altitude_;
}
inline void GeodeticPosition::_internal_set_altitude(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.altitude_ = value;
}

// -------------------------------------------------------------------

// KeyValuePair

// optional string key = 1;
inline bool KeyValuePair::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void KeyValuePair::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KeyValuePair::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.KeyValuePair.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyValuePair::set_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:osi3.KeyValuePair.key)
}
inline std::string* KeyValuePair::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:osi3.KeyValuePair.key)
  return _s;
}
inline const std::string& KeyValuePair::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void KeyValuePair::_internal_set_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* KeyValuePair::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* KeyValuePair::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.KeyValuePair.key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.key_.Set("", GetArena());
  }
  return released;
}
inline void KeyValuePair::set_allocated_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.KeyValuePair.key)
}

// optional string value = 2;
inline bool KeyValuePair::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void KeyValuePair::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KeyValuePair::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:osi3.KeyValuePair.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyValuePair::set_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:osi3.KeyValuePair.value)
}
inline std::string* KeyValuePair::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:osi3.KeyValuePair.value)
  return _s;
}
inline const std::string& KeyValuePair::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_.Get();
}
inline void KeyValuePair::_internal_set_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(value, GetArena());
}
inline std::string* KeyValuePair::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* KeyValuePair::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:osi3.KeyValuePair.value)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.value_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.value_.Set("", GetArena());
  }
  return released;
}
inline void KeyValuePair::set_allocated_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.KeyValuePair.value)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace osi3


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // osi_5fcommon_2eproto_2epb_2eh
