// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: osi_lane.proto
// Protobuf C++ Version: 5.29.5

#include "osi_lane.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace osi3 {

inline constexpr Lane_Classification_RoadCondition::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        surface_temperature_{0},
        surface_water_film_{0},
        surface_freezing_point_{0},
        surface_ice_{0},
        surface_roughness_{0},
        surface_texture_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Lane_Classification_RoadCondition::Lane_Classification_RoadCondition(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct Lane_Classification_RoadConditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Lane_Classification_RoadConditionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Lane_Classification_RoadConditionDefaultTypeInternal() {}
  union {
    Lane_Classification_RoadCondition _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Lane_Classification_RoadConditionDefaultTypeInternal _Lane_Classification_RoadCondition_default_instance_;

inline constexpr LaneBoundary_Classification::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        limiting_structure_id_{},
        type_{static_cast< ::osi3::LaneBoundary_Classification_Type >(0)},
        color_{static_cast< ::osi3::LaneBoundary_Classification_Color >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR LaneBoundary_Classification::LaneBoundary_Classification(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LaneBoundary_ClassificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LaneBoundary_ClassificationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LaneBoundary_ClassificationDefaultTypeInternal() {}
  union {
    LaneBoundary_Classification _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LaneBoundary_ClassificationDefaultTypeInternal _LaneBoundary_Classification_default_instance_;

inline constexpr LaneBoundary_BoundaryPoint::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        position_{nullptr},
        width_{0},
        height_{0},
        dash_{static_cast< ::osi3::LaneBoundary_BoundaryPoint_Dash >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR LaneBoundary_BoundaryPoint::LaneBoundary_BoundaryPoint(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LaneBoundary_BoundaryPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LaneBoundary_BoundaryPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LaneBoundary_BoundaryPointDefaultTypeInternal() {}
  union {
    LaneBoundary_BoundaryPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LaneBoundary_BoundaryPointDefaultTypeInternal _LaneBoundary_BoundaryPoint_default_instance_;

inline constexpr Lane_Classification_LanePairing::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        antecessor_lane_id_{nullptr},
        successor_lane_id_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR Lane_Classification_LanePairing::Lane_Classification_LanePairing(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct Lane_Classification_LanePairingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Lane_Classification_LanePairingDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Lane_Classification_LanePairingDefaultTypeInternal() {}
  union {
    Lane_Classification_LanePairing _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Lane_Classification_LanePairingDefaultTypeInternal _Lane_Classification_LanePairing_default_instance_;

inline constexpr LaneBoundary::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        boundary_line_{},
        source_reference_{},
        id_{nullptr},
        classification_{nullptr},
        color_description_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR LaneBoundary::LaneBoundary(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LaneBoundaryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LaneBoundaryDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LaneBoundaryDefaultTypeInternal() {}
  union {
    LaneBoundary _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LaneBoundaryDefaultTypeInternal _LaneBoundary_default_instance_;

inline constexpr Lane_Classification::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        centerline_{},
        left_adjacent_lane_id_{},
        right_adjacent_lane_id_{},
        lane_pairing_{},
        right_lane_boundary_id_{},
        left_lane_boundary_id_{},
        free_lane_boundary_id_{},
        road_condition_{nullptr},
        type_{static_cast< ::osi3::Lane_Classification_Type >(0)},
        is_host_vehicle_lane_{false},
        centerline_is_driving_direction_{false},
        subtype_{static_cast< ::osi3::Lane_Classification_Subtype >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR Lane_Classification::Lane_Classification(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct Lane_ClassificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Lane_ClassificationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Lane_ClassificationDefaultTypeInternal() {}
  union {
    Lane_Classification _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Lane_ClassificationDefaultTypeInternal _Lane_Classification_default_instance_;

inline constexpr Lane::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        source_reference_{},
        id_{nullptr},
        classification_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR Lane::Lane(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LaneDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LaneDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LaneDefaultTypeInternal() {}
  union {
    Lane _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LaneDefaultTypeInternal _Lane_default_instance_;
}  // namespace osi3
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_osi_5flane_2eproto[5];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_osi_5flane_2eproto = nullptr;
const ::uint32_t
    TableStruct_osi_5flane_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification_RoadCondition, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification_RoadCondition, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification_RoadCondition, _impl_.surface_temperature_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification_RoadCondition, _impl_.surface_water_film_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification_RoadCondition, _impl_.surface_freezing_point_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification_RoadCondition, _impl_.surface_ice_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification_RoadCondition, _impl_.surface_roughness_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification_RoadCondition, _impl_.surface_texture_),
        0,
        1,
        2,
        3,
        4,
        5,
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification_LanePairing, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification_LanePairing, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification_LanePairing, _impl_.antecessor_lane_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification_LanePairing, _impl_.successor_lane_id_),
        0,
        1,
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification, _impl_.type_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification, _impl_.is_host_vehicle_lane_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification, _impl_.centerline_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification, _impl_.centerline_is_driving_direction_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification, _impl_.left_adjacent_lane_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification, _impl_.right_adjacent_lane_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification, _impl_.lane_pairing_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification, _impl_.right_lane_boundary_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification, _impl_.left_lane_boundary_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification, _impl_.free_lane_boundary_id_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification, _impl_.road_condition_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane_Classification, _impl_.subtype_),
        1,
        2,
        ~0u,
        3,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        0,
        4,
        PROTOBUF_FIELD_OFFSET(::osi3::Lane, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::Lane, _impl_.id_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane, _impl_.classification_),
        PROTOBUF_FIELD_OFFSET(::osi3::Lane, _impl_.source_reference_),
        0,
        1,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary_BoundaryPoint, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary_BoundaryPoint, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary_BoundaryPoint, _impl_.position_),
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary_BoundaryPoint, _impl_.width_),
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary_BoundaryPoint, _impl_.height_),
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary_BoundaryPoint, _impl_.dash_),
        0,
        1,
        2,
        3,
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary_Classification, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary_Classification, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary_Classification, _impl_.type_),
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary_Classification, _impl_.color_),
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary_Classification, _impl_.limiting_structure_id_),
        0,
        1,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary, _impl_.id_),
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary, _impl_.boundary_line_),
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary, _impl_.classification_),
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary, _impl_.source_reference_),
        PROTOBUF_FIELD_OFFSET(::osi3::LaneBoundary, _impl_.color_description_),
        0,
        ~0u,
        1,
        ~0u,
        2,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, 14, -1, sizeof(::osi3::Lane_Classification_RoadCondition)},
        {20, 30, -1, sizeof(::osi3::Lane_Classification_LanePairing)},
        {32, 52, -1, sizeof(::osi3::Lane_Classification)},
        {64, 75, -1, sizeof(::osi3::Lane)},
        {78, 90, -1, sizeof(::osi3::LaneBoundary_BoundaryPoint)},
        {94, 105, -1, sizeof(::osi3::LaneBoundary_Classification)},
        {108, 121, -1, sizeof(::osi3::LaneBoundary)},
};
static const ::_pb::Message* const file_default_instances[] = {
    &::osi3::_Lane_Classification_RoadCondition_default_instance_._instance,
    &::osi3::_Lane_Classification_LanePairing_default_instance_._instance,
    &::osi3::_Lane_Classification_default_instance_._instance,
    &::osi3::_Lane_default_instance_._instance,
    &::osi3::_LaneBoundary_BoundaryPoint_default_instance_._instance,
    &::osi3::_LaneBoundary_Classification_default_instance_._instance,
    &::osi3::_LaneBoundary_default_instance_._instance,
};
const char descriptor_table_protodef_osi_5flane_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\016osi_lane.proto\022\004osi3\032\020osi_common.proto"
    "\"\252\013\n\004Lane\022\034\n\002id\030\001 \001(\0132\020.osi3.Identifier\022"
    "1\n\016classification\030\002 \001(\0132\031.osi3.Lane.Clas"
    "sification\0221\n\020source_reference\030\003 \003(\0132\027.o"
    "si3.ExternalReference\032\235\n\n\016Classification"
    "\022,\n\004type\030\001 \001(\0162\036.osi3.Lane.Classificatio"
    "n.Type\022\034\n\024is_host_vehicle_lane\030\002 \001(\010\022\"\n\n"
    "centerline\030\003 \003(\0132\016.osi3.Vector3d\022\'\n\037cent"
    "erline_is_driving_direction\030\004 \001(\010\022/\n\025lef"
    "t_adjacent_lane_id\030\005 \003(\0132\020.osi3.Identifi"
    "er\0220\n\026right_adjacent_lane_id\030\006 \003(\0132\020.osi"
    "3.Identifier\022;\n\014lane_pairing\030\007 \003(\0132%.osi"
    "3.Lane.Classification.LanePairing\0220\n\026rig"
    "ht_lane_boundary_id\030\010 \003(\0132\020.osi3.Identif"
    "ier\022/\n\025left_lane_boundary_id\030\t \003(\0132\020.osi"
    "3.Identifier\022/\n\025free_lane_boundary_id\030\n "
    "\003(\0132\020.osi3.Identifier\022\?\n\016road_condition\030"
    "\013 \001(\0132\'.osi3.Lane.Classification.RoadCon"
    "dition\0222\n\007subtype\030\014 \001(\0162!.osi3.Lane.Clas"
    "sification.Subtype\032\261\001\n\rRoadCondition\022\033\n\023"
    "surface_temperature\030\001 \001(\001\022\032\n\022surface_wat"
    "er_film\030\002 \001(\001\022\036\n\026surface_freezing_point\030"
    "\003 \001(\001\022\023\n\013surface_ice\030\004 \001(\001\022\031\n\021surface_ro"
    "ughness\030\005 \001(\001\022\027\n\017surface_texture\030\006 \001(\001\032h"
    "\n\013LanePairing\022,\n\022antecessor_lane_id\030\001 \001("
    "\0132\020.osi3.Identifier\022+\n\021successor_lane_id"
    "\030\002 \001(\0132\020.osi3.Identifier\"f\n\004Type\022\020\n\014TYPE"
    "_UNKNOWN\020\000\022\016\n\nTYPE_OTHER\020\001\022\020\n\014TYPE_DRIVI"
    "NG\020\002\022\023\n\017TYPE_NONDRIVING\020\003\022\025\n\021TYPE_INTERS"
    "ECTION\020\004\"\302\002\n\007Subtype\022\023\n\017SUBTYPE_UNKNOWN\020"
    "\000\022\021\n\rSUBTYPE_OTHER\020\001\022\022\n\016SUBTYPE_NORMAL\020\002"
    "\022\022\n\016SUBTYPE_BIKING\020\003\022\024\n\020SUBTYPE_SIDEWALK"
    "\020\004\022\023\n\017SUBTYPE_PARKING\020\005\022\020\n\014SUBTYPE_STOP\020"
    "\006\022\026\n\022SUBTYPE_RESTRICTED\020\007\022\022\n\016SUBTYPE_BOR"
    "DER\020\010\022\024\n\020SUBTYPE_SHOULDER\020\t\022\020\n\014SUBTYPE_E"
    "XIT\020\n\022\021\n\rSUBTYPE_ENTRY\020\013\022\022\n\016SUBTYPE_ONRA"
    "MP\020\014\022\023\n\017SUBTYPE_OFFRAMP\020\r\022\032\n\026SUBTYPE_CON"
    "NECTINGRAMP\020\016\"\244\t\n\014LaneBoundary\022\034\n\002id\030\001 \001"
    "(\0132\020.osi3.Identifier\0227\n\rboundary_line\030\002 "
    "\003(\0132 .osi3.LaneBoundary.BoundaryPoint\0229\n"
    "\016classification\030\003 \001(\0132!.osi3.LaneBoundar"
    "y.Classification\0221\n\020source_reference\030\004 \003"
    "(\0132\027.osi3.ExternalReference\0221\n\021color_des"
    "cription\030\005 \001(\0132\026.osi3.ColorDescription\032\356"
    "\001\n\rBoundaryPoint\022 \n\010position\030\001 \001(\0132\016.osi"
    "3.Vector3d\022\r\n\005width\030\002 \001(\001\022\016\n\006height\030\003 \001("
    "\001\0223\n\004dash\030\004 \001(\0162%.osi3.LaneBoundary.Boun"
    "daryPoint.Dash\"g\n\004Dash\022\020\n\014DASH_UNKNOWN\020\000"
    "\022\016\n\nDASH_OTHER\020\001\022\016\n\nDASH_START\020\002\022\021\n\rDASH"
    "_CONTINUE\020\003\022\014\n\010DASH_END\020\004\022\014\n\010DASH_GAP\020\005\032"
    "\252\005\n\016Classification\0224\n\004type\030\001 \001(\0162&.osi3."
    "LaneBoundary.Classification.Type\0226\n\005colo"
    "r\030\002 \001(\0162\'.osi3.LaneBoundary.Classificati"
    "on.Color\022/\n\025limiting_structure_id\030\003 \003(\0132"
    "\020.osi3.Identifier\"\303\002\n\004Type\022\020\n\014TYPE_UNKNO"
    "WN\020\000\022\016\n\nTYPE_OTHER\020\001\022\020\n\014TYPE_NO_LINE\020\002\022\023"
    "\n\017TYPE_SOLID_LINE\020\003\022\024\n\020TYPE_DASHED_LINE\020"
    "\004\022\023\n\017TYPE_BOTTS_DOTS\020\005\022\022\n\016TYPE_ROAD_EDGE"
    "\020\006\022\022\n\016TYPE_SNOW_EDGE\020\007\022\023\n\017TYPE_GRASS_EDG"
    "E\020\010\022\024\n\020TYPE_GRAVEL_EDGE\020\t\022\022\n\016TYPE_SOIL_E"
    "DGE\020\n\022\023\n\017TYPE_GUARD_RAIL\020\013\022\r\n\tTYPE_CURB\020"
    "\014\022\022\n\016TYPE_STRUCTURE\020\r\022\020\n\014TYPE_BARRIER\020\016\022"
    "\026\n\022TYPE_SOUND_BARRIER\020\017\"\262\001\n\005Color\022\021\n\rCOL"
    "OR_UNKNOWN\020\000\022\017\n\013COLOR_OTHER\020\001\022\016\n\nCOLOR_N"
    "ONE\020\002\022\017\n\013COLOR_WHITE\020\003\022\020\n\014COLOR_YELLOW\020\004"
    "\022\r\n\tCOLOR_RED\020\005\022\016\n\nCOLOR_BLUE\020\006\022\017\n\013COLOR"
    "_GREEN\020\007\022\020\n\014COLOR_VIOLET\020\010\022\020\n\014COLOR_ORAN"
    "GE\020\tB\002H\001"
};
static const ::_pbi::DescriptorTable* const descriptor_table_osi_5flane_2eproto_deps[1] =
    {
        &::descriptor_table_osi_5fcommon_2eproto,
};
static ::absl::once_flag descriptor_table_osi_5flane_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_osi_5flane_2eproto = {
    false,
    false,
    2688,
    descriptor_table_protodef_osi_5flane_2eproto,
    "osi_lane.proto",
    &descriptor_table_osi_5flane_2eproto_once,
    descriptor_table_osi_5flane_2eproto_deps,
    1,
    7,
    schemas,
    file_default_instances,
    TableStruct_osi_5flane_2eproto::offsets,
    file_level_enum_descriptors_osi_5flane_2eproto,
    file_level_service_descriptors_osi_5flane_2eproto,
};
namespace osi3 {
const ::google::protobuf::EnumDescriptor* Lane_Classification_Type_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_osi_5flane_2eproto);
  return file_level_enum_descriptors_osi_5flane_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t Lane_Classification_Type_internal_data_[] = {
    327680u, 0u, };
bool Lane_Classification_Type_IsValid(int value) {
  return 0 <= value && value <= 4;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Lane_Classification_Type Lane_Classification::TYPE_UNKNOWN;
constexpr Lane_Classification_Type Lane_Classification::TYPE_OTHER;
constexpr Lane_Classification_Type Lane_Classification::TYPE_DRIVING;
constexpr Lane_Classification_Type Lane_Classification::TYPE_NONDRIVING;
constexpr Lane_Classification_Type Lane_Classification::TYPE_INTERSECTION;
constexpr Lane_Classification_Type Lane_Classification::Type_MIN;
constexpr Lane_Classification_Type Lane_Classification::Type_MAX;
constexpr int Lane_Classification::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* Lane_Classification_Subtype_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_osi_5flane_2eproto);
  return file_level_enum_descriptors_osi_5flane_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t Lane_Classification_Subtype_internal_data_[] = {
    983040u, 0u, };
bool Lane_Classification_Subtype_IsValid(int value) {
  return 0 <= value && value <= 14;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Lane_Classification_Subtype Lane_Classification::SUBTYPE_UNKNOWN;
constexpr Lane_Classification_Subtype Lane_Classification::SUBTYPE_OTHER;
constexpr Lane_Classification_Subtype Lane_Classification::SUBTYPE_NORMAL;
constexpr Lane_Classification_Subtype Lane_Classification::SUBTYPE_BIKING;
constexpr Lane_Classification_Subtype Lane_Classification::SUBTYPE_SIDEWALK;
constexpr Lane_Classification_Subtype Lane_Classification::SUBTYPE_PARKING;
constexpr Lane_Classification_Subtype Lane_Classification::SUBTYPE_STOP;
constexpr Lane_Classification_Subtype Lane_Classification::SUBTYPE_RESTRICTED;
constexpr Lane_Classification_Subtype Lane_Classification::SUBTYPE_BORDER;
constexpr Lane_Classification_Subtype Lane_Classification::SUBTYPE_SHOULDER;
constexpr Lane_Classification_Subtype Lane_Classification::SUBTYPE_EXIT;
constexpr Lane_Classification_Subtype Lane_Classification::SUBTYPE_ENTRY;
constexpr Lane_Classification_Subtype Lane_Classification::SUBTYPE_ONRAMP;
constexpr Lane_Classification_Subtype Lane_Classification::SUBTYPE_OFFRAMP;
constexpr Lane_Classification_Subtype Lane_Classification::SUBTYPE_CONNECTINGRAMP;
constexpr Lane_Classification_Subtype Lane_Classification::Subtype_MIN;
constexpr Lane_Classification_Subtype Lane_Classification::Subtype_MAX;
constexpr int Lane_Classification::Subtype_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* LaneBoundary_BoundaryPoint_Dash_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_osi_5flane_2eproto);
  return file_level_enum_descriptors_osi_5flane_2eproto[2];
}
PROTOBUF_CONSTINIT const uint32_t LaneBoundary_BoundaryPoint_Dash_internal_data_[] = {
    393216u, 0u, };
bool LaneBoundary_BoundaryPoint_Dash_IsValid(int value) {
  return 0 <= value && value <= 5;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr LaneBoundary_BoundaryPoint_Dash LaneBoundary_BoundaryPoint::DASH_UNKNOWN;
constexpr LaneBoundary_BoundaryPoint_Dash LaneBoundary_BoundaryPoint::DASH_OTHER;
constexpr LaneBoundary_BoundaryPoint_Dash LaneBoundary_BoundaryPoint::DASH_START;
constexpr LaneBoundary_BoundaryPoint_Dash LaneBoundary_BoundaryPoint::DASH_CONTINUE;
constexpr LaneBoundary_BoundaryPoint_Dash LaneBoundary_BoundaryPoint::DASH_END;
constexpr LaneBoundary_BoundaryPoint_Dash LaneBoundary_BoundaryPoint::DASH_GAP;
constexpr LaneBoundary_BoundaryPoint_Dash LaneBoundary_BoundaryPoint::Dash_MIN;
constexpr LaneBoundary_BoundaryPoint_Dash LaneBoundary_BoundaryPoint::Dash_MAX;
constexpr int LaneBoundary_BoundaryPoint::Dash_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* LaneBoundary_Classification_Type_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_osi_5flane_2eproto);
  return file_level_enum_descriptors_osi_5flane_2eproto[3];
}
PROTOBUF_CONSTINIT const uint32_t LaneBoundary_Classification_Type_internal_data_[] = {
    1048576u, 0u, };
bool LaneBoundary_Classification_Type_IsValid(int value) {
  return 0 <= value && value <= 15;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_UNKNOWN;
constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_OTHER;
constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_NO_LINE;
constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_SOLID_LINE;
constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_DASHED_LINE;
constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_BOTTS_DOTS;
constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_ROAD_EDGE;
constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_SNOW_EDGE;
constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_GRASS_EDGE;
constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_GRAVEL_EDGE;
constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_SOIL_EDGE;
constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_GUARD_RAIL;
constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_CURB;
constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_STRUCTURE;
constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_BARRIER;
constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_SOUND_BARRIER;
constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::Type_MIN;
constexpr LaneBoundary_Classification_Type LaneBoundary_Classification::Type_MAX;
constexpr int LaneBoundary_Classification::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* LaneBoundary_Classification_Color_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_osi_5flane_2eproto);
  return file_level_enum_descriptors_osi_5flane_2eproto[4];
}
PROTOBUF_CONSTINIT const uint32_t LaneBoundary_Classification_Color_internal_data_[] = {
    655360u, 0u, };
bool LaneBoundary_Classification_Color_IsValid(int value) {
  return 0 <= value && value <= 9;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_UNKNOWN;
constexpr LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_OTHER;
constexpr LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_NONE;
constexpr LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_WHITE;
constexpr LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_YELLOW;
constexpr LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_RED;
constexpr LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_BLUE;
constexpr LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_GREEN;
constexpr LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_VIOLET;
constexpr LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_ORANGE;
constexpr LaneBoundary_Classification_Color LaneBoundary_Classification::Color_MIN;
constexpr LaneBoundary_Classification_Color LaneBoundary_Classification::Color_MAX;
constexpr int LaneBoundary_Classification::Color_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class Lane_Classification_RoadCondition::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Lane_Classification_RoadCondition>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Lane_Classification_RoadCondition, _impl_._has_bits_);
};

Lane_Classification_RoadCondition::Lane_Classification_RoadCondition(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.Lane.Classification.RoadCondition)
}
Lane_Classification_RoadCondition::Lane_Classification_RoadCondition(
    ::google::protobuf::Arena* arena, const Lane_Classification_RoadCondition& from)
    : Lane_Classification_RoadCondition(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE Lane_Classification_RoadCondition::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Lane_Classification_RoadCondition::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, surface_temperature_),
           0,
           offsetof(Impl_, surface_texture_) -
               offsetof(Impl_, surface_temperature_) +
               sizeof(Impl_::surface_texture_));
}
Lane_Classification_RoadCondition::~Lane_Classification_RoadCondition() {
  // @@protoc_insertion_point(destructor:osi3.Lane.Classification.RoadCondition)
  SharedDtor(*this);
}
inline void Lane_Classification_RoadCondition::SharedDtor(MessageLite& self) {
  Lane_Classification_RoadCondition& this_ = static_cast<Lane_Classification_RoadCondition&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* Lane_Classification_RoadCondition::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Lane_Classification_RoadCondition(arena);
}
constexpr auto Lane_Classification_RoadCondition::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(Lane_Classification_RoadCondition),
                                            alignof(Lane_Classification_RoadCondition));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull Lane_Classification_RoadCondition::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_Lane_Classification_RoadCondition_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Lane_Classification_RoadCondition::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<Lane_Classification_RoadCondition>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Lane_Classification_RoadCondition::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<Lane_Classification_RoadCondition>(), &Lane_Classification_RoadCondition::ByteSizeLong,
            &Lane_Classification_RoadCondition::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Lane_Classification_RoadCondition, _impl_._cached_size_),
        false,
    },
    &Lane_Classification_RoadCondition::kDescriptorMethods,
    &descriptor_table_osi_5flane_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* Lane_Classification_RoadCondition::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 0, 0, 2> Lane_Classification_RoadCondition::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Lane_Classification_RoadCondition, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::Lane_Classification_RoadCondition>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional double surface_temperature = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 0, 0, PROTOBUF_FIELD_OFFSET(Lane_Classification_RoadCondition, _impl_.surface_temperature_)}},
    // optional double surface_water_film = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 1, 0, PROTOBUF_FIELD_OFFSET(Lane_Classification_RoadCondition, _impl_.surface_water_film_)}},
    // optional double surface_freezing_point = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 2, 0, PROTOBUF_FIELD_OFFSET(Lane_Classification_RoadCondition, _impl_.surface_freezing_point_)}},
    // optional double surface_ice = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 3, 0, PROTOBUF_FIELD_OFFSET(Lane_Classification_RoadCondition, _impl_.surface_ice_)}},
    // optional double surface_roughness = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 4, 0, PROTOBUF_FIELD_OFFSET(Lane_Classification_RoadCondition, _impl_.surface_roughness_)}},
    // optional double surface_texture = 6;
    {::_pbi::TcParser::FastF64S1,
     {49, 5, 0, PROTOBUF_FIELD_OFFSET(Lane_Classification_RoadCondition, _impl_.surface_texture_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional double surface_temperature = 1;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification_RoadCondition, _impl_.surface_temperature_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double surface_water_film = 2;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification_RoadCondition, _impl_.surface_water_film_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double surface_freezing_point = 3;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification_RoadCondition, _impl_.surface_freezing_point_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double surface_ice = 4;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification_RoadCondition, _impl_.surface_ice_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double surface_roughness = 5;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification_RoadCondition, _impl_.surface_roughness_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double surface_texture = 6;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification_RoadCondition, _impl_.surface_texture_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void Lane_Classification_RoadCondition::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.Lane.Classification.RoadCondition)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.surface_temperature_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.surface_texture_) -
        reinterpret_cast<char*>(&_impl_.surface_temperature_)) + sizeof(_impl_.surface_texture_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Lane_Classification_RoadCondition::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Lane_Classification_RoadCondition& this_ = static_cast<const Lane_Classification_RoadCondition&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Lane_Classification_RoadCondition::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Lane_Classification_RoadCondition& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.Lane.Classification.RoadCondition)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional double surface_temperature = 1;
          if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                1, this_._internal_surface_temperature(), target);
          }

          // optional double surface_water_film = 2;
          if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                2, this_._internal_surface_water_film(), target);
          }

          // optional double surface_freezing_point = 3;
          if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                3, this_._internal_surface_freezing_point(), target);
          }

          // optional double surface_ice = 4;
          if (cached_has_bits & 0x00000008u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                4, this_._internal_surface_ice(), target);
          }

          // optional double surface_roughness = 5;
          if (cached_has_bits & 0x00000010u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                5, this_._internal_surface_roughness(), target);
          }

          // optional double surface_texture = 6;
          if (cached_has_bits & 0x00000020u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                6, this_._internal_surface_texture(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.Lane.Classification.RoadCondition)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Lane_Classification_RoadCondition::ByteSizeLong(const MessageLite& base) {
          const Lane_Classification_RoadCondition& this_ = static_cast<const Lane_Classification_RoadCondition&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Lane_Classification_RoadCondition::ByteSizeLong() const {
          const Lane_Classification_RoadCondition& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.Lane.Classification.RoadCondition)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x0000003fu) {
            // optional double surface_temperature = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 9;
            }
            // optional double surface_water_film = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 9;
            }
            // optional double surface_freezing_point = 3;
            if (cached_has_bits & 0x00000004u) {
              total_size += 9;
            }
            // optional double surface_ice = 4;
            if (cached_has_bits & 0x00000008u) {
              total_size += 9;
            }
            // optional double surface_roughness = 5;
            if (cached_has_bits & 0x00000010u) {
              total_size += 9;
            }
            // optional double surface_texture = 6;
            if (cached_has_bits & 0x00000020u) {
              total_size += 9;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void Lane_Classification_RoadCondition::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Lane_Classification_RoadCondition*>(&to_msg);
  auto& from = static_cast<const Lane_Classification_RoadCondition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.Lane.Classification.RoadCondition)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.surface_temperature_ = from._impl_.surface_temperature_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.surface_water_film_ = from._impl_.surface_water_film_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.surface_freezing_point_ = from._impl_.surface_freezing_point_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.surface_ice_ = from._impl_.surface_ice_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.surface_roughness_ = from._impl_.surface_roughness_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.surface_texture_ = from._impl_.surface_texture_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Lane_Classification_RoadCondition::CopyFrom(const Lane_Classification_RoadCondition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.Lane.Classification.RoadCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Lane_Classification_RoadCondition::InternalSwap(Lane_Classification_RoadCondition* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Lane_Classification_RoadCondition, _impl_.surface_texture_)
      + sizeof(Lane_Classification_RoadCondition::_impl_.surface_texture_)
      - PROTOBUF_FIELD_OFFSET(Lane_Classification_RoadCondition, _impl_.surface_temperature_)>(
          reinterpret_cast<char*>(&_impl_.surface_temperature_),
          reinterpret_cast<char*>(&other->_impl_.surface_temperature_));
}

::google::protobuf::Metadata Lane_Classification_RoadCondition::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Lane_Classification_LanePairing::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Lane_Classification_LanePairing>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Lane_Classification_LanePairing, _impl_._has_bits_);
};

void Lane_Classification_LanePairing::clear_antecessor_lane_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.antecessor_lane_id_ != nullptr) _impl_.antecessor_lane_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void Lane_Classification_LanePairing::clear_successor_lane_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.successor_lane_id_ != nullptr) _impl_.successor_lane_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
Lane_Classification_LanePairing::Lane_Classification_LanePairing(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.Lane.Classification.LanePairing)
}
inline PROTOBUF_NDEBUG_INLINE Lane_Classification_LanePairing::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::Lane_Classification_LanePairing& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

Lane_Classification_LanePairing::Lane_Classification_LanePairing(
    ::google::protobuf::Arena* arena,
    const Lane_Classification_LanePairing& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Lane_Classification_LanePairing* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.antecessor_lane_id_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.antecessor_lane_id_)
                        : nullptr;
  _impl_.successor_lane_id_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.successor_lane_id_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:osi3.Lane.Classification.LanePairing)
}
inline PROTOBUF_NDEBUG_INLINE Lane_Classification_LanePairing::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Lane_Classification_LanePairing::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, antecessor_lane_id_),
           0,
           offsetof(Impl_, successor_lane_id_) -
               offsetof(Impl_, antecessor_lane_id_) +
               sizeof(Impl_::successor_lane_id_));
}
Lane_Classification_LanePairing::~Lane_Classification_LanePairing() {
  // @@protoc_insertion_point(destructor:osi3.Lane.Classification.LanePairing)
  SharedDtor(*this);
}
inline void Lane_Classification_LanePairing::SharedDtor(MessageLite& self) {
  Lane_Classification_LanePairing& this_ = static_cast<Lane_Classification_LanePairing&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.antecessor_lane_id_;
  delete this_._impl_.successor_lane_id_;
  this_._impl_.~Impl_();
}

inline void* Lane_Classification_LanePairing::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Lane_Classification_LanePairing(arena);
}
constexpr auto Lane_Classification_LanePairing::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(Lane_Classification_LanePairing),
                                            alignof(Lane_Classification_LanePairing));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull Lane_Classification_LanePairing::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_Lane_Classification_LanePairing_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Lane_Classification_LanePairing::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<Lane_Classification_LanePairing>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Lane_Classification_LanePairing::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<Lane_Classification_LanePairing>(), &Lane_Classification_LanePairing::ByteSizeLong,
            &Lane_Classification_LanePairing::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Lane_Classification_LanePairing, _impl_._cached_size_),
        false,
    },
    &Lane_Classification_LanePairing::kDescriptorMethods,
    &descriptor_table_osi_5flane_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* Lane_Classification_LanePairing::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2> Lane_Classification_LanePairing::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Lane_Classification_LanePairing, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::Lane_Classification_LanePairing>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional .osi3.Identifier successor_lane_id = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(Lane_Classification_LanePairing, _impl_.successor_lane_id_)}},
    // optional .osi3.Identifier antecessor_lane_id = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Lane_Classification_LanePairing, _impl_.antecessor_lane_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.Identifier antecessor_lane_id = 1;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification_LanePairing, _impl_.antecessor_lane_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.Identifier successor_lane_id = 2;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification_LanePairing, _impl_.successor_lane_id_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void Lane_Classification_LanePairing::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.Lane.Classification.LanePairing)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.antecessor_lane_id_ != nullptr);
      _impl_.antecessor_lane_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.successor_lane_id_ != nullptr);
      _impl_.successor_lane_id_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Lane_Classification_LanePairing::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Lane_Classification_LanePairing& this_ = static_cast<const Lane_Classification_LanePairing&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Lane_Classification_LanePairing::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Lane_Classification_LanePairing& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.Lane.Classification.LanePairing)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.Identifier antecessor_lane_id = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.antecessor_lane_id_, this_._impl_.antecessor_lane_id_->GetCachedSize(), target,
                stream);
          }

          // optional .osi3.Identifier successor_lane_id = 2;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.successor_lane_id_, this_._impl_.successor_lane_id_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.Lane.Classification.LanePairing)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Lane_Classification_LanePairing::ByteSizeLong(const MessageLite& base) {
          const Lane_Classification_LanePairing& this_ = static_cast<const Lane_Classification_LanePairing&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Lane_Classification_LanePairing::ByteSizeLong() const {
          const Lane_Classification_LanePairing& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.Lane.Classification.LanePairing)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // optional .osi3.Identifier antecessor_lane_id = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.antecessor_lane_id_);
            }
            // optional .osi3.Identifier successor_lane_id = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.successor_lane_id_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void Lane_Classification_LanePairing::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Lane_Classification_LanePairing*>(&to_msg);
  auto& from = static_cast<const Lane_Classification_LanePairing&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.Lane.Classification.LanePairing)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.antecessor_lane_id_ != nullptr);
      if (_this->_impl_.antecessor_lane_id_ == nullptr) {
        _this->_impl_.antecessor_lane_id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.antecessor_lane_id_);
      } else {
        _this->_impl_.antecessor_lane_id_->MergeFrom(*from._impl_.antecessor_lane_id_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.successor_lane_id_ != nullptr);
      if (_this->_impl_.successor_lane_id_ == nullptr) {
        _this->_impl_.successor_lane_id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.successor_lane_id_);
      } else {
        _this->_impl_.successor_lane_id_->MergeFrom(*from._impl_.successor_lane_id_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Lane_Classification_LanePairing::CopyFrom(const Lane_Classification_LanePairing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.Lane.Classification.LanePairing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Lane_Classification_LanePairing::InternalSwap(Lane_Classification_LanePairing* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Lane_Classification_LanePairing, _impl_.successor_lane_id_)
      + sizeof(Lane_Classification_LanePairing::_impl_.successor_lane_id_)
      - PROTOBUF_FIELD_OFFSET(Lane_Classification_LanePairing, _impl_.antecessor_lane_id_)>(
          reinterpret_cast<char*>(&_impl_.antecessor_lane_id_),
          reinterpret_cast<char*>(&other->_impl_.antecessor_lane_id_));
}

::google::protobuf::Metadata Lane_Classification_LanePairing::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Lane_Classification::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Lane_Classification>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_._has_bits_);
};

void Lane_Classification::clear_centerline() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.centerline_.Clear();
}
void Lane_Classification::clear_left_adjacent_lane_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.left_adjacent_lane_id_.Clear();
}
void Lane_Classification::clear_right_adjacent_lane_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.right_adjacent_lane_id_.Clear();
}
void Lane_Classification::clear_right_lane_boundary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.right_lane_boundary_id_.Clear();
}
void Lane_Classification::clear_left_lane_boundary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.left_lane_boundary_id_.Clear();
}
void Lane_Classification::clear_free_lane_boundary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.free_lane_boundary_id_.Clear();
}
Lane_Classification::Lane_Classification(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.Lane.Classification)
}
inline PROTOBUF_NDEBUG_INLINE Lane_Classification::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::Lane_Classification& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        centerline_{visibility, arena, from.centerline_},
        left_adjacent_lane_id_{visibility, arena, from.left_adjacent_lane_id_},
        right_adjacent_lane_id_{visibility, arena, from.right_adjacent_lane_id_},
        lane_pairing_{visibility, arena, from.lane_pairing_},
        right_lane_boundary_id_{visibility, arena, from.right_lane_boundary_id_},
        left_lane_boundary_id_{visibility, arena, from.left_lane_boundary_id_},
        free_lane_boundary_id_{visibility, arena, from.free_lane_boundary_id_} {}

Lane_Classification::Lane_Classification(
    ::google::protobuf::Arena* arena,
    const Lane_Classification& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Lane_Classification* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.road_condition_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Lane_Classification_RoadCondition>(
                              arena, *from._impl_.road_condition_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, type_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, type_),
           offsetof(Impl_, subtype_) -
               offsetof(Impl_, type_) +
               sizeof(Impl_::subtype_));

  // @@protoc_insertion_point(copy_constructor:osi3.Lane.Classification)
}
inline PROTOBUF_NDEBUG_INLINE Lane_Classification::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        centerline_{visibility, arena},
        left_adjacent_lane_id_{visibility, arena},
        right_adjacent_lane_id_{visibility, arena},
        lane_pairing_{visibility, arena},
        right_lane_boundary_id_{visibility, arena},
        left_lane_boundary_id_{visibility, arena},
        free_lane_boundary_id_{visibility, arena} {}

inline void Lane_Classification::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, road_condition_),
           0,
           offsetof(Impl_, subtype_) -
               offsetof(Impl_, road_condition_) +
               sizeof(Impl_::subtype_));
}
Lane_Classification::~Lane_Classification() {
  // @@protoc_insertion_point(destructor:osi3.Lane.Classification)
  SharedDtor(*this);
}
inline void Lane_Classification::SharedDtor(MessageLite& self) {
  Lane_Classification& this_ = static_cast<Lane_Classification&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.road_condition_;
  this_._impl_.~Impl_();
}

inline void* Lane_Classification::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Lane_Classification(arena);
}
constexpr auto Lane_Classification::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.centerline_) +
          decltype(Lane_Classification::_impl_.centerline_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.left_adjacent_lane_id_) +
          decltype(Lane_Classification::_impl_.left_adjacent_lane_id_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.right_adjacent_lane_id_) +
          decltype(Lane_Classification::_impl_.right_adjacent_lane_id_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.lane_pairing_) +
          decltype(Lane_Classification::_impl_.lane_pairing_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.right_lane_boundary_id_) +
          decltype(Lane_Classification::_impl_.right_lane_boundary_id_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.left_lane_boundary_id_) +
          decltype(Lane_Classification::_impl_.left_lane_boundary_id_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.free_lane_boundary_id_) +
          decltype(Lane_Classification::_impl_.free_lane_boundary_id_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(Lane_Classification), alignof(Lane_Classification), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Lane_Classification::PlacementNew_,
                                 sizeof(Lane_Classification),
                                 alignof(Lane_Classification));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull Lane_Classification::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_Lane_Classification_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Lane_Classification::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<Lane_Classification>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Lane_Classification::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<Lane_Classification>(), &Lane_Classification::ByteSizeLong,
            &Lane_Classification::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_._cached_size_),
        false,
    },
    &Lane_Classification::kDescriptorMethods,
    &descriptor_table_osi_5flane_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* Lane_Classification::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 12, 10, 0, 2> Lane_Classification::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_._has_bits_),
    0, // no _extensions_
    12, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294963200,  // skipmap
    offsetof(decltype(_table_), field_entries),
    12,  // num_field_entries
    10,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::Lane_Classification>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .osi3.Lane.Classification.Type type = 1;
    {::_pbi::TcParser::FastEr0S1,
     {8, 1, 4, PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.type_)}},
    // optional bool is_host_vehicle_lane = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Lane_Classification, _impl_.is_host_vehicle_lane_), 2>(),
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.is_host_vehicle_lane_)}},
    // repeated .osi3.Vector3d centerline = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.centerline_)}},
    // optional bool centerline_is_driving_direction = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Lane_Classification, _impl_.centerline_is_driving_direction_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.centerline_is_driving_direction_)}},
    // repeated .osi3.Identifier left_adjacent_lane_id = 5;
    {::_pbi::TcParser::FastMtR1,
     {42, 63, 1, PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.left_adjacent_lane_id_)}},
    // repeated .osi3.Identifier right_adjacent_lane_id = 6;
    {::_pbi::TcParser::FastMtR1,
     {50, 63, 2, PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.right_adjacent_lane_id_)}},
    // repeated .osi3.Lane.Classification.LanePairing lane_pairing = 7;
    {::_pbi::TcParser::FastMtR1,
     {58, 63, 3, PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.lane_pairing_)}},
    // repeated .osi3.Identifier right_lane_boundary_id = 8;
    {::_pbi::TcParser::FastMtR1,
     {66, 63, 4, PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.right_lane_boundary_id_)}},
    // repeated .osi3.Identifier left_lane_boundary_id = 9;
    {::_pbi::TcParser::FastMtR1,
     {74, 63, 5, PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.left_lane_boundary_id_)}},
    // repeated .osi3.Identifier free_lane_boundary_id = 10;
    {::_pbi::TcParser::FastMtR1,
     {82, 63, 6, PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.free_lane_boundary_id_)}},
    // optional .osi3.Lane.Classification.RoadCondition road_condition = 11;
    {::_pbi::TcParser::FastMtS1,
     {90, 0, 7, PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.road_condition_)}},
    // optional .osi3.Lane.Classification.Subtype subtype = 12;
    {::_pbi::TcParser::FastEr0S1,
     {96, 4, 14, PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.subtype_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.Lane.Classification.Type type = 1;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.type_), _Internal::kHasBitsOffset + 1, 8,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional bool is_host_vehicle_lane = 2;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.is_host_vehicle_lane_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated .osi3.Vector3d centerline = 3;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.centerline_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bool centerline_is_driving_direction = 4;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.centerline_is_driving_direction_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated .osi3.Identifier left_adjacent_lane_id = 5;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.left_adjacent_lane_id_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.Identifier right_adjacent_lane_id = 6;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.right_adjacent_lane_id_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.Lane.Classification.LanePairing lane_pairing = 7;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.lane_pairing_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.Identifier right_lane_boundary_id = 8;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.right_lane_boundary_id_), -1, 4,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.Identifier left_lane_boundary_id = 9;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.left_lane_boundary_id_), -1, 5,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.Identifier free_lane_boundary_id = 10;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.free_lane_boundary_id_), -1, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.Lane.Classification.RoadCondition road_condition = 11;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.road_condition_), _Internal::kHasBitsOffset + 0, 7,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.Lane.Classification.Subtype subtype = 12;
    {PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.subtype_), _Internal::kHasBitsOffset + 4, 9,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Vector3d>()},
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::Lane_Classification_LanePairing>()},
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::Lane_Classification_RoadCondition>()},
    {0, 5},
    {0, 15},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void Lane_Classification::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.Lane.Classification)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.centerline_.Clear();
  _impl_.left_adjacent_lane_id_.Clear();
  _impl_.right_adjacent_lane_id_.Clear();
  _impl_.lane_pairing_.Clear();
  _impl_.right_lane_boundary_id_.Clear();
  _impl_.left_lane_boundary_id_.Clear();
  _impl_.free_lane_boundary_id_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.road_condition_ != nullptr);
    _impl_.road_condition_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.type_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.subtype_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.subtype_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Lane_Classification::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Lane_Classification& this_ = static_cast<const Lane_Classification&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Lane_Classification::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Lane_Classification& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.Lane.Classification)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.Lane.Classification.Type type = 1;
          if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                1, this_._internal_type(), target);
          }

          // optional bool is_host_vehicle_lane = 2;
          if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                2, this_._internal_is_host_vehicle_lane(), target);
          }

          // repeated .osi3.Vector3d centerline = 3;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_centerline_size());
               i < n; i++) {
            const auto& repfield = this_._internal_centerline().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    3, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // optional bool centerline_is_driving_direction = 4;
          if (cached_has_bits & 0x00000008u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                4, this_._internal_centerline_is_driving_direction(), target);
          }

          // repeated .osi3.Identifier left_adjacent_lane_id = 5;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_left_adjacent_lane_id_size());
               i < n; i++) {
            const auto& repfield = this_._internal_left_adjacent_lane_id().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    5, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .osi3.Identifier right_adjacent_lane_id = 6;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_right_adjacent_lane_id_size());
               i < n; i++) {
            const auto& repfield = this_._internal_right_adjacent_lane_id().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    6, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .osi3.Lane.Classification.LanePairing lane_pairing = 7;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_lane_pairing_size());
               i < n; i++) {
            const auto& repfield = this_._internal_lane_pairing().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    7, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .osi3.Identifier right_lane_boundary_id = 8;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_right_lane_boundary_id_size());
               i < n; i++) {
            const auto& repfield = this_._internal_right_lane_boundary_id().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    8, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .osi3.Identifier left_lane_boundary_id = 9;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_left_lane_boundary_id_size());
               i < n; i++) {
            const auto& repfield = this_._internal_left_lane_boundary_id().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    9, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .osi3.Identifier free_lane_boundary_id = 10;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_free_lane_boundary_id_size());
               i < n; i++) {
            const auto& repfield = this_._internal_free_lane_boundary_id().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    10, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // optional .osi3.Lane.Classification.RoadCondition road_condition = 11;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                11, *this_._impl_.road_condition_, this_._impl_.road_condition_->GetCachedSize(), target,
                stream);
          }

          // optional .osi3.Lane.Classification.Subtype subtype = 12;
          if (cached_has_bits & 0x00000010u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                12, this_._internal_subtype(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.Lane.Classification)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Lane_Classification::ByteSizeLong(const MessageLite& base) {
          const Lane_Classification& this_ = static_cast<const Lane_Classification&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Lane_Classification::ByteSizeLong() const {
          const Lane_Classification& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.Lane.Classification)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .osi3.Vector3d centerline = 3;
            {
              total_size += 1UL * this_._internal_centerline_size();
              for (const auto& msg : this_._internal_centerline()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.Identifier left_adjacent_lane_id = 5;
            {
              total_size += 1UL * this_._internal_left_adjacent_lane_id_size();
              for (const auto& msg : this_._internal_left_adjacent_lane_id()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.Identifier right_adjacent_lane_id = 6;
            {
              total_size += 1UL * this_._internal_right_adjacent_lane_id_size();
              for (const auto& msg : this_._internal_right_adjacent_lane_id()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.Lane.Classification.LanePairing lane_pairing = 7;
            {
              total_size += 1UL * this_._internal_lane_pairing_size();
              for (const auto& msg : this_._internal_lane_pairing()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.Identifier right_lane_boundary_id = 8;
            {
              total_size += 1UL * this_._internal_right_lane_boundary_id_size();
              for (const auto& msg : this_._internal_right_lane_boundary_id()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.Identifier left_lane_boundary_id = 9;
            {
              total_size += 1UL * this_._internal_left_lane_boundary_id_size();
              for (const auto& msg : this_._internal_left_lane_boundary_id()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.Identifier free_lane_boundary_id = 10;
            {
              total_size += 1UL * this_._internal_free_lane_boundary_id_size();
              for (const auto& msg : this_._internal_free_lane_boundary_id()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x0000001fu) {
            // optional .osi3.Lane.Classification.RoadCondition road_condition = 11;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.road_condition_);
            }
            // optional .osi3.Lane.Classification.Type type = 1;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
            }
            // optional bool is_host_vehicle_lane = 2;
            if (cached_has_bits & 0x00000004u) {
              total_size += 2;
            }
            // optional bool centerline_is_driving_direction = 4;
            if (cached_has_bits & 0x00000008u) {
              total_size += 2;
            }
            // optional .osi3.Lane.Classification.Subtype subtype = 12;
            if (cached_has_bits & 0x00000010u) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_subtype());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void Lane_Classification::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Lane_Classification*>(&to_msg);
  auto& from = static_cast<const Lane_Classification&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.Lane.Classification)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_centerline()->MergeFrom(
      from._internal_centerline());
  _this->_internal_mutable_left_adjacent_lane_id()->MergeFrom(
      from._internal_left_adjacent_lane_id());
  _this->_internal_mutable_right_adjacent_lane_id()->MergeFrom(
      from._internal_right_adjacent_lane_id());
  _this->_internal_mutable_lane_pairing()->MergeFrom(
      from._internal_lane_pairing());
  _this->_internal_mutable_right_lane_boundary_id()->MergeFrom(
      from._internal_right_lane_boundary_id());
  _this->_internal_mutable_left_lane_boundary_id()->MergeFrom(
      from._internal_left_lane_boundary_id());
  _this->_internal_mutable_free_lane_boundary_id()->MergeFrom(
      from._internal_free_lane_boundary_id());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.road_condition_ != nullptr);
      if (_this->_impl_.road_condition_ == nullptr) {
        _this->_impl_.road_condition_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Lane_Classification_RoadCondition>(arena, *from._impl_.road_condition_);
      } else {
        _this->_impl_.road_condition_->MergeFrom(*from._impl_.road_condition_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_host_vehicle_lane_ = from._impl_.is_host_vehicle_lane_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.centerline_is_driving_direction_ = from._impl_.centerline_is_driving_direction_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.subtype_ = from._impl_.subtype_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Lane_Classification::CopyFrom(const Lane_Classification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.Lane.Classification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Lane_Classification::InternalSwap(Lane_Classification* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.centerline_.InternalSwap(&other->_impl_.centerline_);
  _impl_.left_adjacent_lane_id_.InternalSwap(&other->_impl_.left_adjacent_lane_id_);
  _impl_.right_adjacent_lane_id_.InternalSwap(&other->_impl_.right_adjacent_lane_id_);
  _impl_.lane_pairing_.InternalSwap(&other->_impl_.lane_pairing_);
  _impl_.right_lane_boundary_id_.InternalSwap(&other->_impl_.right_lane_boundary_id_);
  _impl_.left_lane_boundary_id_.InternalSwap(&other->_impl_.left_lane_boundary_id_);
  _impl_.free_lane_boundary_id_.InternalSwap(&other->_impl_.free_lane_boundary_id_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.subtype_)
      + sizeof(Lane_Classification::_impl_.subtype_)
      - PROTOBUF_FIELD_OFFSET(Lane_Classification, _impl_.road_condition_)>(
          reinterpret_cast<char*>(&_impl_.road_condition_),
          reinterpret_cast<char*>(&other->_impl_.road_condition_));
}

::google::protobuf::Metadata Lane_Classification::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Lane::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Lane>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Lane, _impl_._has_bits_);
};

void Lane::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void Lane::clear_source_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_reference_.Clear();
}
Lane::Lane(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.Lane)
}
inline PROTOBUF_NDEBUG_INLINE Lane::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::Lane& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        source_reference_{visibility, arena, from.source_reference_} {}

Lane::Lane(
    ::google::protobuf::Arena* arena,
    const Lane& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Lane* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.id_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.id_)
                        : nullptr;
  _impl_.classification_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Lane_Classification>(
                              arena, *from._impl_.classification_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:osi3.Lane)
}
inline PROTOBUF_NDEBUG_INLINE Lane::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        source_reference_{visibility, arena} {}

inline void Lane::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, classification_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::classification_));
}
Lane::~Lane() {
  // @@protoc_insertion_point(destructor:osi3.Lane)
  SharedDtor(*this);
}
inline void Lane::SharedDtor(MessageLite& self) {
  Lane& this_ = static_cast<Lane&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.id_;
  delete this_._impl_.classification_;
  this_._impl_.~Impl_();
}

inline void* Lane::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Lane(arena);
}
constexpr auto Lane::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Lane, _impl_.source_reference_) +
          decltype(Lane::_impl_.source_reference_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(Lane), alignof(Lane), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Lane::PlacementNew_,
                                 sizeof(Lane),
                                 alignof(Lane));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull Lane::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_Lane_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Lane::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<Lane>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Lane::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<Lane>(), &Lane::ByteSizeLong,
            &Lane::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Lane, _impl_._cached_size_),
        false,
    },
    &Lane::kDescriptorMethods,
    &descriptor_table_osi_5flane_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* Lane::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> Lane::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Lane, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::Lane>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .osi3.Identifier id = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Lane, _impl_.id_)}},
    // optional .osi3.Lane.Classification classification = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(Lane, _impl_.classification_)}},
    // repeated .osi3.ExternalReference source_reference = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 2, PROTOBUF_FIELD_OFFSET(Lane, _impl_.source_reference_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.Identifier id = 1;
    {PROTOBUF_FIELD_OFFSET(Lane, _impl_.id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.Lane.Classification classification = 2;
    {PROTOBUF_FIELD_OFFSET(Lane, _impl_.classification_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.ExternalReference source_reference = 3;
    {PROTOBUF_FIELD_OFFSET(Lane, _impl_.source_reference_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::Lane_Classification>()},
    {::_pbi::TcParser::GetTable<::osi3::ExternalReference>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void Lane::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.Lane)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.source_reference_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.id_ != nullptr);
      _impl_.id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.classification_ != nullptr);
      _impl_.classification_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Lane::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Lane& this_ = static_cast<const Lane&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Lane::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Lane& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.Lane)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.Identifier id = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.id_, this_._impl_.id_->GetCachedSize(), target,
                stream);
          }

          // optional .osi3.Lane.Classification classification = 2;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.classification_, this_._impl_.classification_->GetCachedSize(), target,
                stream);
          }

          // repeated .osi3.ExternalReference source_reference = 3;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_source_reference_size());
               i < n; i++) {
            const auto& repfield = this_._internal_source_reference().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    3, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.Lane)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Lane::ByteSizeLong(const MessageLite& base) {
          const Lane& this_ = static_cast<const Lane&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Lane::ByteSizeLong() const {
          const Lane& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.Lane)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .osi3.ExternalReference source_reference = 3;
            {
              total_size += 1UL * this_._internal_source_reference_size();
              for (const auto& msg : this_._internal_source_reference()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // optional .osi3.Identifier id = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.id_);
            }
            // optional .osi3.Lane.Classification classification = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.classification_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void Lane::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Lane*>(&to_msg);
  auto& from = static_cast<const Lane&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.Lane)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_source_reference()->MergeFrom(
      from._internal_source_reference());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.id_ != nullptr);
      if (_this->_impl_.id_ == nullptr) {
        _this->_impl_.id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.id_);
      } else {
        _this->_impl_.id_->MergeFrom(*from._impl_.id_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.classification_ != nullptr);
      if (_this->_impl_.classification_ == nullptr) {
        _this->_impl_.classification_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Lane_Classification>(arena, *from._impl_.classification_);
      } else {
        _this->_impl_.classification_->MergeFrom(*from._impl_.classification_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Lane::CopyFrom(const Lane& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.Lane)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Lane::InternalSwap(Lane* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.source_reference_.InternalSwap(&other->_impl_.source_reference_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Lane, _impl_.classification_)
      + sizeof(Lane::_impl_.classification_)
      - PROTOBUF_FIELD_OFFSET(Lane, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata Lane::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LaneBoundary_BoundaryPoint::_Internal {
 public:
  using HasBits =
      decltype(std::declval<LaneBoundary_BoundaryPoint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LaneBoundary_BoundaryPoint, _impl_._has_bits_);
};

void LaneBoundary_BoundaryPoint::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
LaneBoundary_BoundaryPoint::LaneBoundary_BoundaryPoint(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.LaneBoundary.BoundaryPoint)
}
inline PROTOBUF_NDEBUG_INLINE LaneBoundary_BoundaryPoint::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::LaneBoundary_BoundaryPoint& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

LaneBoundary_BoundaryPoint::LaneBoundary_BoundaryPoint(
    ::google::protobuf::Arena* arena,
    const LaneBoundary_BoundaryPoint& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LaneBoundary_BoundaryPoint* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.position_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Vector3d>(
                              arena, *from._impl_.position_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, width_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, width_),
           offsetof(Impl_, dash_) -
               offsetof(Impl_, width_) +
               sizeof(Impl_::dash_));

  // @@protoc_insertion_point(copy_constructor:osi3.LaneBoundary.BoundaryPoint)
}
inline PROTOBUF_NDEBUG_INLINE LaneBoundary_BoundaryPoint::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void LaneBoundary_BoundaryPoint::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, position_),
           0,
           offsetof(Impl_, dash_) -
               offsetof(Impl_, position_) +
               sizeof(Impl_::dash_));
}
LaneBoundary_BoundaryPoint::~LaneBoundary_BoundaryPoint() {
  // @@protoc_insertion_point(destructor:osi3.LaneBoundary.BoundaryPoint)
  SharedDtor(*this);
}
inline void LaneBoundary_BoundaryPoint::SharedDtor(MessageLite& self) {
  LaneBoundary_BoundaryPoint& this_ = static_cast<LaneBoundary_BoundaryPoint&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.position_;
  this_._impl_.~Impl_();
}

inline void* LaneBoundary_BoundaryPoint::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) LaneBoundary_BoundaryPoint(arena);
}
constexpr auto LaneBoundary_BoundaryPoint::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(LaneBoundary_BoundaryPoint),
                                            alignof(LaneBoundary_BoundaryPoint));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull LaneBoundary_BoundaryPoint::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_LaneBoundary_BoundaryPoint_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &LaneBoundary_BoundaryPoint::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<LaneBoundary_BoundaryPoint>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &LaneBoundary_BoundaryPoint::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<LaneBoundary_BoundaryPoint>(), &LaneBoundary_BoundaryPoint::ByteSizeLong,
            &LaneBoundary_BoundaryPoint::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(LaneBoundary_BoundaryPoint, _impl_._cached_size_),
        false,
    },
    &LaneBoundary_BoundaryPoint::kDescriptorMethods,
    &descriptor_table_osi_5flane_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* LaneBoundary_BoundaryPoint::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 2, 0, 2> LaneBoundary_BoundaryPoint::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LaneBoundary_BoundaryPoint, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::LaneBoundary_BoundaryPoint>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional .osi3.LaneBoundary.BoundaryPoint.Dash dash = 4;
    {::_pbi::TcParser::FastEr0S1,
     {32, 3, 5, PROTOBUF_FIELD_OFFSET(LaneBoundary_BoundaryPoint, _impl_.dash_)}},
    // optional .osi3.Vector3d position = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(LaneBoundary_BoundaryPoint, _impl_.position_)}},
    // optional double width = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 1, 0, PROTOBUF_FIELD_OFFSET(LaneBoundary_BoundaryPoint, _impl_.width_)}},
    // optional double height = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 2, 0, PROTOBUF_FIELD_OFFSET(LaneBoundary_BoundaryPoint, _impl_.height_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.Vector3d position = 1;
    {PROTOBUF_FIELD_OFFSET(LaneBoundary_BoundaryPoint, _impl_.position_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional double width = 2;
    {PROTOBUF_FIELD_OFFSET(LaneBoundary_BoundaryPoint, _impl_.width_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double height = 3;
    {PROTOBUF_FIELD_OFFSET(LaneBoundary_BoundaryPoint, _impl_.height_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .osi3.LaneBoundary.BoundaryPoint.Dash dash = 4;
    {PROTOBUF_FIELD_OFFSET(LaneBoundary_BoundaryPoint, _impl_.dash_), _Internal::kHasBitsOffset + 3, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Vector3d>()},
    {0, 6},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void LaneBoundary_BoundaryPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LaneBoundary.BoundaryPoint)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.position_ != nullptr);
    _impl_.position_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.width_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.dash_) -
        reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.dash_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* LaneBoundary_BoundaryPoint::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const LaneBoundary_BoundaryPoint& this_ = static_cast<const LaneBoundary_BoundaryPoint&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* LaneBoundary_BoundaryPoint::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const LaneBoundary_BoundaryPoint& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.LaneBoundary.BoundaryPoint)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.Vector3d position = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.position_, this_._impl_.position_->GetCachedSize(), target,
                stream);
          }

          // optional double width = 2;
          if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                2, this_._internal_width(), target);
          }

          // optional double height = 3;
          if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                3, this_._internal_height(), target);
          }

          // optional .osi3.LaneBoundary.BoundaryPoint.Dash dash = 4;
          if (cached_has_bits & 0x00000008u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                4, this_._internal_dash(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.LaneBoundary.BoundaryPoint)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t LaneBoundary_BoundaryPoint::ByteSizeLong(const MessageLite& base) {
          const LaneBoundary_BoundaryPoint& this_ = static_cast<const LaneBoundary_BoundaryPoint&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t LaneBoundary_BoundaryPoint::ByteSizeLong() const {
          const LaneBoundary_BoundaryPoint& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.LaneBoundary.BoundaryPoint)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x0000000fu) {
            // optional .osi3.Vector3d position = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.position_);
            }
            // optional double width = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 9;
            }
            // optional double height = 3;
            if (cached_has_bits & 0x00000004u) {
              total_size += 9;
            }
            // optional .osi3.LaneBoundary.BoundaryPoint.Dash dash = 4;
            if (cached_has_bits & 0x00000008u) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_dash());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void LaneBoundary_BoundaryPoint::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LaneBoundary_BoundaryPoint*>(&to_msg);
  auto& from = static_cast<const LaneBoundary_BoundaryPoint&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.LaneBoundary.BoundaryPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.position_ != nullptr);
      if (_this->_impl_.position_ == nullptr) {
        _this->_impl_.position_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Vector3d>(arena, *from._impl_.position_);
      } else {
        _this->_impl_.position_->MergeFrom(*from._impl_.position_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.dash_ = from._impl_.dash_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LaneBoundary_BoundaryPoint::CopyFrom(const LaneBoundary_BoundaryPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LaneBoundary.BoundaryPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LaneBoundary_BoundaryPoint::InternalSwap(LaneBoundary_BoundaryPoint* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LaneBoundary_BoundaryPoint, _impl_.dash_)
      + sizeof(LaneBoundary_BoundaryPoint::_impl_.dash_)
      - PROTOBUF_FIELD_OFFSET(LaneBoundary_BoundaryPoint, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::google::protobuf::Metadata LaneBoundary_BoundaryPoint::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LaneBoundary_Classification::_Internal {
 public:
  using HasBits =
      decltype(std::declval<LaneBoundary_Classification>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LaneBoundary_Classification, _impl_._has_bits_);
};

void LaneBoundary_Classification::clear_limiting_structure_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limiting_structure_id_.Clear();
}
LaneBoundary_Classification::LaneBoundary_Classification(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.LaneBoundary.Classification)
}
inline PROTOBUF_NDEBUG_INLINE LaneBoundary_Classification::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::LaneBoundary_Classification& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        limiting_structure_id_{visibility, arena, from.limiting_structure_id_} {}

LaneBoundary_Classification::LaneBoundary_Classification(
    ::google::protobuf::Arena* arena,
    const LaneBoundary_Classification& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LaneBoundary_Classification* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, type_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, type_),
           offsetof(Impl_, color_) -
               offsetof(Impl_, type_) +
               sizeof(Impl_::color_));

  // @@protoc_insertion_point(copy_constructor:osi3.LaneBoundary.Classification)
}
inline PROTOBUF_NDEBUG_INLINE LaneBoundary_Classification::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        limiting_structure_id_{visibility, arena} {}

inline void LaneBoundary_Classification::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, type_),
           0,
           offsetof(Impl_, color_) -
               offsetof(Impl_, type_) +
               sizeof(Impl_::color_));
}
LaneBoundary_Classification::~LaneBoundary_Classification() {
  // @@protoc_insertion_point(destructor:osi3.LaneBoundary.Classification)
  SharedDtor(*this);
}
inline void LaneBoundary_Classification::SharedDtor(MessageLite& self) {
  LaneBoundary_Classification& this_ = static_cast<LaneBoundary_Classification&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* LaneBoundary_Classification::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) LaneBoundary_Classification(arena);
}
constexpr auto LaneBoundary_Classification::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(LaneBoundary_Classification, _impl_.limiting_structure_id_) +
          decltype(LaneBoundary_Classification::_impl_.limiting_structure_id_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(LaneBoundary_Classification), alignof(LaneBoundary_Classification), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&LaneBoundary_Classification::PlacementNew_,
                                 sizeof(LaneBoundary_Classification),
                                 alignof(LaneBoundary_Classification));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull LaneBoundary_Classification::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_LaneBoundary_Classification_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &LaneBoundary_Classification::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<LaneBoundary_Classification>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &LaneBoundary_Classification::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<LaneBoundary_Classification>(), &LaneBoundary_Classification::ByteSizeLong,
            &LaneBoundary_Classification::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(LaneBoundary_Classification, _impl_._cached_size_),
        false,
    },
    &LaneBoundary_Classification::kDescriptorMethods,
    &descriptor_table_osi_5flane_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* LaneBoundary_Classification::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> LaneBoundary_Classification::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LaneBoundary_Classification, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::LaneBoundary_Classification>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .osi3.LaneBoundary.Classification.Type type = 1;
    {::_pbi::TcParser::FastEr0S1,
     {8, 0, 15, PROTOBUF_FIELD_OFFSET(LaneBoundary_Classification, _impl_.type_)}},
    // optional .osi3.LaneBoundary.Classification.Color color = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 1, 9, PROTOBUF_FIELD_OFFSET(LaneBoundary_Classification, _impl_.color_)}},
    // repeated .osi3.Identifier limiting_structure_id = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(LaneBoundary_Classification, _impl_.limiting_structure_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.LaneBoundary.Classification.Type type = 1;
    {PROTOBUF_FIELD_OFFSET(LaneBoundary_Classification, _impl_.type_), _Internal::kHasBitsOffset + 0, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .osi3.LaneBoundary.Classification.Color color = 2;
    {PROTOBUF_FIELD_OFFSET(LaneBoundary_Classification, _impl_.color_), _Internal::kHasBitsOffset + 1, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // repeated .osi3.Identifier limiting_structure_id = 3;
    {PROTOBUF_FIELD_OFFSET(LaneBoundary_Classification, _impl_.limiting_structure_id_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {0, 16},
    {0, 10},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void LaneBoundary_Classification::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LaneBoundary.Classification)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.limiting_structure_id_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.type_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.color_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.color_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* LaneBoundary_Classification::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const LaneBoundary_Classification& this_ = static_cast<const LaneBoundary_Classification&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* LaneBoundary_Classification::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const LaneBoundary_Classification& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.LaneBoundary.Classification)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.LaneBoundary.Classification.Type type = 1;
          if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                1, this_._internal_type(), target);
          }

          // optional .osi3.LaneBoundary.Classification.Color color = 2;
          if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                2, this_._internal_color(), target);
          }

          // repeated .osi3.Identifier limiting_structure_id = 3;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_limiting_structure_id_size());
               i < n; i++) {
            const auto& repfield = this_._internal_limiting_structure_id().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    3, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.LaneBoundary.Classification)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t LaneBoundary_Classification::ByteSizeLong(const MessageLite& base) {
          const LaneBoundary_Classification& this_ = static_cast<const LaneBoundary_Classification&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t LaneBoundary_Classification::ByteSizeLong() const {
          const LaneBoundary_Classification& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.LaneBoundary.Classification)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .osi3.Identifier limiting_structure_id = 3;
            {
              total_size += 1UL * this_._internal_limiting_structure_id_size();
              for (const auto& msg : this_._internal_limiting_structure_id()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // optional .osi3.LaneBoundary.Classification.Type type = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
            }
            // optional .osi3.LaneBoundary.Classification.Color color = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_color());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void LaneBoundary_Classification::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LaneBoundary_Classification*>(&to_msg);
  auto& from = static_cast<const LaneBoundary_Classification&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.LaneBoundary.Classification)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_limiting_structure_id()->MergeFrom(
      from._internal_limiting_structure_id());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.color_ = from._impl_.color_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LaneBoundary_Classification::CopyFrom(const LaneBoundary_Classification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LaneBoundary.Classification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LaneBoundary_Classification::InternalSwap(LaneBoundary_Classification* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.limiting_structure_id_.InternalSwap(&other->_impl_.limiting_structure_id_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LaneBoundary_Classification, _impl_.color_)
      + sizeof(LaneBoundary_Classification::_impl_.color_)
      - PROTOBUF_FIELD_OFFSET(LaneBoundary_Classification, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::google::protobuf::Metadata LaneBoundary_Classification::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LaneBoundary::_Internal {
 public:
  using HasBits =
      decltype(std::declval<LaneBoundary>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LaneBoundary, _impl_._has_bits_);
};

void LaneBoundary::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void LaneBoundary::clear_source_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_reference_.Clear();
}
void LaneBoundary::clear_color_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.color_description_ != nullptr) _impl_.color_description_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
LaneBoundary::LaneBoundary(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:osi3.LaneBoundary)
}
inline PROTOBUF_NDEBUG_INLINE LaneBoundary::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::osi3::LaneBoundary& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        boundary_line_{visibility, arena, from.boundary_line_},
        source_reference_{visibility, arena, from.source_reference_} {}

LaneBoundary::LaneBoundary(
    ::google::protobuf::Arena* arena,
    const LaneBoundary& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LaneBoundary* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.id_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(
                              arena, *from._impl_.id_)
                        : nullptr;
  _impl_.classification_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::osi3::LaneBoundary_Classification>(
                              arena, *from._impl_.classification_)
                        : nullptr;
  _impl_.color_description_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::Message::CopyConstruct<::osi3::ColorDescription>(
                              arena, *from._impl_.color_description_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:osi3.LaneBoundary)
}
inline PROTOBUF_NDEBUG_INLINE LaneBoundary::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        boundary_line_{visibility, arena},
        source_reference_{visibility, arena} {}

inline void LaneBoundary::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, color_description_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::color_description_));
}
LaneBoundary::~LaneBoundary() {
  // @@protoc_insertion_point(destructor:osi3.LaneBoundary)
  SharedDtor(*this);
}
inline void LaneBoundary::SharedDtor(MessageLite& self) {
  LaneBoundary& this_ = static_cast<LaneBoundary&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.id_;
  delete this_._impl_.classification_;
  delete this_._impl_.color_description_;
  this_._impl_.~Impl_();
}

inline void* LaneBoundary::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) LaneBoundary(arena);
}
constexpr auto LaneBoundary::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(LaneBoundary, _impl_.boundary_line_) +
          decltype(LaneBoundary::_impl_.boundary_line_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(LaneBoundary, _impl_.source_reference_) +
          decltype(LaneBoundary::_impl_.source_reference_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(LaneBoundary), alignof(LaneBoundary), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&LaneBoundary::PlacementNew_,
                                 sizeof(LaneBoundary),
                                 alignof(LaneBoundary));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull LaneBoundary::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_LaneBoundary_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &LaneBoundary::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<LaneBoundary>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &LaneBoundary::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<LaneBoundary>(), &LaneBoundary::ByteSizeLong,
            &LaneBoundary::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(LaneBoundary, _impl_._cached_size_),
        false,
    },
    &LaneBoundary::kDescriptorMethods,
    &descriptor_table_osi_5flane_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* LaneBoundary::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 5, 0, 2> LaneBoundary::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LaneBoundary, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    5,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::osi3::LaneBoundary>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .osi3.Identifier id = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(LaneBoundary, _impl_.id_)}},
    // repeated .osi3.LaneBoundary.BoundaryPoint boundary_line = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 1, PROTOBUF_FIELD_OFFSET(LaneBoundary, _impl_.boundary_line_)}},
    // optional .osi3.LaneBoundary.Classification classification = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 2, PROTOBUF_FIELD_OFFSET(LaneBoundary, _impl_.classification_)}},
    // repeated .osi3.ExternalReference source_reference = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 3, PROTOBUF_FIELD_OFFSET(LaneBoundary, _impl_.source_reference_)}},
    // optional .osi3.ColorDescription color_description = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 2, 4, PROTOBUF_FIELD_OFFSET(LaneBoundary, _impl_.color_description_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .osi3.Identifier id = 1;
    {PROTOBUF_FIELD_OFFSET(LaneBoundary, _impl_.id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.LaneBoundary.BoundaryPoint boundary_line = 2;
    {PROTOBUF_FIELD_OFFSET(LaneBoundary, _impl_.boundary_line_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.LaneBoundary.Classification classification = 3;
    {PROTOBUF_FIELD_OFFSET(LaneBoundary, _impl_.classification_), _Internal::kHasBitsOffset + 1, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .osi3.ExternalReference source_reference = 4;
    {PROTOBUF_FIELD_OFFSET(LaneBoundary, _impl_.source_reference_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .osi3.ColorDescription color_description = 5;
    {PROTOBUF_FIELD_OFFSET(LaneBoundary, _impl_.color_description_), _Internal::kHasBitsOffset + 2, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::osi3::Identifier>()},
    {::_pbi::TcParser::GetTable<::osi3::LaneBoundary_BoundaryPoint>()},
    {::_pbi::TcParser::GetTable<::osi3::LaneBoundary_Classification>()},
    {::_pbi::TcParser::GetTable<::osi3::ExternalReference>()},
    {::_pbi::TcParser::GetTable<::osi3::ColorDescription>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void LaneBoundary::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LaneBoundary)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.boundary_line_.Clear();
  _impl_.source_reference_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.id_ != nullptr);
      _impl_.id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.classification_ != nullptr);
      _impl_.classification_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.color_description_ != nullptr);
      _impl_.color_description_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* LaneBoundary::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const LaneBoundary& this_ = static_cast<const LaneBoundary&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* LaneBoundary::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const LaneBoundary& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:osi3.LaneBoundary)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // optional .osi3.Identifier id = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.id_, this_._impl_.id_->GetCachedSize(), target,
                stream);
          }

          // repeated .osi3.LaneBoundary.BoundaryPoint boundary_line = 2;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_boundary_line_size());
               i < n; i++) {
            const auto& repfield = this_._internal_boundary_line().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    2, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // optional .osi3.LaneBoundary.Classification classification = 3;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.classification_, this_._impl_.classification_->GetCachedSize(), target,
                stream);
          }

          // repeated .osi3.ExternalReference source_reference = 4;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_source_reference_size());
               i < n; i++) {
            const auto& repfield = this_._internal_source_reference().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    4, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // optional .osi3.ColorDescription color_description = 5;
          if (cached_has_bits & 0x00000004u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                5, *this_._impl_.color_description_, this_._impl_.color_description_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:osi3.LaneBoundary)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t LaneBoundary::ByteSizeLong(const MessageLite& base) {
          const LaneBoundary& this_ = static_cast<const LaneBoundary&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t LaneBoundary::ByteSizeLong() const {
          const LaneBoundary& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:osi3.LaneBoundary)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .osi3.LaneBoundary.BoundaryPoint boundary_line = 2;
            {
              total_size += 1UL * this_._internal_boundary_line_size();
              for (const auto& msg : this_._internal_boundary_line()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .osi3.ExternalReference source_reference = 4;
            {
              total_size += 1UL * this_._internal_source_reference_size();
              for (const auto& msg : this_._internal_source_reference()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000007u) {
            // optional .osi3.Identifier id = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.id_);
            }
            // optional .osi3.LaneBoundary.Classification classification = 3;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.classification_);
            }
            // optional .osi3.ColorDescription color_description = 5;
            if (cached_has_bits & 0x00000004u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.color_description_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void LaneBoundary::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LaneBoundary*>(&to_msg);
  auto& from = static_cast<const LaneBoundary&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:osi3.LaneBoundary)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_boundary_line()->MergeFrom(
      from._internal_boundary_line());
  _this->_internal_mutable_source_reference()->MergeFrom(
      from._internal_source_reference());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.id_ != nullptr);
      if (_this->_impl_.id_ == nullptr) {
        _this->_impl_.id_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::Identifier>(arena, *from._impl_.id_);
      } else {
        _this->_impl_.id_->MergeFrom(*from._impl_.id_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.classification_ != nullptr);
      if (_this->_impl_.classification_ == nullptr) {
        _this->_impl_.classification_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::LaneBoundary_Classification>(arena, *from._impl_.classification_);
      } else {
        _this->_impl_.classification_->MergeFrom(*from._impl_.classification_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.color_description_ != nullptr);
      if (_this->_impl_.color_description_ == nullptr) {
        _this->_impl_.color_description_ =
            ::google::protobuf::Message::CopyConstruct<::osi3::ColorDescription>(arena, *from._impl_.color_description_);
      } else {
        _this->_impl_.color_description_->MergeFrom(*from._impl_.color_description_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LaneBoundary::CopyFrom(const LaneBoundary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LaneBoundary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LaneBoundary::InternalSwap(LaneBoundary* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.boundary_line_.InternalSwap(&other->_impl_.boundary_line_);
  _impl_.source_reference_.InternalSwap(&other->_impl_.source_reference_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LaneBoundary, _impl_.color_description_)
      + sizeof(LaneBoundary::_impl_.color_description_)
      - PROTOBUF_FIELD_OFFSET(LaneBoundary, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata LaneBoundary::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace osi3
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ PROTOBUF_UNUSED =
        (::_pbi::AddDescriptors(&descriptor_table_osi_5flane_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
